

# 单向链表的介绍与创建

1. 链表的作用
   1) 存储数据

2. 链表的优点
   1) 受存储空间的影响较小
   2) 链表中的每一个节点，都是一个单独的小空间
      1) 这些小空间的位置没有要求，可以是任意的位置，哪怕在犄角旮旯中也可以
   
3. 链表的缺点
   1) 每一个节点都存在额外的开销
      1) 链表的每一个节点都是一个单独的空间，并且这些空间的位置没有特殊的要求
      2) 所以每个节点中，都需要额外的开销，保存下一个节点的位置，以便可以找到该节点
      3) 并且，链表中的每个节点，建立起联系
   2) 查询速度不如数组快
      1) 查询某个节点，需要先获取到父节点
      2) 然后从父节点中，获取到当前节点的地址，从而访问到当前的节点
      3) 所以，需要从根节点开始获取
      4) 而数组获取数据，直接根据第一个节点的地址，计算出相应节点的地址索引，是十分高效的


4. 链表的特点
   1) 链表中的每一个节点，都认为自己是根节点，只针对单向链表
      1) 原因: 单向链表中的节点，只知道自己的子级是谁，无法知道自己的父级是谁
      2) 所以: 单向链表中的每一个节点都认为自己是根节点
   2) 由于单向链表中的每一个节点都认为自己是根节点
      1) 所以，**从每个节点到最后都是一个完整的链表**
      2) 比如: A -> B -> C -> D是一个链表
         1) 取出一段链表: B -> C -> D，也是一个完整的链表
         2) 因为B不知道上面存在A


5. 链表的创建代码
```js
/** 链表的结构
 *    A -> B -> C -> D -> E -> F   
 */

function LianBiao(value) {
    this.value = value;
    this.xia = null;
}
const A = new LianBiao("A");
const B = new LianBiao("B");
const C = new LianBiao("C");
const D = new LianBiao("D");
const E = new LianBiao("E");
const F = new LianBiao("F");
A.xia = B;
B.xia = C;
C.xia = D;
D.xia = E;
E.xia = F;
F.xia = null;
```





# 单向链表的遍历

1. 方式
   1) 利用链表的最后一个节点的指向，进行遍历
   2) 即: 使用迭代进行遍历，当遇到节点的指向为null的时候，退出迭代

2. 示范代码
```js
function forEach(biao) {
    // 上次迭代已经是最后一个节点，本次迭代传入的biao为null，直接退出
    if(biao == null) return;
    console.log(biao.value);
    forEach(biao.xia);
}
forEach(A);
```






# 获取链表的长度

1. 方式
   1) 每递归一次，长度加一


2. 示范代码
```js
function index(biao) {
    return _(biao);
    function _(biao, i = 0) {
        if(biao == null) return i;
        return _(biao.xia, i + 1);
    }
}
console.log( index(A) ) 
```







# 通过下标获取某个链表的数据

1. 方式
   1) 传入链表的初始根节点，以及下标


2. 示范代码
```js
function cha(biao, index, i = 0) {
    return _(biao, index);
    function _(biao, index, i = 0) {
        if(biao == null) return null;
        if( i === index ) return biao.value;
        return _(biao.xia, index, i + 1);
    }
}
console.log( cha(A, 3) ) 
```





# 通过下标设置某个链表中的数据

1. 方式
   1) 传入链表的初始根节点，以及下标，以及设置的数据


2. 示范代码
```js
function she(biao, index, data) {
    _(biao, index, data);
    function _(biao, index, data, i = 0) {
        if(biao == null) return;
        if( i === index ) biao.value = data;
        else _(biao.xia, index, data, i + 1);
    }
}
she(A, 3, "DD");
```





# 在链表的某个节点后面加入一个新的节点

1. 方式
   1) 传入链表
   2) 传入链表中对应的节点
   3) 传入新插入的节点


2. 示范代码
```js
function tian(lian, jie, cha) {
    if(cha == null) return;
    if(jie == null) return;

    if(lian === jie) {
        // 之前下面的节点
        const jiu = lian.xia;
        // 放入新的节点
        lian.xia = cha;
        cha.xia = jiu;
        return;
    }
    tian(lian.xia, jie, cha);
}

tian(A, C, new LianBiao("G"));
```






# 在链表的某个位置插入节点

1. 方式
   1) 传入链表
   2) 传入位置
      1) 如果传入0，在开始的位置加入一个新的节点
      2) 如果传入的数据过大，在末尾添加一个节点
   3) 由于可能改变根节点(传入0)，所以该方法重新返回一条链表


2. 示范代码
```js
function tian(lian, index, cha) {
    return _(lian);

    function _(lian, i = 0) {
        // 最后一个节点
        if(lian == null) {
            if( i <= index ) {
                return cha;
            } 
            return null;
        }

        const jie = _(lian.xia, i + 1);
        // jie得到的是下一个节点，当前的节点的xia属性指向的就是下一个节点
        lian.xia = jie;
        
        // 拼接一个节点进行返回
        if( i === index) {
            cha.xia = lian;
            return cha;
        }

        return lian;
    }
}

const DD = tian(A, 100, new LianBiao("G"));
console.log(DD);
```






# 在链表的末尾加入新的节点

1. 方式
   1) 利用链表的末尾指向null，进行添加
   2) 传入链表，传入新的节点


2. 示范代码
```js
function tian(lian, cha) {
    if( lian === null ) return;
    if( lian.xia === null ) {
        lian.xia = cha;
        return;
    }

    tian(lian.xia, cha);
}
tian(A, new LianBiao("G"));
console.log(A);
```





# 删除链表的节点


1. 方式
   1) 可能删除根节点，所以该方法重新返回一个链表
   2) 传入链表、传入要删除的节点或者传入删除节点的位置，如果传入的位置过大，则不进行删除


2. 示范代码
```js
function _delete(lian, jie) {
    if(lian == null || jie == null) return;

    // 如果传入的是位置，当前标记标志为true
    let boolear = false;
    if( typeof jie === "number" ) {
        boolear = true;
    }
    return _(lian);


    function _(lian, index = 0) {
        if(lian == null) return null;
        // 得到下一个节点
        const jie_dian = _( lian.xia, index + 1 );

        // 当前节点进行指向
        lian.xia = jie_dian;
        
        // 删除当前节点
        if(boolear && index === jie) {
            // 改变返回值，返回当前节点的下一个节点
            // 则当前节点的上一个节点在进行拼接的时候，就不在拼接当前节点，相当于删除
            return lian.xia;
        }else if(lian === jie) {
            return lian.xia;
        }
        return lian;
    }
}

const SS = _delete(A, B);
console.log(SS);
```





# 单向链表的逆置

1. 原理
   1) 当前的节点的下一个节点的指向属性，指向当前节点
   2) 当前节点的指向属性，指向null
   3) 先进行递归，然后在改变指向
      1) 如果先改变指向，在进行递归，由于当前节点的指向变为了null
      2) 所以递归无法完成，后面的节点也无法获取



2. 示范代码
```js
function ni_zhi(lian) {
    function nizhi(lian) {
    // 返回最后一个节点，即逆置后的根节点
    if(lian.xia === null) return lian;
    // 先进行递归
    const xin = nizhi(lian.xia);

    // 改变当前节点的下一个节点的指向属性，指向当前节点
    lian.xia.xia = lian;
    lian.xia = null;
    
    return xin;
}
// she(A, 3, "DD");

const s = nizhi(A, B);
console.log(s);
}
```






# 数组的冒泡排序

1. 原理
   1) 以此把大的数据(或者小的数据)移到数组的开头
   2) 遍历数组，依次比较每一位数据，只要符合条件，交换数组对应位中的数据

2. 示范代码
```js
function mao_pao(arr) {
    if(arr == null) return;
    for(let i = 0; i < arr.length; i ++) {
        for(let j = i + 1; j < arr.length; j ++) {
            if(arr[i] > arr[j]) {
                const a = arr[j];
                arr[j] = arr[i];
                arr[i] = a;
            }
        }
    }
}
```




# 数组的选择排序

1. 原理
   1) 与冒泡排序的方式基本相同
   2) 冒泡排序: 是只要符合条件，立马交换
   3) 选择排序: 只要符合条件，保存数组索引，当一圈循环完，找到了最大值，然后把它放在最后
      1) 只交换一次



2. 示范代码
```js
function xuan_ze(arr) {
    if(arr == null) return;
    var index = 0;
    for(let i = 0; i < arr.length; i ++) {
        index = i;
        for(let j = i + 1; j < arr.length; j ++) {
            if(arr[index] < arr[j]) {
                index = j;
            }
        }
        const a = arr[index];
        arr[index] = arr[i];
        arr[i] = a;
    }
}
```





# 数组的简单快速排序

1. 原理
   1) 找到第一个数据，然后把比他小的数据放在它的左侧，比他大的数据放在右侧
   2) 然后在排左侧的数据，和右侧的数据，同理
   3) 单独创建两个数组，一个存放小数据，一个存放大数据，浪费了一定的效率


2. 示范代码
```js
function kuai_pai(arr) {
    if( arr == null ) return;
    if( arr.length === 0 ) return [];
    let xiao = [];
    let da = [];
    const a = arr[0];
    for(let i = 1; i < arr.length; i ++) {
        if(arr[i] >= a) da.push(arr[i]);
        else xiao.push(arr[i]);
    }
    xiao = kuai_pai(xiao);
    da = kuai_pai(da);
    xiao.push(a);
    return xiao.concat(da);
}
```





# 数组的标准快速排序

1. 原理
   1) 找到第一个数据，然后把比他小的数据放在它的左侧，比他大的数据放在右侧
   2) 然后在排左侧的数据，和右侧的数据，同理
   3) 使用两个标记，一个标记左侧的是小数据，另一个标记的右侧是大数据


2. 示范代码
```js
function jiao_huan(arr, a1, a2) {
    const data = arr[a1];
    arr[a1] = arr[a2];
    arr[a2] = data;
}

function kuai_pai2(arr, a, b) {
    let left = a;
    let right = b;
    if(a >= b - 1) return;
    do {
        do left ++;  while( arr[a] > arr[left] && left < right )
        do right --; while( arr[a] <= arr[right] && left < right )

        if(left < right) jiao_huan(arr, left, right);
    } 
    while(left < right);
    const wei = left === right ? right - 1 : right;
    jiao_huan(arr, wei, a);

    kuai_pai2(arr, a, wei);
    kuai_pai2(arr, wei + 1, b);
}
```




# 双向数据链表

1. 优点
   1) 无论给出哪一个节点，都可以对整个链表进行遍历


2. 缺点
   1) 多浪费一个引用的空间
   2) 构建起来比较麻烦


3. 示范结构
```js
function Data(value) {
    this.value = value;
    this.next = null;
    this.pre = null;
}

// 创建双向数据列表
function createErData(...arr) {
    if(arr === null) return ;
    if(typeof arr !== "object") return ;
    for(let i = 1; i < arr.length - 1; i ++) {
        arr[i].next = arr[i + 1];
        arr[i].pre = arr[i - 1];
    }

    arr[arr.length - 1].pre = arr[arr.length - 2];
    arr[0].next = arr[1];
    return arr[0];
}

const a = new Data(1);
const b = new Data(2);
const c = new Data(3);
const erData = createErData(a, b, c);
```



# 树形结构介绍

1. 简介
   1) 树是一种有向无环的图
   2) 树是图的一种
   3) 图: 就是二维拓扑结构
      1) 每一个节点是一个独立的区域，节点与节点之间存在关系
      2) 这些节点无论位置怎么变换，它们之间的关系是不会变的
      3) 研究二维数据结构，研究的就是这些关系


2. 特点
   1) 树形结构有一个`根节点`，起始节点被称为`根节点`
   2) 树形结构中的末端，即下面没有节点的节点，被称为`叶子节点`
   3) 既不是根节点也不是叶子节点的节点，被称为`节点`
   4) `树的度`: 树形结构中，分叉最多的一个节点，分多少叉，则该树形结构的度就为多少
   5) `树的深度`: 树最深有几层，树形结构的深度就为多少





# 二叉树的概念

1. 介绍
   1) 每个节点最多有两个分叉的树形结构，被称为二叉树




# 满二叉树的概念

1. 介绍
   1) 除了叶子节点，每个节点都必须含有两个分叉点
   2) 所有的叶子节点，必须在最下面一层，并且位于同一深度




# 完全二叉树的概念

1. 国际定义
   1) 所有的叶子节点，必须在最下面一层、或者倒数第二层
   2) 除了叶子节点，每个节点都必须存在两个分叉


2. 中国定义
   1) 所有的叶子节点，必须在最下面一层、或者倒数第二层
   2) 某个节点，可以只有一个叶子节点，即一个分叉(存在叶子节点的，只有倒数第二个节点)
   3) 叶子节点，必须向一侧靠拢
      1) 可以只有一个叶子节点，但是叶子节点，必须向有两个叶子节点的分叉靠拢
      2) 比如: 左侧有两个叶子节点，单个的叶子节点必须在左侧，不能在右侧




# 二叉树中子树的概念

1. 介绍
   1) 二叉树中的每一个分叉，单独拿出来就是一个子树
   2) 二叉树中的每一个节点，包括叶子节点，都可以看成子树根节点
      1) 树形结构中，每一个节点，都是认为自己是根节点，只知道自己的子节点，不知道有没有父节点


2. 左子树
   1) 某个节点的左边分叉，被称为左子树


3. 右子树
   1) 某个节点的右边分叉，被称为右子树




# 二叉树的前序遍历

1. 介绍
   1) 前序遍历: 学名为先根次序遍历
   2) 遍历方式为: 先打印当前节点，在打印左子节点，在打印右子节点
      1) 打印完左子节点，如果左子节点还有子节点，继续向下遍历
      2) 左边分叉完全遍历完，在遍历右侧分叉


2. 示例分析
```js
         A
   B            C
D     E      F     G  

// 打印顺序: ABDECFG
```


3. 根据上面的二叉树实例，构建对应的二叉树，并且以前序遍历的方式遍历该二叉树
```js
// 创建二叉树
function ErChaShu(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}
const A = new ErChaShu("A");
const B = new ErChaShu("B");
const C = new ErChaShu("C");
const D = new ErChaShu("D");
const E = new ErChaShu("E");
const F = new ErChaShu("F");
const G = new ErChaShu("G");
A.left = B;
A.right = C;
B.left = D;
B.right = E;
C.left = F;
C.right = G;


// 遍历二叉树的方法
function qian(obj) {
    // 既是容错，也是出口(传入叶子节点的分支为null，直接退出，表示已经结束)
    if(obj === null) return;
    // 先打印当前的
    console.log(obj.value);
    // 在处理左
    qian(obj.left);
    // 在处理右
    qian(obj.right);
}

qian(A);
```





# 二叉树的中序遍历

1. 介绍
   1) 前序遍历: 学名为中根次序遍历
   2) 遍历方式为: 先打印左子节点，在打印当前节点，在打印右子节点
      1) 如果左子节点，还有子节点，继续向下查询，把左子节点作为下次遍历的当前节点，不进行打印
      2) 如果右子节点，还有子节点，继续向下查询，把右子节点作为下次遍历的当前节点，不进行打印


2. 示例分析
```js
         A
   B            C
D     E      F     G  

// 打印顺序: DBEAFCG
// 简单分析: 从左向右依次查
```


3. 根据上面的二叉树实例，构建对应的二叉树，并且以中序遍历的方式遍历该二叉树
```js
// 创建二叉树
function ErChaShu(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}
const A = new ErChaShu("A");
const B = new ErChaShu("B");
const C = new ErChaShu("C");
const D = new ErChaShu("D");
const E = new ErChaShu("E");
const F = new ErChaShu("F");
const G = new ErChaShu("G");
A.left = B;
A.right = C;
B.left = D;
B.right = E;
C.left = F;
C.right = G;


// 遍历二叉树的方法
function zhong(obj) {
    // 既是容错，也是出口(传入叶子节点的分支为null，直接退出，表示已经结束)
    if(obj === null) return;
    // 先处理左
    zhong(obj.left);
    // 在打印当前的
    console.log(obj.value);
    // 在处理右
    zhong(obj.right);
}

zhong(A);
```




# 二叉树的后序遍历

1. 介绍
   1) 前序遍历: 学名为后根次序遍历
   2) 遍历方式为: 先打印左子节点，在打印右子节点，在打印当前节点
      1) 如果左子节点，还有子节点，继续向下查询，把左子节点作为下次遍历的当前节点，不进行打印
      2) 如果右子节点，还有子节点，继续向下查询，把右子节点作为下次遍历的当前节点，不进行打印


2. 示例分析
```js
         A
   B            C
D     E      F     G  
     H I

// 打印顺序: DHIEBFGCA   
// A有子节点，分析顺序为BCA
// B有子节点: B先不打印，继续遍历DEB，把DEB替换A分析打印的B，变为DEBCA
// E有子节点: E先不打印，继续遍历HIE，把HIE替换B分析打印的E，变为DHIEBCA
// C有子节点: C先不打印，继续遍历FGC，把FGC替换A分析打印的C，变为DHIEBFGCA
```


3. 根据上面的二叉树实例，构建对应的二叉树，并且以中序遍历的方式遍历该二叉树
```js
// 创建二叉树
function ErChaShu(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}
const A = new ErChaShu("A");
const B = new ErChaShu("B");
const C = new ErChaShu("C");
const D = new ErChaShu("D");
const E = new ErChaShu("E");
const F = new ErChaShu("F");
const G = new ErChaShu("G");
const H = new ErChaShu("H");
const I = new ErChaShu("I");
A.left = B;
A.right = C;
B.left = D;
B.right = E;
C.left = F;
C.right = G;
E.left = H;
E.right = I;


// 遍历二叉树的方法
function hou(obj) {
    // 既是容错，也是出口(传入叶子节点的分支为null，直接退出，表示已经结束)
    if(obj === null) return;
    // 先处理左
    hou(obj.left);
    // 在处理右
    hou(obj.right);
    // 在打印当前的
    console.log(obj.value);
}

hou(A);
```





# 根据前序和中序，还原二叉树

1. 原理
   1) 前序中的第一个，就是根节点
   2) 中序中的根节点，左侧的为根节点的左分支，右侧的为右分支
   3) 根据中序中，得到的左分支和右分支的长度
   4) 可以在前序中，进行左分支和右分支的划分
   5) 根据前序中得到的左分支和右分支，其中的第一个，为分支的根节点
   6) 然后分支的根节点，可以去中序中，继续划分，分支的左右分支，依次类推
   7) 一直划分到树叶节点，此时在划分左右分支，得到的就是一个空数组


2. 代码实现
```js
// 创建二叉树
function ErChaShu(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}
// 前序
const qian = ["A", "B", "D", "E", "C", "F", "G"];
// 中序
const zhong = ["D", "B", "E", "A", "F", "C", "G"];

// 还原二叉树
function huan(qian, zhong) {
    if(qian == null || zhong == null 
    // 此处相当于出口
    || qian.length === 0 || zhong.length === 0 
    // 返回null，链条的终端为null
    || qian.length !== zhong.length) return null;
    
    // 把根节点创建出来
    const gen = new ErChaShu( qian[0] );
    // 得到中序中，根节点对应的位置，用于划分左右分支
    const index = zhong.indexOf( qian[0] );
    // 得到前序中，根节点左侧的节点
    const qianLeft = qian.slice(1, index + 1);
    // 得到中序中，根节点左侧的节点
    const zhongLeft = zhong.slice(0, index);
    // 得到前序中，根节点右侧的节点
    const qianRight = qian.slice(index + 1, qian.length);
    // 得到中序中，根节点右侧的节点
    const zhongRight = zhong.slice(index + 1, qian.length);
    // + 1是隔开根节点
    // 到最后，中序和前序中只有一个节点，叶子节点。所以得到的index = 0;
    // 截取操作，不是从1截取到1，就是从0截取到0，得到的都是空数组，触发出口

    
    // 拼接根节点的左侧分支(直接把左分支前和中序传入，进行递归，返回的就是左分支根节点)
    gen.left = huan(qianLeft, zhongLeft);
    // 拼接根节点的右侧分支(直接把右分支前和中序传入，进行递归，返回的就是右分支根节点)
    gen.right = huan(qianRight, zhongRight);
    
    return gen;
}
console.log( huan(qian, zhong) );
```





# 根据后序和中序，还原二叉树

1. 原理
   1) 后序中的最后一个，就是根节点
   2) 中序中的根节点，左侧的为根节点的左分支，右侧的为右分支
   3) 根据中序中，得到的左分支和右分支的长度
   4) 可以在后序中，进行左分支和右分支的划分
   5) 根据后序中得到的左分支和右分支，其中的最后一个，为分支的根节点
   6) 然后分支的根节点，可以去中序中，继续划分，分支的左右分支，依次类推
   7) 一直划分到树叶节点，此时在划分左右分支，得到的就是一个空数组


2. 代码实现
```js
// 创建二叉树
function ErChaShu(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}
// 后序
const hou = ["D", "H", "I", "E", "B", "F", "G", "C", "A"];
// 中序
const zhong = ["D", "B", "H", "E", "I", "A", "F", "C", "G"];

// 还原二叉树
function huan(hou, zhong) {
    if(hou == null || zhong == null 
    // 此处相当于出口
    || hou.length === 0 || zhong.length === 0 
    // 返回null，链条的终端为null
    || hou.length !== zhong.length) return null;
    
    // 把根节点创建出来
    const gen = new ErChaShu( hou[hou.length - 1] );
    // 得到中序中，根节点对应的位置，用于划分左右分支
    const index = zhong.indexOf( hou[hou.length - 1] );
    // 得到后序中，根节点左侧的节点
    const houLeft = hou.slice(0, index);
    // 得到中序中，根节点左侧的节点
    const zhongLeft = zhong.slice(0, index);
    // 得到后序中，根节点右侧的节点
    const houRight = hou.slice(index, hou.length - 1);
    // 得到中序中，根节点右侧的节点
    const zhongRight = zhong.slice(index + 1, hou.length);
    // + 1是隔开根节点
    // 到最后，中序和后序中只有一个节点，叶子节点。所以得到的index = 0;
    // 截取操作，不是从1截取到1，就是从0截取到0，得到的都是空数组，触发出口

    
    // 拼接根节点的左侧分支(直接把左分支后和中序传入，进行递归，返回的就是左分支根节点)
    gen.left = huan(houLeft, zhongLeft);
    // 拼接根节点的右侧分支(直接把右分支后和中序传入，进行递归，返回的就是右分支根节点)
    gen.right = huan(houRight, zhongRight);
    
    return gen;
}
console.log( huan(hou, zhong) );
```





# 二叉树的深度优先搜索

1. 原理
   1) 先查看当前的节点，如果当前的节点有分支，继续查看分支
   2) 分支查看完成，再跳到另一个分支继续查询


2. 示范代码
```js
// 查询二叉树中有没有某个数据的方法
function cha_xun(jie, data) {
    if(jie == null) return false;
    // 判断当前节点是不是
    console.log(jie.value);
    if( jie.value === data ) return true;
    // 判断左节点，如果左节点没有，继续递归，还是看左节点
    // 直到左节点查询完成，退出当前递归，进入上一个递归的右节点查询
    return cha_xun(jie.left, data) || cha_xun(jie.right, data);
}
```




# 二叉树的广度优先搜索

1. 原理
   1) 横向查询，一级一级的查询
   2) 适用于局域搜索
   3) 把所有的子节点，放入一个数组中，下次递归的时候，遍历该数组
   4) 同时把所有的子节点，放入数组中，继续迭代


2. 示范代码
```js
// 查询二叉树中有没有某个数据的方法
function cha_xun(jie, data) {
    if(jieArr == null) return false;
    // 最底层的叶子节点处理完成，传入的数组就是一个空数组
    if(jieArr.length === 0) return false;
    
    const arr = [];
    for(let i = 0; i < jieArr.length; i ++) {
        // 判断当前节点是不是
        console.log(jieArr[i].value);
        if( jieArr[i].value === data ) {
            return true;
        }else {
            if(jieArr[i].left) arr.push(jieArr[i].left);
            if(jieArr[i].right) arr.push(jieArr[i].right)
        }
    }

    return cha_xun2(arr, data);
}
console.log( cha_xun2([cha], "H") );
```






# 二叉树的比较(完全相同)

1. 原理
   1) 使用迭代，如果两个二叉树完全相同，则迭代停止，返回相同
   2) 如果两个二叉树的内容不同，或者一个存在一个不存在，则迭代停止，返回不同


2. 示范代码
```js
// 查询二叉树中有没有某个数据的方法
function bijiao(cha1, cha2) {
   
   // 同样也是出口，两个传入的是null;
   if( cha1 == cha2 ) return true;
   if( cha1.value !== cha2.value ) return false;
   if( cha1 == null && cha2 || cha2 == null && cha1 ) return false;


   // 否则继续迭代
   return bijiao(cha1.left, cha2.left) && bijiao(cha1.right, cha2.right);
}

console.log( bijiao(cha1, cha2) ) 
```




# 二叉树的比较(左右分支交换)

1. 原理
   1) 有的使用，二叉树的左右分支进行了互换，也是认为这两个二叉树相同
   2) 所以在进行迭代的时候，不光要迭代相同分支，也需要迭代判断左右互换


2. 示范代码
```js
// 查询二叉树中有没有某个数据的方法
function bijiao(cha1, cha2) {
   
   // 同样也是出口，两个传入的是null;
   if( cha1 == cha2 ) return true;
   if( cha1.value !== cha2.value ) return false;
   if( cha1 == null && cha2 || cha2 == null && cha1 ) return false;


   // 否则继续迭代
   return bijiao(cha1.left, cha2.left) && bijiao(cha1.right, cha2.right)
       // 或者左右分支互换
       || bijiao(cha1.left, cha2.right) && bijiao(cha1.right, cha2.left);
}

console.log( bijiao(cha1, cha2) ) 
```






# 二叉树的diss算法(得到两个树具体的不同信息)

1. 原理
   1) 把不同之处的节点，放在一个数组中
   2) 完全相同，数组中为空


2. 示范代码
```js
function diss(cha1, cha2, arr) {
   
    // 同样也是出口，两个传入的是null;
    if( cha1 == cha2 ) return true;
    // 表示新增
    else if(cha1 == null && cha2) {
        arr.push({ type: "增加", cha1: cha1, cha2: cha2 })
        // 增加，cha1没有对应的分支，无法进行向下迭代
    }
    // 表示删除
    else if(cha1 == null && cha2) {
        arr.push({ type: "删除", cha1: cha1, cha2: cha2 })
        // 删除，cha2没有对应的分支，无法进行向下迭代
    }
    // 表示发生了变化
    else if( cha1.value !== cha2.value ) {
        arr.push({ type: "不同", cha1: cha1, cha2: cha2 })

        // 内容发生变化，可能还存在子节点
        // 所以需要继续判断，由于下面的递归进不去，需要在该位置进去
        diss(cha1.left, cha2.left);
        diss(cha1.right, cha2.right);
    }
    // 表示相同，继续递归
    else {
        diss(cha1.left, cha2.left, arr);
        diss(cha1.right, cha2.right, arr);
    }
}

const arr = [];
diss(cha1, cha2, arr);
console.log(arr);
```





# 普利姆算法构建图的最小生成树

1. 介绍
   1) 普利姆算法，又被称为加点法
   2) 连一次加一个点


2. 原理
   1) 遍历所有已经建立联系的节点，找到与其可以连接的节点，然后建立关系，并且保存
   2) 可以连接的节点，不能是已经建立关系的节点
   3) 可以连接的节点，距离必须最短


3. 示范代码
```js
function ErChaShu(value) {
    this.value = value;
    // 保存该节点，与那些节点进行了相连
    this.guan = [];
}
const max = Infinity;
const jie_dian = [new ErChaShu("A"), new ErChaShu("B"), 
    new ErChaShu("C"), new ErChaShu("D"), new ErChaShu("E")];

// max表示节点间不相连，数据，表示对应节点相连所需的距离。0表示自己与自己相连
const jv_li = [
    [0, 4, 7, max, max],  // A
    [4, 0, 8, 6, max],    // B
    [7, 8, 0, 5, max],    // C
    [max, 6, 5, 0, 7],    // D
    [max, max, max, 7, 0] // E
]


function guan_xi(qi_zhong) {
    qi_zhong[0].guan.push(qi_zhong[1]);
    qi_zhong[1].guan.push(qi_zhong[0]);
}

function ji_suan_qi_zhong(jie_dian, jv_li, jie_dian_arr) {
    let qi_dian = null;
    let zhong_dian = null;
    let zui_duan_jv_li = max;

    for(let i = 0; i < jie_dian_arr.length; i ++) {
        const index = jie_dian.indexOf( jie_dian_arr[i] );
        // 取出与该节点相连的，所有节点的距离，找到最小的
        const jv = jv_li[ index ];
        for(let j = 0; j < jv.length; j ++) {
            if(index !== -1     // 节点存在
               && jv[j] !== 0   // 起点和终点不是同一个节点
               && jv[j] < max   // 距离更小
               && jie_dian_arr.indexOf( jie_dian[j] ) === -1 // 终点没有在节点记录中
            ) {
                // 更新数据
                qi_dian = jie_dian_arr[i];
                zhong_dian = jie_dian[j];
                zui_duan_jv_li = jv[j];
            }
        } 
    }

    // 遍历完，得到一个最小距离的起点和终点，进行返回
    return [qi_dian, zhong_dian];
}

function jia_dian_fa(jie_dian, jv_li) {
    // 随便找一个起始点
    const qi_shi = jie_dian[2];
    // 保存已经相连的节点
    const jie_dian_arr = [];
    jie_dian_arr.push(qi_shi);

    // 循环建立关系表
    while(true) {
        // 从节点集合中，找到距离最短，可以相连的节点
        const qi_zhong = ji_suan_qi_zhong(jie_dian, jv_li, jie_dian_arr);
        // 把终点保存在节点表中
        jie_dian_arr.push( qi_zhong[1] );
        // 建立起点与终点的关系表
        guan_xi(qi_zhong);

        // 当保存的节点集合与给定的节点集合的长度相同，表示所有节点已经处理完成，可以退出
        if(jie_dian_arr.length === jie_dian.length) {
            return jie_dian_arr;
        }
    }
    
}

var a = jia_dian_fa(jie_dian, jv_li);
console.log(a);
```





# 克鲁斯卡尔算法构建图的最小生成树

1. 介绍
   1) 克鲁斯卡尔算法，又被称为加边法
   2) 对边进行分析，找到最小的边，进行连接


2. 原理
   1) 找到一个最小的边，找到该边的两个端点节点
   2) 建立起部落，保存线两端的节点
   3) 可以建立节点关系的情况
      1) 如果距离最短，并且两端节点都没有保存过，创建一个部落，保存这两个节点
      2) 如果距离最短，并且两端节点，有一端已经保存到一个部落中，另一个节点也保存到该部落中
      3) 如果距离最短，并且两端节点都已经保存在部落中，但是位于不同的部落
         1) 把后面的部落删除，把该部落中的节点保存到前一个部落中
      4) 最终，只剩一个部落，并且该部落中保存了所有的节点，则构建完成
      5) 部落就是一个描述已经建立关系的节点的集合
         1) 不同的部落是，有些节点已经建立起关系，但是它们的关系不是连一块的


3. 示范代码
```js
function ErChaShu(value) {
    this.value = value;
    // 保存该节点，与那些节点进行了相连
    this.guan = [];
}
const max = Infinity;
const jie_dian = [new ErChaShu("A"), new ErChaShu("B"), 
    new ErChaShu("C"), new ErChaShu("D"), new ErChaShu("E")];

const jv_li = [
    [0, 4, 7, max, max],  // A
    [4, 0, 8, 6, max],    // B
    [7, 8, 0, 5, max],    // C
    [max, 6, 5, 0, 7],    // D
    [max, max, max, 7, 0] // E
]


function link(qi_dian, zhong_dian, bu_luo) {
    if(qi_dian == null || zhong_dian == null || bu_luo == null) return false;
    
    let qi = null;
    let zhong = null;
    // 遍历部落集合中的每一个部落，查看本次节点是否符合条件
    for(let i = 0; i < bu_luo.length; i ++) {
        // 表示部落中有起点
        if( bu_luo[i].indexOf(qi_dian) !== -1 ) {
            // 保存起点部落
            qi = bu_luo[i];
        }
        // 表示部落中有终点
        if( bu_luo[i].indexOf(zhong_dian) !== -1 ) {
            // 保存终点部落
            zhong = bu_luo[i];
        }
    }
    
    // 起点和终点没有部落可以相连
    if(!qi && !zhong) {
        // 创建一个新部落
        const arr = [];
        arr.push(qi_dian, zhong_dian);
        bu_luo.push(arr);
    }
    // 起点和终点有一个有部落可以相连
    if(!qi && zhong || qi && !zhong) {
        // 起点有部落，说明起点已经保存，此时需要保存终点
        qi && qi.push(zhong_dian);
        // 终点有部落，说明终点已经保存，此时需要保存起点
        zhong && zhong.push(qi_dian);
    }
    // 起点和终点不在同一个部落可以相连
    if(qi && zhong && qi !== zhong) {
        // 获取到终点部落的位置
        const index = bu_luo.indexOf(zhong);
        // 删除终点部落，会返回删除的部落
        bu_luo.splice(index, 1);
        // 把删除的部落合并到起点部落中，表示它们已经相连
        qi.push( ...zhong );
    };

    qi_dian.guan.push(zhong_dian);
    zhong_dian.guan.push(qi_dian);
}

function ji_suan_qi_zhong(jie_dian, jv_li, bu_luo) {
    let qi_dian = null;
    let zhong_dian = null;
    let xiao_jv = max;

    // 遍历距离集合，找到符合条件的最小的边
    for(let i = 0; i < jv_li.length; i ++) {
        for(let j = 0; j < jv_li[i].length; j ++) {
            if( jv_li[i][j] !== 0                    // 起点与终点相同
                && jv_li[i][j] < xiao_jv             // 距离更小
                // 该过程是使用部落进行判断，不能操作部落，即使操作代码与之相同，也不能操作
                // 循环判断，要保存条件的一致性，所以不能操作部落
                && pan_link(jie_dian[i], jie_dian[j], bu_luo, ) // 看看本次小距离是否满足连接条件
            ) {
                // 更新数据
                qi_dian = jie_dian[i];
                zhong_dian = jie_dian[j];
                xiao_jv = jv_li[i][j];
            }
        }
    }

    // 遍历完，得到一个最小距离的起点和终点，进行返回
    return [qi_dian, zhong_dian];
}

function pan_link(qi_dian, zhong_dian, bu_luo) {
    if(qi_dian == null || zhong_dian == null || bu_luo == null) return false;
    
    let qi = null;
    let zhong = null;
    // 遍历部落集合中的每一个部落，查看本次节点是否符合条件
    for(let i = 0; i < bu_luo.length; i ++) {
        // 表示部落中有起点
        if( bu_luo[i].indexOf(qi_dian) !== -1 ) {
            // 保存起点部落
            qi = bu_luo[i];
        }
        // 表示部落中有终点
        if( bu_luo[i].indexOf(zhong_dian) !== -1 ) {
            // 保存终点部落
            zhong = bu_luo[i];
        }
    }
    
    // 起点和终点没有部落可以相连
    if(!qi && !zhong) return true;
    // 起点和终点有一个有部落可以相连
    if(!qi && zhong || qi && !zhong) return true;
    // 起点和终点不在同一个部落可以相连
    if(qi && zhong && qi !== zhong) return true;
}

function jia_bian_fa(jie_dian, jv_li) {
    // 保存部落(二维数组)
    const bu_luo = [];

    while( true ) {// 得到一个最小的边的起点和终点
        const qi_zhong = ji_suan_qi_zhong(jie_dian, jv_li, bu_luo); 
        // 更新部落并且建立关系
        link(qi_zhong[0], qi_zhong[1], bu_luo);
        // 是否创建完成，退出循环
        if(bu_luo.length === 1 && bu_luo[0].length === jie_dian.length) {
            return bu_luo[0];
        }
    }
}

var a = jia_bian_fa(jie_dian, jv_li);
console.log(a);
```





# 二叉搜索树的构建

1. 作用
   1) 可以快速的判断某个数据集合中有没有某个数据
   2) **如果数据集合量过大，数组就不适合做查询工作，应该使用二叉搜索树**


2. 原理
   1) 把数据集合，构建成二叉搜索树
   2) 二叉搜索树的特点
      1) 节点的左分支永远比该节点的数据小
      2) 节点的右分支永远比该节点的数据大
   3) 随便取一个节点，进行分析，通常取第一个数据作为第一个节点进行分析


3. 二叉搜索树的构建示范代码
```js
// 创建二叉树
function ErChaShu(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}

// 创建数据集合
const arr = [];
for(let i = 0; i < 100; i ++) {
    arr.push( parseInt(Math.random() * 100)  );
}

// 比较数据
function bi_jiao(jie_dian, data) {
    if(jie_dian == null) return;
    // 当前的数据，与节点相同，不比再次处理
    if(jie_dian.value === data) return;

    // 没有创建，需要判断创建左右节点
    if(jie_dian.value < data) {   // 放右边子节点
        // 如果当前节点的右分支没有，可以直接创建
        if(jie_dian.right == null) jie_dian.right = new ErChaShu(data);
        // 如果当前节点的右分支存在，不能直接拼接，而是应该在与右分支进行比较
        else bi_jiao(jie_dian.right, data)
    }else if(jie_dian.value > data) {   // 放左边子节点
        // 如果当前节点的左分支没有，可以直接创建
        if(jie_dian.left == null) jie_dian.left = new ErChaShu(data);
        // 如果当前节点的左分支存在，不能直接拼接，而是应该在与左分支进行比较
        else bi_jiao(jie_dian.left, data)
    }
}

// 根据数据集合创建二叉搜索树
function create_sou_suo(arr) {
    if( arr == null ) return;
    // 取根节点数据，创建根节点
    const gen = new ErChaShu( arr[0] );
    // 遍历数据，与根节点比较，大的放右边，小的放左边
    for(let i = 0; i < arr.length; i ++) {
        // 每一个数据都与根节点进行比较，确定位置，然后一级一级的比较
        bi_jiao(gen, arr[i]);
    }
    return gen;
}

const a = create_sou_suo(arr);
console.log(a);
```






# 二叉搜索树的查询方法

1. 作用
   1) 快速查出二叉搜索树中有没有某个数据


2. 原理
   1) 取根节点进行分析
   2) 如果数大于根节点的数，则去右分支找
   3) 如果数小于根节点的数，则去左分支找
   4) 这样步骤会成倍的减少，排除大量的数据


3. 二叉搜索树的搜素示范代码
```js
// 创建一个二叉搜索树(上方的代码)
const sou = create_sou_suo(arr);


// 查询二叉搜索树中有没有某个数据
function cha_xun(cha, data) {
    // 二叉树已经查询完成，或者没有传入二叉树，表示没有数据，返回false
    if(cha == null) return false;
    // 如果当前的节点值，与比较值相同，表示存在该数据，返回true
    if(cha.value === data) return true;
    // 如果数据小，去左分支查询
    if( cha.value > data ) {
        return cha_xun(cha.left, data);
    }
    // 如果数据大，去右分支查询
    if( cha.value < data ) {
        return cha_xun(cha.right, data);
    }
}
console.log(  cha_xun(sou, 6) );
```







# 二叉平衡树的介绍

1. 介绍
   1) 每个节点的左右分支的长度差，不可以超过1
   2) 注意是每个节点，而不是最上面的根节点




# 判断一个二叉树是不是平衡二叉树

1. 原理
   1) 首先得到一个二叉树节点的长度
   2) 判断左右分支的长度差是否小于等于1


2. 示范代码
```js
// 创建二叉树
function ErChaShu(value) {
    this.value = value;
    this.left = null;
    this.right = null;
}

/** 二叉树
 *       A
 *   B       C
 *  D E   F     G
 *       H        I
 *                  J
 */

const A = new ErChaShu("A");
const B = new ErChaShu("B");
const C = new ErChaShu("C");
const D = new ErChaShu("D");
const E = new ErChaShu("E");
const F = new ErChaShu("F");
const G = new ErChaShu("G");
const H = new ErChaShu("H");
const I = new ErChaShu("I");
const J = new ErChaShu("J");
A.left = B;
A.right = C;
B.left = D;
B.right = E;
C.left = F;
C.right = G;
// 加上下面三个，A就变成了非平衡二叉树
F.left = H;
G.right = I;
I.right = J;

// 判断一个节点的长度
function length(jie, index) {
    // index为长度
    if(jie == null) return index;
    
    // index是传入节点的长度，向左分支查，长度在基础上加1，向右分支查，长度还是在基础上加1
    // 向下移一个节点，长度自然加一。
    const zuo = length(jie.left, index + 1);
    const you = length(jie.right, index + 1);
    // 判断左分支还是右分支长，返回最长的一个作为该节点的深度
    return zuo > you ? zuo : you;
}

// 判断一个二叉树是否为平衡二叉树
function pan_duan(cha) {
    // 如果迭代到叶子节点还满足平衡二叉树条件，此时已经是最后一个节点
    // 此时进行递归，传入的就是null(没有子节点了)
    // 返回true，表示已经满足平衡二叉树的条件
    if(cha == null) return true;
    
    // 节点的左分支长度
    const left = length(cha.left, 0);
    // 节点的右分支长度
    const right = length(cha.right, 0);

    // 判断该节点是否满足平衡二叉树的条件
    if( Math.abs(right - left) > 1 ) {
        // 不是平衡二叉树
        return false;
    }
    // 查看子节点是否符合平衡二叉树的条件，当前的节点符合
    else {
        return pan_duan(cha.left) && pan_duan(cha.right);
    }
}

console.log( pan_duan(A) );
```





# 二叉树的单旋(单旋简易版)

1. 作用
   1) 把一个非平衡二叉树的二叉树，变成平衡二叉树


2. 二叉树的单旋详解
   1) 单旋，共分为两种情况
      1) 根据左分支过长，还是右分支过长，它的旋转情况不同
      2) 共分为: 左单旋和右单旋
      3) 左单旋、右单旋并不是实现单旋的两种方式
         1) 而是，二叉树在进行单旋时，根据情况不同，采用的方式不同
         2) 根据不同的情况，划分的两种方式
   2) 左单旋
      1) 条件
         1) 某个节点不符合平衡二叉树的条件，即该节点的左、右分支的长度差大于1
         2) 并且，是**右分支的长度，大于左分支的长度**
         3) 此时需要左单旋
      2) 具体的单旋步骤
         1) **找新的根节点，替换旧的根节点**
            1) 新的根节点，即旧的根节点的右分支的根节点(即`?.right`)
         2) 更改分支
            1) 旧的根节点被新的根节点进行了替换，旧的根节点也不能舍弃
               1) **旧的根节点，会作为新的根节点的左分支**
            2) 旧的根节点替换了新的根节点的左分支，新的根节点的左分支也不能舍弃
               1) 由于新的根节点，就是旧的根节点的右分支
               2) 此时新的根节点替换完旧的根节点，则旧的根节点的右分支就空余出来了
               3) **新的根节点的左分支，就会作为旧的根节点的右分支**
            3) 新的根节点的右分支，还是之前的右分支
   3) 右单旋
      1) 条件
         1) 某个节点不符合平衡二叉树的条件，即该节点的左、右分支的长度差大于1
         2) 并且，是**左分支的长度，大于右分支的长度**
         3) 此时需要右单旋
      2) 具体的单旋步骤
         1) **找新的根节点，替换旧的根节点**
            1) 新的根节点，即旧的根节点的左分支的根节点(即`?.left`)
         2) 更改分支
            1) 旧的根节点被新的根节点进行了替换，旧的根节点也不能舍弃
               1) **旧的根节点，会作为新的根节点的右分支**
            2) 旧的根节点替换了新的根节点的右分支，新的根节点的右分支也不能舍弃
               1) 由于新的根节点，就是旧的根节点的左分支
               2) 此时新的根节点替换完旧的根节点，则旧的根节点的左分支就空余出来了
               3) **新的根节点的右分支，就会作为旧的根节点的左分支**
            3) 新的根节点的左分支，还是之前的左分支



3. 单旋实现的注意点
   1) 先迭代，继续向下查询，直到找到该二叉树最底层不符合平衡条件的节点，进行单旋处理
      1) 不能找到一个立马进行单旋处理
   2) 原因:
      1) 先单旋，可能会造成新的根节点，也不符合平衡条件
      2) 由于本次已经处理完成，新的根节点不会再次查询是否符合平衡条件
         1) 除非手动判断，再次处理，浪费了效率，通常一个节点只单旋一次
      3) 单旋后不符合平衡条件的情况介绍
         1) 单旋的核心: 
            1) 把长分支中的某个分支掰下来
            2) 拼接到短的分支上去，这样分支的长度就提上来了
            3) 只要掰的分支够长，处理完，长度差小于等于1，该节点就是一个平衡节点了
         2) 如果单旋产生的新的根节点，也不符合平衡条件
            1) 即一个分支过长，一个分支过短
            2) 比如: 左旋，使用的是右分支的根节点作为新的根节点
               1) 如果右分支的根节点的分支，左边过短，右边过长，长度差大于1
               2) 单旋后，掰的是左分支，即过短的那个分支
               3) 这样拼接后，新根节点的左右分支长度差，还是大于1
               4) 造成，单旋后，新的根节点依旧不符合平衡条件
      4) 如果，先处理底层，把底层所有的节点都变成了平衡节点
         1) 这样，所有节点的左右分支的长度差都小于等于1
         2) 这样，掰下来一个分支，做单旋改变分支长度，分支的长度差才会小于等于1
         3) 这样，新的根节点，就是一个平衡节点
         4) 新生成的二叉树，即为平衡二叉树 
      


4. 二叉搜索树进行单旋后，还是一个二叉搜索树
   1) 左旋
      1) 找旧根节点的右分支的根节点，作为新的根节点
      2) 旧的根节点，会作为新的根节点的左分支
         1) 由于新的根节点，是旧的根节点之前的右分支
         2) 根据二叉搜索树的特点，右分支的数据比当前的大
         3) 即新的根节点对应的数据，比旧的根节点对应的数据大
         4) 旧的根节点作为新的根节点的左分支，完全符合搜索树的特点(左小)
      3) 新的根节点之前的左分支，会作为旧的根节点的右分支
         1) 新的根节点之前的左分支，位于旧的根节点之前的右分支上
         2) 根据二叉搜索树的特点，右分支的数据比当前的大
         3) 即新的根节点之前的左分支对应的数据，比旧的根节点对应的数据大
         4) 此时，该左分支，作为旧的根节点的右分支，完全符合搜索树的特点(右大)     
   2) 右旋
      1) 找旧根节点的左分支的根节点，作为新的根节点
      2) 旧的根节点，会作为新的根节点的右分支
         1) 由于新的根节点，是旧的根节点之前的左分支
         2) 根据二叉搜索树的特点，左分支的数据比当前的小
         3) 即新的根节点对应的数据，比旧的根节点对应的数据小
         4) 旧的根节点作为新的根节点的右分支，完全符合搜索树的特点(右大)
      3) 新的根节点之前的右分支，会作为旧的根节点的左分支
         1) 新的根节点之前的右分支，位于旧的根节点之前的左分支上
         2) 根据二叉搜索树的特点，左分支的数据比当前的大
         3) 即新的根节点之前的右分支对应的数据，比旧的根节点对应的数据大
         4) 此时，该右分支，作为旧的根节点的左分支，完全符合搜索树的特点(左小)
   3) 二叉搜索树，无论是经过左旋还是右旋，还是一个二叉搜索树，只不过变成了平衡二叉搜索树



5. 单旋实现的具体流程
   1) 先判断当前节点，是否符合平衡条件
   2) 然后，更改当前节点的左右分支指向，即left和right
      1) 此处进行迭代，靠迭代返回值，赋予指向
      2) 此处就是先迭代
   3) 进行单旋处理，如果当前节点不符合平衡条件
      1) 根据左分支长，还是右分支长，选用右单旋还是左单旋
   4) 经过单旋处理后，就会得到一个新的根节点，然后直接返回
      1) 如果是第一个节点，经过单旋后，外界可以得到单旋后的新的根节点
      2) 如果是迭代，经过单旋后，返回一个新的根节点
         1) 在`?.left=`或者`?.right=`的作用下，指向新的根节点
         2) 即，之前的根节点(旧根节点)，被替换掉
   5) 如果当前节点符合平衡条件，直接返回当前的节点
      1) 如果是第一个节点，外界得到的还是之前的根节点，没有发生替换
      2) 如果是迭代
         1) 在`?.left=`或者`?.right=`的作用下，指向的还是之前的根节点
         2) 没有发生变化




6. 单旋不适用的情况
   1) 单旋发生的条件
      1) 左右分支的长度差过大
   2) 单旋的处理方法
      2) 掰下一个分支，拼接到短的分支上，加长短分支的长度，使其符合平衡条件
   3) 不能单纯的只使用单旋的两种情况
      1) **长的分支，是靠掰下的分支顶起的长度，不能单纯的使用单旋进行处理**
         1) 只要长度差大于1，然后拼接到根节点上，就会变成大于2
         2) 所以掰的分支长度，不能大于另一个分支的长度，只能小于或者等于
      2) **掰下的分支，与旧的根节点的另外一条分支，之间的长度差大于2**
         1) 不能单纯的使用单旋进行处理
         2) 拼接到旧的根节点上，旧根节点的左右分支的长度差就会大于2
      3) 解决方式: **使用双旋进行处理**
         1) 左右双旋，右左双旋，处理第一种情况
         2) 左左双旋，右右双旋，处理第二种情况



7. 单旋的示范代码
```js
// 判断一个节点的长度
function length(jie, index) {
    // index为长度，已经到达叶子节点，返回长度
    if(jie == null) return index;
    
    // index是传入节点的长度，向左分支查，长度在基础上加1，向右分支查，长度还是在基础上加1
    // 向下移一个节点，长度自然加一。
    const zuo = length(jie.left, index + 1);
    const you = length(jie.right, index + 1);
    // 判断左分支还是右分支长，返回最长的一个作为该节点的深度
    return zuo > you ? zuo : you;
}

// 左单旋
function left_xuan(cha) {
    // 得到新的根节点
    const gen = cha.right;
    // 把之前的根节点的右分支，改为新的根节点之前的左分支
    cha.right = gen.left;
    // 之前的根节点，作为新的根节点的左分支
    gen.left = cha;

    // 返回新的根节点
    return gen;
}
// 右单旋
function right_xuan(cha) {
    // 得到新的根节点
    const gen = cha.right;
    // 把之前的根节点的左分支，改为新的根节点之前的右分支
    cha.left = gen.right;
    // 之前的根节点，作为新的根节点的右分支
    gen.right = cha;

    // 返回新的根节点
    return gen;
}

// 根据非平衡二叉树，构建出平衡二叉树
function dan_xuan(cha) {
    // 到最后，直接退出，叶子节点后面拼接的是null，所以返回null
    if(cha == null) return null;
    // 先获取分支的长度，判断是否为平衡二叉树
    const left = length(cha.left, 0);
    const right = length(cha.right, 0);

    // 进行迭代，传入对应的分支，判断对应的分支根节点是否符合平衡条件
    // 符合拼接的还是之前的分支根节点，不符合拼接的是单旋产生的新的根节点
    cha.left = dan_xuan(cha.left);
    cha.right = dan_xuan(cha.right);

    // 后处理，需要判断是否进行单旋，是左单旋还是右单旋
    if( right - left > 1 )  return left_xuan(cha);    // 左单旋
    if( left - right > 1 )  return right_xuan(cha);   // 右单旋
    if( Math.abs(left - right) <= 1 ) return cha;     // 符合平衡条件
}

const dan = dan_xuan(A);
console.log( pan_duan( dan ) );
```





# 单旋中加上双旋的处理方式(单旋完整版)


1. 双旋其实就是多次单旋


2. 具体流程
   1) 左右双旋和右左双旋
      1) 获取单旋所掰的分支的长度，与其对应的另外一条分支的长度做比较
         1) 另外一条分支，比如掰的是左分支，与其对应的右分支的长度进行比较
         2) 如果长度差大于0，即掰的分支比对应的另外一条分支长
            1) 拼接完成后，当前节点加上之前的根节点，长度差就大于1
            2) 即不符合平衡条件
         3) 就需要进行双旋处理
      2) 单旋，会产生一个新的根节点，即左右分支的根节点
      3) 具体的双旋流程
         1) 单旋是左单旋，新的根节点就是该节点的左分支的根节点
            1) 单旋前，先对左分支的根节点进行右单旋
            2) 然后在进行单旋
            3) 旋转流程: 右单旋 -> 左单旋，即右左单旋
         2) 单旋是右单旋，新的根节点就是该节点的右分支的根节点
            1) 单旋前，先对右分支的根节点进行左单旋
            2) 然后在进行单旋
            3) 旋转流程: 左单旋 -> 右单旋，即左右单旋
   2) 左左双旋和右右双旋
      1) 出现该现象的情况
         1) 掰过去的分支的长度，与旧的根节点对应的另外一条分支的长度
         2) 它们的长度差大于等于2，即大于1
         3) **一定是掰的分支长**，原因如下:
            1) 既然进行单旋，说明分支的长度差大于1
            2) 并且掰的分支，位于长的那个分支上
            3) 由于从底层开始处理，并且经过左右和右左双旋的处理
            4) 所掰的分支的长度，接近与长分支的长度
            5) 所以掰的分支的长度与旧根节点对应的另外一条分支(短分支)产生的长度差
            6) 并且长度差大于2，一定是掰的分支长
            7) 否则进行单旋的短分支，就不为短分支，既然是短分支，长度就比长分支短
            8) 而掰的分支的长度，接近与长分支，所以掰的分支的长度一定长与短分支
      2) 处理的时间，发生在单旋所掰的分支拼接到旧的根节点上
         1) 即，单旋处理完成后
      3) **处理方法: 直接递归单旋函数，传入旧的根节点**
         1) 既然完成拼接(单旋)后的旧的根节点，产生了左右分支差
         2) 就需要，再次单旋旧的根节点
         3) 由于不知道，所掰的分支与其对应的另外一条分支的长度差为多少
         4) 可能差距过大，就需要从底层开始单旋，直到分支的长度差相似，不大于1
            1) 直接单旋旧的根节点，可能会造成，掰的分支过长
            2) 单旋完，依旧不是平衡节点
         5) 此时在进行单旋旧的根节点，就变成了平衡节点
         6) 直接递归单旋函数，自动会递归到该节点的最后，进行处理
      4) **还需要，对本次单旋，产生的新的根节点，再进行一次单旋递归**
         1) 左左双旋，右右双旋，操作的是旧的根节点，进行单旋处理
         2) 而旧的根节点，此时已经作为本次单旋产生的新的根节点的一个分支
         3) 而旧的根节点单旋，会影响节点的长度
         4) 可能会造成，本次单旋产生的新的根节点，又不是一个平衡节点了
         5) 所以需要对本次产生的新的根节点，在进行一次单旋递归
            1) 如果依旧是平衡节点，根据单旋函数的特点，直接返回节点
            2) 如果不是，重新进行单旋，期间可能会发生双旋
      5) 介绍
         1) 如果本次单旋是左单旋，即右分支过长
            1) 掰的分支，会拼接到旧的根节点的右分支上
            2) 如果掰的分支过长，引发旧的根节点的再次单旋
            3) 依旧是左单旋，右分支过长
            4) 所以本次单旋经过了两个单旋处理，左单旋 -> 左单旋，即左左双旋
         2) 如果本次单旋是右单旋，即左分支过长
            1) 掰的分支，会拼接到旧的根节点的左分支上
            2) 如果掰的分支过长，引发旧的根节点的再次单旋
            3) 依旧是右单旋，左分支过长
            4) 所以本次单旋经过了两个单旋处理，右单旋 -> 右单旋，即右右双旋



3. 示范代码，完整的单旋函数代码
```js
/** 触发右右双旋二叉树
 *       A
 *     B    
 *    C  D     
 *   E    F   
 *  G      H    
 */

 /** 触发左右双旋二叉树
 *       A
 *     B    
 *    C        
 *   D        
 *  E           
 */


// 判断一个节点的长度，旧代码
function length(jie, index) {
    if(jie == null) return index;
    const zuo = length(jie.left, index + 1);
    const you = length(jie.right, index + 1);
    
    return zuo > you ? zuo : you;
}
// 旧代码
function left_xuan(cha) {
    const gen = cha.right;
    cha.right = gen.left;
    gen.left = cha;

    return gen;
}
// 旧代码
function right_xuan(cha) {
    const gen = cha.left;
    cha.left = gen.right;
    gen.right = cha;

    return gen;
}


// 单旋，内部加了双旋的实现
function dan_xuan(cha) {
    if(cha == null) return null;
    const left = length(cha.left, 0);
    const right = length(cha.right, 0);
    // 递归
    cha.left = dan_xuan(cha.left);
    cha.right = dan_xuan(cha.right);

    // 左单旋的触发条件
    if( right - left > 1 ) {
        // 取出所掰的分支的长度
        const left = length(cha.right.left, 0);
        // 与所掰分支对应的另外一条分支的长度，判断右左双旋的触发条件
        const right = length(cha.right.right, 0);
        // 旧节点，对应的另外一条分支的长度，判断左左双旋的触发条件
        const jiu_left = length(cha.left, 0);
        // 触发右左双旋
        if(left - right > 0) {
            // 先右旋，对单旋分支进行右旋
            // 所以产生的新的根节点，要赋予右分支，新根节点替换旧根节点
            cha.right = right_xuan(cha.right);
        }
        // 进行左旋，与上面的右旋，组成了右左双旋
        let gen = left_xuan(cha);
        // 触发左左双旋的条件 
        if( left - jiu_left > 1 ) {
            // 直接对旧的根节点进行递归，进行单旋处理
            // 旧的根节点，作为新的根节点的右分支
            // 所以单旋产生的根节点，要赋予右分支，替换旧节点
            gen.right = dan_xuan(gen.right);
            // 单旋影响分支长度，需要对新的根节点再次递归
            gen = dan_xuan(gen);
        }
        return gen;
    }
    // 右单旋的触发条件
    if( left - right > 1 ) {
        // 取出所掰的分支的长度
        const right = length(cha.left.right, 0);
        // 与所掰分支对应的另外一条分支的长度，判断左右双旋的触发条件
        const left = length(cha.left.left, 0);
        // 旧节点，对应的另外一条分支的长度，判断右右双旋的触发条件
        const jiu_right = length(cha.right, 0);
        // 触发左右双旋
        if(right - left > 0) {
            // 先左旋，对单旋分支进行左旋
            // 所以产生的新的根节点，要赋予左分支，新根节点替换旧根节点
            cha.left = left_xuan(cha.left);
        }
        // 进行右旋，与上面的左旋，组成了左右双旋
        let gen = right_xuan(cha); 
        // 触发右右双旋的条件 
        if( right - jiu_right > 1 ) {
            // 直接对旧的根节点进行递归，进行单旋处理
            // 旧的根节点，作为新的根节点的左分支
            // 所以单旋产生的根节点，要赋予左分支，替换旧节点
            gen.left = dan_xuan(gen.left);
            // 单旋影响分支长度，需要对新的根节点再次递归
            gen = dan_xuan(gen);
        }
        return gen;
    } 
    if( Math.abs(left - right) <= 1 ) {
        return cha;
    }
} 

const a = dan_xuan(A);
// 判断是否为平衡二叉树
console.log( pan_duan(a) )
```





# 树的深度优先搜索

1. 方式
   1) 树可能有很多分支，二叉树只是一种树的特殊格式
   2) 由于不知道树的分支有多少个，所以把它们都放在一个数组中
   3) 只需要遍历递归树的分支数组，就可以实现树的广度优先搜索
    


2. 示范代码
```js
/** 树的结构
 *          A
 *     B         C
 *    D  E    F G H I   
 *   J       K        L             
 */

// 创建树
function ErChaShu(value) {
    this.value = value;
    this.fen = [];
}
const A = new ErChaShu("A");
const B = new ErChaShu("B");
const C = new ErChaShu("C");
const D = new ErChaShu("D");
const E = new ErChaShu("E");
const F = new ErChaShu("F");
const G = new ErChaShu("G");
const H = new ErChaShu("H");
const I = new ErChaShu("I");
const J = new ErChaShu("J");
const K = new ErChaShu("K");
const L = new ErChaShu("L");
A.fen.push(B, C);
B.fen.push(D, E);
D.fen.push(J);
C.fen.push(F, G, H, I);
F.fen.push(K);
I.fen.push(L);


function shu_shen_bian(shu, data) {
    if(shu === null) return false;
    if(shu.value === data) return true;
    for(let i = 0; i < shu.fen.length; i ++) {
        if( shu_shen_bian(shu.fen[i], data) ) return true;
    }
    // 递归查询不到，说明该树中没有该数据
    return false;
}
const a = shu_shen_bian(A, "L");
console.log(a);
```







# 树的广度优先搜索

1. 方式
   1) 树可能有很多分支，二叉树只是一种树的特殊格式
   2) 由于不知道树的分支有多少个，所以把它们都放在一个数组中
   3) 传入一个数组，遍历该数组，取出内部的节点，进行判断
   4) 如果不符合，把**子节点放入一个数组中**
   5) 当前节点遍历完成后，如果没有一个节点满足，则所有的子节点都已经放入一个数组中了
   6) 然后此时进行迭代，传入子节点数组，这样就会实现横向遍历搜索
    


2. 示范代码
```js
/** 树的结构
 *          A
 *     B         C
 *    D  E    F G H I   
 *   J       K        L             
 */

// 创建树
function ErChaShu(value) {
    this.value = value;
    this.fen = [];
}
const A = new ErChaShu("A");
const B = new ErChaShu("B");
const C = new ErChaShu("C");
const D = new ErChaShu("D");
const E = new ErChaShu("E");
const F = new ErChaShu("F");
const G = new ErChaShu("G");
const H = new ErChaShu("H");
const I = new ErChaShu("I");
const J = new ErChaShu("J");
const K = new ErChaShu("K");
const L = new ErChaShu("L");
A.fen.push(B, C);
B.fen.push(D, E);
D.fen.push(J);
C.fen.push(F, G, H, I);
F.fen.push(K);
I.fen.push(L);


function shu_shen_bian(shuArr, data) {
    // 如果到达叶子节点，还没有找到，再次迭代传入的数据就是空数组
    // 此时就可以返回false，表示无该数据
    if(shuArr === null || shuArr.length === 0) return false;
    let arr = [];
    // 遍历传入的节点数组
    for(let i = 0; i < shuArr.length; i ++) {
        if( shuArr[i].value === data ) return true;
        else arr = arr.concat(shuArr[i].fen);
    }
    // 进行递归
    return shu_shen_bian(arr, data);
}
const a = shu_shen_bian([A], "L");
console.log(a);
```






# 图的深度优先搜索

1. 方式
   1) 由于图存在回路，所以要保留已经访问过的节点，否则陷入死循环
   2) 遇到节点，就向下进行递归


2. 示范代码
```js
/** 图的结构
 *     A 与B、C、D有关系
 *     B 与A、C、E有关系
 *     C 与A、B有关系
 *     D 与A有关系
 *     E 与B、F有关系     
 *     F 与E有关系       
 */

// 创建图
function ErChaShu(value) {
    this.value = value;
    this.guan_xi = [];
}
const A = new ErChaShu("A");
const B = new ErChaShu("B");
const C = new ErChaShu("C");
const D = new ErChaShu("D");
const E = new ErChaShu("E");
const F = new ErChaShu("F");
A.guan_xi.push(B, C, D);
B.guan_xi.push(A, C, E);
C.guan_xi.push(A, B);
D.guan_xi.push(A);
E.guan_xi.push(B, F);
F.guan_xi.push(E);


function shen_du(jie, data, path) {
    if(jie === null) return false;
    // 该节点已经查询过，不在向下递归查询，防止陷入递归死循环
    if(path.indexOf(jie) > -1) return false;
    if(jie.value === data) return true;
    // 运行到该位置，说明当前节点不符合条件，该节点就需要进行保存
    path.push(jie);
    
    // 遍历迭代有关系的节点
    for(let i = 0; i < jie.guan_xi.length; i ++) {
        // 查询成功，直接返回
        if( shen_du(jie.guan_xi[i], data, path) ) return true;
    }
    // 运行到该位置，说明没有找到数据
    return false;
}
const a = shen_du(A, "C", []);
console.log(a);
```





# 图的广度优先搜索

1. 方式
   1) 由于图存在回路，所以要保留已经访问过的节点，否则陷入死循环
   2) 传入数组，数组中保存所有当前需要处理的节点
   3) 如果数组中的某个节点不符合条件，则把该节点所有有关系的节点存入一个数组中
   4) 当前节点数组遍历完成，如果没有符合条件的节点，就需要进行递归
   5) 此时，新的节点数组已经构建完成，传入即可
   6) 如果迭代到最后一层，没有符合的节点，再次递归传入的就是一个空数组


2. 示范代码
```js
/** 图的结构
 *     A 与B、C、D有关系
 *     B 与A、C、E有关系
 *     C 与A、B有关系
 *     D 与A有关系
 *     E 与B、F有关系     
 *     F 与E有关系       
 */

// 创建图
function ErChaShu(value) {
    this.value = value;
    this.guan_xi = [];
}
const A = new ErChaShu("A");
const B = new ErChaShu("B");
const C = new ErChaShu("C");
const D = new ErChaShu("D");
const E = new ErChaShu("E");
const F = new ErChaShu("F");
A.guan_xi.push(B, C, D);
B.guan_xi.push(A, C, E);
C.guan_xi.push(A, B);
D.guan_xi.push(A);
E.guan_xi.push(B, F);
F.guan_xi.push(E);


function guang_du(jieArr, data, path) {
    if(jieArr === null || jieArr.length === 0) return false;
    let arr = [];
    for(let i = 0; i < jieArr.length; i ++) {
        const jie = jieArr[i];
        // 该节点已经查询过，不在向下进行处理，跳出本次循环
        // 不能直接return，还有其它节点没有处理
       if(path.indexOf(jie) > -1) continue;
       if(jie.value === data) return true;
       else arr = arr.concat(jie.guan_xi);
       // 运行到该位置，说明当前节点不符合条件，该节点就需要进行保存
       path.push(jie);
    }
    
    return guang_du(arr, data, path)
}
const a = guang_du([A], "D", []);
console.log(a);
```






# 动态规范之斐波那契数列

1. 传入一个数，获取该位置对应的斐波拉契数列中的数据


2. 示范代码
```js
function fei(n) {
    if(n === 1) return 1;
    if(n === 2) return 1;
    // 斐波拉契数列中的每一位数据，都相当于前两位的和
    return fei(n - 1) + fei(n - 2);
}

console.log( fei(10) );
```






# 动态规范之青蛙跳台阶问题

1. 问题
   1) 一个青蛙，每次可以跳一个台阶，或者两个台阶
   2) 问: 一个n阶的台阶，青蛙有几种跳法
   3) 解决方案: 青蛙跳到第n阶，可能从n-1个台阶跳上来的，也有可能从n-2个台阶跳上来的
      1) 这样就分成了两个小问题，一个是跳到n-1个台阶有几种方法，一种是跳到n-2个台阶有几种跳法
      2) 两种台阶的跳法和，就是跳到n阶台阶的方式
         1) 比如: 跳到n-1阶台阶有3种跳法，再跳1阶，跳到n阶台阶，还是3种跳法
            1) 比如1-1-1、1-2、2-1三种跳法，在跳一阶还是3种，不会发生变化
            2) 比如1-1-1-1、1-2-1、2-1-1，还是3种跳法
         2) 比如: 跳到n-2阶台阶有3种跳法，再跳2阶，跳到n阶台阶，还是3种跳法
         3) 加起来，跳到n阶的方式就为5种
      3) 而n-1和n-2又可以继续划分
      4) 青蛙跳，其实就是斐波拉契数列的另外一种用法


2. 示范代码
```js
function tiao(n) {
    // 传入的数据不合理
    if(n <= 0 ) return -1;
    // 蹦一下，跳一个台阶
    if(n === 1) return 1;
    // 蹦一下，跳一个台阶，需要跳两次
    // 蹦一下，跳两个台阶，需要跳一次
    // 这样就两种跳法
    if(n === 2) return 2;

    // 跳n阶的跳法
    return tiao(n - 1) + tiao(n - 2);
}
console.log( tiao(10) );
```





# 动态规范之变态青蛙跳台阶问题

1. 问题
   1) 一个青蛙，每次可以跳n个台阶
   2) 问: 一个n阶的台阶，青蛙有几种跳法
   3) 解决方案: 
      1) 青蛙跳到第n阶，可能从n-1、n-2 ··· 2、1阶台阶跳上来
      2) 也有可能直接从地面上直接蹦上来
      3) 所以需要使用for循环


2. 示范代码
```js
function tiao(n) {
    // 传入的数据不合理
    if(n <= 0 ) return -1;
    // 蹦一下，跳一个台阶
    if(n === 1) return 1;
    // 蹦一下，跳一个台阶，需要跳两次
    // 蹦一下，跳两个台阶，需要跳一次
    // 这样就两种跳法
    if(n === 2) return 2;
    
    // 蹦的次数
    let index = 0;
    for(let i = 1; i < n; i ++) {
        index += tiao( n - i );
    }

    // 跳n阶的跳法
    // for循环的范围正好是从n-1 ···· 1阶台阶跳到n阶台阶的方法，不包括直接从地面蹦
    // 加上1，是青蛙直接从地面上蹦上n阶台阶的方法
    return index + 1;
}

console.log( tiao(10) );
```






# 