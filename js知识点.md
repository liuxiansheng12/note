
# 运算符

1. 加、减、乘、除、求余
   1) **运算符两侧有数组或者对象或者函数，会先转换成对应的字符串，然后在参与运算**
      1) 数组: 转换成字符串的样式：把两侧的`[]`去掉(`,`的两侧没有空格)，比如: 
         1) `[] => ""`、`[1, 2] => "1,2"`、`[, 2] => ",2"`、`[2, ] => ""`
         2) 要注意空数组，转换成空字符串
      2) 对象: 一律转换成: `"[object Object]"`
      3) 函数: **直接把书写的函数样式转换成字符串，不会进行空格、换行的删除**(不像数组)
   2) **加号**的两侧有一个字符串，则运算结果，为字符串拼接
      1) 比如: `{} + 5` 的运算结果为 `[object Object]5`
   3) **加号**的两侧是其它类型的数据，转换成number类型的数据，然后在进行运算
   4) **减、乘、除、求余**，会先把运算符两侧的数据，全部转换成number类型的数据，进行运算
      1) 对象、数组、函数先转换成字符串，在转换成number类型的数据，通常为`NaN`
      2) `NaN`参与运算，得到的结果为`NaN`，空数组除外
      3) **空数组，先转换成字符串为空字符串，在转换成number类型的数据为`0`**
      4) **空字符串、null，转换成0。undefined转换成NaN**

2. 逻辑运算符
   1) `>、<、>=、<=`
      1) 两侧都是字符串，比较的是第一个字符的`ASCII`的大小，若相同，在比较第二位
         1) 若没有第二位，则有第二位的一定大
      2) **两侧只要有一个不是字符串，全部转换成number类型的数据，在进行比较**
         1) 只要有一个数据，转换完为NaN，则结果一定是`false`
   2) `==`
      1) 如果两侧全是引用类型的数据，比较的是引用类型数据的引用地址
      2) 如果两侧有一侧是引用类型的数据，则把引用类型的数据转换成对应的字符串
      3) 如果两侧全是字符串，比较的是字符串样式上是否相同
      4) 如果两侧有一个数据，是其它类型的数据(非引用、非字符串)，全部转换成number类型的数据
      5) 只要有一个数据，转换完为NaN，则结果一定是`false`
      6) 特殊点: `undefined == null`为true
         1) 原理上: `NaN == 0`，结果应该为false，但是结果为true
   3) `===`，不存在数据类型的转换

3. &&、||、!运算符
   1) `undefined、null、""、NaN、false、0`，全部为false
   2) 其它数据全部为true





# 原型

1. 直接书写的对象，或者系统自动创建的对象，都是由构造函数`Object`创建出来的
   1) 所以，对象的`__proto__ = Object.prototype`

2. 构造函数的prototype，指向的空间就是系统自动创建出的创建的对象
   1) 比如: `a.__proto__ = A.prototype` 而 `A.prototype.__proto__ = Object.prototype`
   2) **所以对象的原型链的源头，就是`Object.prototype`**

3. 一切函数，都是由构造函数Function，构建出来的(底层)，函数也是一个特殊的对象
   1) 比如: a为一个函数，则`a.__proto__ = Function.prototype`
   2) `Function.prototype.__proto = Object.prototype`
   3) Function也是一个函数，是程序开始时，创建好的，不是由`new Function`产生的
      1) 此时还没有`Function`，所以`Function.__proto__`的指向，比较特殊
      2) 直接指向，`Function.prototype`，保持了一致性
      3) `Object.__proto__ = Function.prototype`




# 执行期上下文(预编译环节)

1. 代码执行前，会创建一个全局执行期上下文，然后把执行期上下文放入执行栈中

2. 一个函数在执行前，会先创建该函数对应的执行期上下文
   1) 执行期上下文中，最重要的有两个东西，一个是this指向，一个是AO
   2) 其中AO中，记录了该函数中所有声明的参数、变量和函数

3. 栈的介绍
   1) 栈是一种数据结构，先进后出，后进先出。
   2) JS引擎始终执行的是栈顶的上下文。


4. this指向
   1) 直接调用函数，this指向全局对象
   2) 全局中，this指向的window
   3) 通过对象调用或new一个函数，this指向调用的对象或新对象


5. AO 变量对象
   1) 确定所有形参值以及特殊变量arguments
   2) 确定函数中通过var声明的变量，将它们的值设置为undefined，如果VO中已有该名称，则直接忽略。
   3) 确定函数中通过字面量声明的函数，将它们的值设置为指向函数对象，如果VO中已存在该名称，则覆盖。


6. 当函数执行完，上下文一销毁，则青线断掉，产生的AO将变成垃圾机制。闭包除外。





# 作用域链

1. AO中包含一个额外的属性，该属性指向创建该AO的函数本身
2. 每个函数在创建时，会有一个隐藏属性`[[scope]]`，它指向的是创建该函数时的AO(父级AO)
3. 当访问一个变量时，会先查找自身VO中是否存在，如果不存在，则依次查找`[[scope]]`属性。这样就形成了一条作用域链。



# js代码执行机制
 
先微后宏



# JS语言特性

- 解释型语言

编译型语言：C语言、C++、java语言、C#语言

编译型语言会经过一个翻译的过程，负责翻译的叫做编译器，翻译的结果，叫做编译结果。

优点：执行速度快
缺点：某个编译结果，难以适用于各种环境（跨平台障碍）；部署繁琐；

解释型语言：js、php

解释型语言没有编译结果

优点：跨平台；部署简单；
缺点：执行速度稍慢  

- 弱类型语言

弱类型：存放的数据类型可变。优点：灵活、易上手； 缺点：不严谨

强类型：存放的数据类型不可变。优点：严谨；缺点：不灵活、不易上手

> 通常，将弱类型的解释型语言，称为脚本语言

- 单线程

同步现象：上一件事情没有做完，下一件事情必须等待。

- 异步

提高单线程的执行效率。