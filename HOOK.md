# HOOK的介绍
1. 增强函数组件的功能
2. 类组件无法使用HOOK


# useState

1. 作用
   1) 让函数组件可以使用状态(定义数据)
   
2. 使用方式
   1) `useState`函数有一个参数，需要传递，该参数的值为该状态的初始值
   2) `useState`函数有一个返回值，并且返回值是一个数组
      1) 该数组一定包含两项。第一项: 当前状态的值、第二项: 改变状态的方法
      2) 要想修改该状态，必须使用返回的对应数组中的修改状态的方法
   3) 并且一个组件可以有多个状态，即可以多次使用`useState`定义多个状态。
   4) 示范代码
   ```js
   // 引入该方法
   import { useState } from "react";
   function A() {
       // 定义状态A
       const [a, setA] = useState(0);
       // 定义状态B
       const [b, setB] = useState(5);
       return <div>
           <div>使用状态1 a: {a} </div>
           <div>使用状态2 b: {b} </div>

           <button onClick = { () => {
               setA(5)
           } } >修改状态1</button>
   
           <button onClick = { () => {
               setB(3)
           } } >修改状态2</button>
       </div>
   }
   ```


3. 注意细节
   1) `useState`严禁写在判断、循环中
      1) 与useState数据存储的规则有关
   2) 使用提供的方法修改数据，会直接覆盖之前的数据，并不会合并，和`setState`不同。
      1) 所以对象，或者数组在改变状态时需要注意，最好使用`setA({...a, name: 12})`。
      2) 把之前的属性展开，然后在修改具体的数据
      3) 目的:
         1) 防止替换过程中，把一些属性给替换掉了


4. 修改状态，重新渲染的规则
   1) 如果，重新赋值，一直等于初始值，则组件函数永远不会执行，即不进行重新渲染
   2) 如果，重新赋值，值发生了变化，则组件函数重新执行，进行重新渲染
      1) 之后的重新赋值，值不在发生变化，则还执行一次，之后不在执行
      2) 即，重新赋值，赋同样的值，前两次会触发
   3) 如果直接在函数中运行，修改状态的函数，会直接进行组件的重新渲染
      1) 不管赋值是否相同，**所以要注意，极易陷入死循环**
      2) 函数重新渲染后，直接执行某函数，进行状态的修改，组件函数重新执行，陷入死循环
   4) 只有在异步函数中(比如事件，定时器)，中执行的函数，修改状态，才会进行性能的优化


5. useState的原理(组件函数第一次执行)
   1) useState的执行，会创建一个类似表的东西
   2) 第一个useState，把状态放在表的第一个位置
      1) 该位置没有值，把useState传入的值放在该位置，然后返回一个数组
   3) 第二个useState，把状态放在表的第二个位置
      1) 该位置没有值，把useState传入的值放在该位置，然后返回一个数组


6. useState的原理(状态改变)
   1) 利用对应的修改状态的函数，修改状态，然后重新执行组件函数
      1) useState函数就会重新执行，此时就会重新获取状态
   2) 第一个useState，查看状态表中的第一个状态，如果有值，则直接返回数组
      1) 此时也会传入初始值，但是由于该位置已经存在值，则该值无效
   3) 第二个useState，查看状态表中的第二个状态，如果有值，则直接返回数组
      1) 此时也会传入初始值，但是由于该位置已经存在值，则该值无效
   4) 正是由于，useState的取值是根据执行的顺序，取对应位置的值，所以不能放在判断循环中
      1) 放在判断循环中，就会影响useState的执行顺序，以至于取不到对应位置的值



7. 组件的强制刷新
    1) 类组件: 调用`this.forceUpdate()`方法，就可以进行组件的强制刷新。
    2) 函数组件没有提供专门的方法。可以通过定义一个空对象状态。
       1) 当需要强制刷新的时候，在给该状态附一个空对象
       2) 由于两个空对象的地址索引是不同的，就会引发组件的刷新，达到强制刷新的效果



8. useState的异步执行问题
   1) useState为了节约性能，返回的修改状态的函数，与setState函数的原理相似
      1) 不立即更新组件
   2) 现象
   ```js
   function A() {
       const [a, setA] = useState(0);

       return <div>
           <div>使用状态 a: {a} </div>
           <button onClick = { () => {
               setA(a + 1)
               setA(a + 1)
           } } >修改状态</button>
       </div>
   }
   // 虽然执行了两次setA，但是前后两个setA，使用的a都是同一个数据0
   // 从函数的执行原理上分析: 也是这样，位于同一个作用域下，所以使用的a都是同一个数据
   ```


9. useState返回的修改状态的函数的第二种用法(对状态进行多次加工)
   1) 传入一个函数，与setState的功能相似，把同一个修改状态的函数，传入的函数放在一个队列中
   2) 然后依次执行队列中的函数，第一个函数，接收状态的初始值
   3) 后面的函数，接收前一个函数返回的状态
   4) 最后一个函数返回的状态，才是将要，修改表中对应的状态值
   5) 示范代码
   ```js
    function A() {
        const [a, setA] = useState(0);

        return <div>
            <div>使用状态 a: {a} </div>

            <button onClick = { () => {
                setA(a => a + 1)
                setA(a => a + 1)
            } } >修改状态</button>
        </div>
    }
    // 最终把状态，变成2
    ```





# useEffect

1. 作用
   1) 执行一些副作用函数，其中有一种用法，相当于`componentDidMound`函数的功能
   2) 用于处理一些组件刚激活时，执行一些代码，但是重新渲染时不在执行


2. 第一种使用方式，每次重新渲染时执行一次`useEffect`中传入的函数
   1) 父组件重新渲染，子组件也会进行重新渲染，则该方法传入的函数会执行
   2) 当前函数组件的状态发生变化，当前组件会进行重新渲染，该方法传入的函数执行
   3) 当前函数组件的状态，一直赋予一个值，函数组件可能会重新渲染两次
      1) **但是该方法传入的函数，只会执行一次**
      2) 第二次赋予相同的状态，虽然组件函数重新执行
      2) 但是由于状态没有变化，所以该方法传入的函数是不会执行的
   4) 示范代码
   ```js
   // 引入该方法
   import { useState, useEffect } from "react";
   function A() {
       const [a, setA] = useState(0);

       useEffect( () => {
           console.log(123);
       } )

       return <div>
           <div>使用状态 a: {a} </div>
           <button onClick = { () => {
               setA(a + 1)
           } } >修改状态</button>
       </div>
   }
   ```


3. 第二种使用方式，进行状态的限制
   1) 当`useEffect`中传入的函数，只有所依赖的状态发生变化，该方法传入的函数才会执行
      1) 第一次一定会执行
      2) 之后，只有依赖的状态发生了变化，传入的函数才会执行
         1) 依赖状态发生了变化，就要重新执行函数，对状态进行重新处理，进行数据的更新
   2) `useEffect`中传入的函数，只在开始时执行一次
      1) 达到`componentDidMount`函数的功能
      2) 利用状态的依赖，如果状态的依赖为空，即没有依赖状态
         1) 此时，就无法进行依赖状态，是否发生变化，进行判断
         2) 则传入的函数，之后才会永远不会执行
         3) 状态无法判断，相当于没有状态没有发生变化，函数自然无法执行
   3) 示范代码
   ```js
   // 引入该方法
   import { useState, useEffect } from "react";
   function A() {
       const [a, setA] = useState(0);

       useEffect( () => {
           console.log(123);
           // 依赖a和b状态，只有a或者b的状态发生变化，该函数才会重新执行
       }, [a, b])
       useEffect( () => {
           console.log(123);
           // 没有状态，则该函数只会在组件创建的时候执行一次，之后不再执行
       }, [])

       return <div>
           <div>使用状态 a: {a} </div>
           <button onClick = { () => {
               setA(a + 1)
           } } >修改状态</button>
       </div>
   }
   ```
 


4. 组件销毁时执行的函数
   1) `useEffect`函数传入的函数，是可以有返回值的，但是返回值必须是一个函数
   2) 返回值函数，在组件销毁的时候，会执行一次，可以进行定时器的清空
   3) `useEffect`函数，传入的函数重新执行时，注意是重新执行，第一次执行不算
      1) 会先执行，上一个`useEffect`函数，传入的函数，的返回值函数
      2) 然后才会执行新的，`useEffect`函数传入的函数，执行完又会得到一个新的返回值函数
      3) 如果进行了状态的限制，即状态限制，传入一个空数组
         1) 这样，`useEffect`函数传入的函数，只会在开始时执行一次，之后不在执行
         2) 而返回值函数，只有在`useEffect`函数传入的函数重新执行，或者组件销毁时执行
         3) 所以，返回值函数，之后在销毁时执行一次
         4) 达到了生命周期，`componentWillUnmount`函数的功能


5. **useEffect函数传入的函数执行时间**
   1) **在组件渲染完成后，真实的dom已经创建完成，执行**
      1) 一定要注意其执行时间
      2) 如果借助，副作用函数，实现一些功能，并且后面或者子组件中要立即使用到该功能
      3) 该功能是无法使用的，此时还没有执行，功能还没有创建
      4) 在重新渲染，或者事件函数中可以使用
   2) 如果多次使用useEffect函数，则传入的函数，会放在一个队列中
      1) 当组件渲染完成后，从队列中依次取出方法，进行执行
   3) 比如:
   ```js
   function A() {
      useEffect(() => {
         console.log(5);
      })
      console.log(1);
      // 先打印1，在打印5，并不是useEffect中传入的函数是异步函数
      // 而是此时组件还没有渲染完成，传入的函数还没有执行

      return <>
      </>
   }
   ```
      


6. 闭包问题
   1) 函数组件重新渲染，即重新执行组件函数，则之前的函数组件执行时创建的作用域依旧存在
   2) 如果组件中，启用了定时器，一直使用某个状态，但是定时器中对该状态又进行了修改
   3) 继而引发函数组件的重新渲染，但是由于定时器是在函数组件旧的作用域下创建的
   4) 所以，虽然状态发生了变化，定时器一直获取到的状态
   5) 由于闭包的问题，使用的一直是初始状态，是获取不到新状态的
   6) 比如：示范代码
   ```js
   import { useState, useEffect } from "react";
   function A() {
       const [a, setA] = useState(0);
   
       useEffect( () => {
           setInterval( () => {
               setA(a + 1);
           }, 1000)
       }, [])     
       // 只让副作用处理函数执行一次，只开启一个定时器
       // 定时器中涉及了状态的改变，即重新渲染组件，如果不进行限制，会一直开定时器
   
       return <div>
           <div>使用状态 a: {a} </div>
       </div>
       // 虽然一直改变状态a，但是由于闭包的问题，一直使用的是旧状态
       // 所以状态赋值一直是0 + 1，经过两次后，函数组件不在进行重新渲染

       // 解决办法，实现状态的递增:
       // 使用setTimeout，副作用处理函数不加状态限制
       // 则每次重新渲染，新开一个setTimeout，获取新的状态，做完递增，失去作用
       // 递增完，又重新渲染，又新开一个setTimeout，使用新的状态进行递增，达到状态递增的效果

       // 虽然旧的setTimeout，还是位于旧的作用域中，依旧处于闭包环境
       // 但是setTimeout只执行一次，下次执行的是新的，就不存在闭包的问题
   }
   ```




# 自定义HOOK

1. 自定义HOOK，其实就是一个自定义的函数，但是函数名有要求，必须以`use`开头

2. 自定义HOOK，中可以使用React中提供的HOOK，并且与组件节点建立联系
   1) 在自定义HOOK中，使用useState定义了状态，然后状态发生了变化
   2) 会导致，使用该自定义HOOK的，组件函数重新执行，进行重新渲染
   3) **即HOOK与使用的函数没有关系，而是与组件有关**

3. 自定义HOOK的示范代码
```js
import { useState } from "react";
function A() {
    // 使用自定义HOOK，返回一个数据
    let a = useAbc();

    return <div>
        <div>使用状态 a: {a} </div>
    </div>
}

function useAbc() {
    const [a, setA] = useState(0);
    // 如果不加限制条件，直接使用setA修改状态，会陷入死循环中，最终报栈溢出的错误
    if(a !== 22) {
        setA(22);
    }
    return a;
}
```

4. 进行一些功能的提取，比如副作用函数的封装




# useReducer

1. 功能
   1) 管理状态，当某个状态，根据不同的需求变成不同的状态，可以使用该方法进行管理
   2) 相当于`redux`中的`reducer`函数

2. useReducer函数的用法
   1) 该方法传入三个参数
      1) 第一个参数(必须是函数)，为状态的处理函数，该函数必须有返回值
         1) 返回值，为修改后的状态值
      2) 第二参数为，状态的初始值
      3) 第三个参数(必须是函数)，初始值的进一步加工函数，该函数必须有返回值
         1) 返回值，为最终的初始值
   2) 一个useReducer，只能管理一个状态，但是该函数可以多次使用，管理多个状态

3. useReducer函数的使用示范代码
```js
// 引入该方法
import { useState, useReducer } from "react";
// 自定义的处理函数
function abc(a, action) {
    switch(action.type) {
        case "a状态为12":
            return action.attrs;
    }
    return a;
}
function A() {
    // 初始状态，从1变成了5
    const [a, dispatch] = useReducer(abc, 1, (a) => { console.log(a); return 5} );
    return <div>
        <div>使用状态 a: {a} </div>
        <button onClick={ () => {
            // 传入action对象
            dispatch({
                type: "a状态为12",
                attrs: 12
            })
        } }>改变状态</button>
    </div>
}
```


4. 仿写useReducer函数(无法实现修改初值值的函数，只在开始时执行一次)
```js
function useReducer(dis, data, ina) {
    let d = data;
    // 对初始值的处理，只执行一次，给函数加一个状态，标识已经执行了一次
    // 每次传入的函数，是同一个函数，可以实现
    if(ina && !ina.__type) {
        d = ina(d);
        ina.__type = true;
    }

    // 创建状态
    const [type, setType] = useState(d);
    // 返回一个dispatch函数，该函数没有需要自己创建，可以接收active对象
    function dispatch(active) {
        // 执行dis函数，根据active对象，修改状态，返回新的状态，进行修改
        const data = dis(type, active);
        setType(data);
    }
    
    return [type, dispatch];
}
```



# useContent

1. 作用
   1) 读取上下文中的数据

2. 使用方式
   1) 该方法传入一个上下文对象
   2) 会返回整个上下文中的数据
   3) 可以使用解构的方式，提取出需要的上下文

3. 原始的获取执行期上下文中的数据，需要借助`content.Consumer`组件，以函数的形式获取


4. 代码示范
```js
// 引入该方法
import { useContext } from "react";
// 创建上下文对象
let content = React.createContext();
// 往执行期上下文中加入数据，即父组件
function C() {
    return <content.Provider value={ {a: "b", b: 11} }>
        <A />
        <B />
    </content.Provider>
}

// 使用原始的方式获取执行期上下文
function A() {
    return <div>
        <content.Consumer>
            {
                ({a}) => {
                    return <p>{a}</p>
                }
            }
        </content.Consumer>
    </div>
}

// 使用useContext获取执行期上下文中的数据
function B() {
    // 传入创建的执行期上下文，就可以获取到内部的数据，然后进行解构
    let { a } = useContext(content);  
    return <div>
        <p>{a}</p>
    </div>
}
```


# useCallBack

1. 作用
   1) 固化一个函数的地址索引
   2) 每个组件重新渲染，如果设计到函数的创建，每次重新渲染，都会重新创建一个函数
      1) 可以把函数创建提取出来，放在组件函数的外面
      2) 组件函数重新执行进行重新渲染，则函数不在重新创建，直接使用外界的函数地址索引
      3) 但是，有一个问题，如果函数中使用了组件状态，就需要用传递参数的方式，过于麻烦
      4) 此时就需要使用`useCallBack`固定函数的地址索引
   3) **可以优化函数的重新渲染**
      1) 当前函数组件中，创建了一个函数，传入子组件中，子组件进行了性能优化
         1) 只要数据没有发生变化，就不会进行重新渲染
      2) 当前函数组件，进行了重新渲染，会重新创建一个函数，传入子组件中
         1) 子组件，进行数据比较，比较的是地址索引，两个是不同的，就会直接重新渲染
         2) 但是本质上，数据没有发生变化，不应该重新渲染
      3) 固化地址索引，就可以解决这一问题
         1) 虽然函数进行了重新创建，只要依赖没有发生变化，得到的还是旧的函数引用
         2) 传入子组件中，进行数据比较，地址没有发生变化，就不会重新渲染



2. 使用方法
   1) `useCallBack`函数，在使用时，需要传递两个参数
      1) 第一个参数为，固定函数地址索引的函数
      2) 第二个参数为，状态依赖，与`useEffect`中的状态依赖，使用以及功能相同
   2) 该方法，返回固定的函数地址索引
   3) 该方法，在重新渲染时，依旧会执行，函数依旧会创建，然后传递到函数中
      1) 但是`useCallBack`函数，进行了处理
      2) 只要状态依赖没有发生变化，返回的还是旧的函数地址索引
      3) 即新传入的函数忽略
      4) 如果状态依赖为一个空数组，则函数地址索引一直不会发生变化

3. 示范代码
```js
// 引入该方法
import { useState, useCallback } from "react";

// 函数组件
function A() {
    const [a, setA] = useState(5);
    // 固化函数索引，只要a没有发生变化，A函数重新执行，进行重新渲染
    // 得到的都是同一个函数索引
    let func = useCallback( () => {
        console.log(a);
    }, [a])

    return <div>
        <B func={ func } />
    </div>
}

// 纯组件(自动性能优化)
class B extends React.PureComponent {
    render() {
        console.log("重新渲染了");
        return <div></div>
    }
}
```



# useMemo

1. 作用
   1) 与`useCallBack`函数的功能相同，也是固化地址引用
   2) 但是功能更加强大，`useCallBack`只能固化函数引用
   3) 该函数可以固化，函数、数组、对象的地址索引
   4) **useMemo最大的作用，通常使用该方法优化函数组件重新渲染时的效率**
      1) 主要优化的是，列表循环创建节点的过程
      2) 在React中，列表循环渲染，利用的就是React对数组的处理的特点
      3) 即，列表循环渲染，其实就是遍历一个数组，创建一个节点数组
      4) 如果生成的节点数组过于复杂，则重新渲染时，如果依赖的数组数据没有发生变化
      5) 当组件重新渲染的时候，又会重新遍历数组，创建节点数组，如果复杂，太浪费性能
      6) **此时就可以固化，节点数组的地址引用，如果依赖数组没有变化**
      7) 直接使用上次创建好的，节点数组，不在重新创建
         1) 只要一个小数据发生了变化，引发重新渲染，从而进行列表循环，过于浪费性能
   5) 固化一个数组或者对象，则每次重新渲染，即函数的重新执行，操作的都是同一个空间
      1) 如果直接通过 `let a = {}`，定义对象
      2) 每次重新渲染(组件函数重新执行)，就会创建新的对象，进行覆盖


2. 使用方法
   1) `useMemo`函数，接收两个参数
   2) 第一个参数为一个函数，函数必须有返回值，返回值就是要固定索引的数据
   3) 第二个参数为状态依赖，如果依赖没有发生变化，第一个参数传入的函数是不会执行的
      1) 直接得到，上次函数执行时，返回的数据的索引，也可以返回普通的数据
   4) 该函数返回的就是固定的索引，或者普通的数据(索引就是一个特殊的数据)


3. 代码示范
```js
// 模拟恐怖的数组
let arr = new Array(1000)
arr.fill("ahdufiahidf");

function A() {
    // 一个小数据
    const [a, setA] = useState(5);

    let b = useMemo( () => {
        // 对大数组循环产生的结构，进行固化，防止重新渲染时，重新走该函数
        return arr.map( (k) => {
            return <div>{k}</div>
        } )
    }, [arr])

    return <div>
        { b }
        <div onClick={ () => {
            // 改变小状态
            setA(10);
        } }>{ a }</div>
    </div>
}
```
   



# useRef

1. 作用
   1) 产生一个**固化地址的特殊对象**，即ref对象
      1) 如果直接使用`React.createRef()`创建ref对象的话，虽然可以实现效果。
      2) 但是每次组件重新渲染，都会重新创建新的，浪费了效率
      3) 用`useRef`，只会创建一次，之后组件刷新(组件函数执行)
      4) 直接获取之前创建的ref对象，不用在重新创建

2. 使用方式
   1) 只有一个参数，如果不传递，创建的对象和`React.createRef()`创建的对象一样
   2) 如果传递参数，给对象中的`current`属性附一个初始值(没什么用)


3. 示范代码
```js
import { useState } from "react";
function A() {
    let ref = useRef();
    return <div>
        <div ref={ref}>标签</div>
    </div>
}
```

4. 扩展
   1) `React.createRef()`可以和`useMemo`结合使用，可以实现与`useRef`函数相同的功能
   2) `useRef`函数，返回的就是一个固定地址索引的对象，可以作为普通的对象使用
      1) 这样，组件重新渲染，使用的都是同一个对象
      2) 只不过该对象在开始时，只有一个没用的属性`current`
    



# useImperativeHandle

1. 作用
    1) 给ref对象中的current属性赋值
    2) 要是只是单纯的赋一个值，直接.current = ?就可以实现。
    但是函数组件，只要一刷新就会多次执行，如果赋的值需要计算，且计算过程有些复杂。
    在使用 = 赋值有时就浪费了性能。

    3) 使用useImperativeHandle可以设置数据依赖数组。
    只有数据依赖数组发生变化时，才进行复杂的运算，重新给current赋值。
    如果没有发生变化，计算函数不在运行，直接赋之前计算出来的值。

2. 使用
    传递三个参数:
    1) 第一个参数: 为ref对象。
    2) 第二个参数: 是一个函数，会在初始时执行一次，返回值赋给ref的current属性
    如果没有设置数据依赖，则组件每次重新执行，该函数都会重新执行。
    **并且该函数的执行时异步执行**
    3) 第三个参数: 数据依赖，只有发生变化时，第二个参数传入的函数才会重新执行


3. 示范代码
```js
import { useImperativeHandle, useRef } from "react";
function A() {
    // 创建一个ref对象
    let ref = useRef();
    useImperativeHandle(ref, () => {
        console.log(111);
        // 返回值给ref中的current赋值
        return {
            a: () => {
                console.log("ref");
            }
        }
    }, [])


    console.log(222);

    return <div>
        <div>标签</div>
    </div>
}
```
先打印222后打印111，说明useImperativeHandle传入的第二个参数函数，是异步执行的


4. 扩展
    1) 函数组件的行间是不能写ref，如果想要使用ref，需要进行ref的转发
    2) 可以通过useImperativeHandle给ref转发到函数组件内部的ref对象的current赋值
    3) 比如赋一个函数，这样父组件环境中就可以通过ref使用赋的函数。




# useLayoutEffout

1. 作用
    可以用来处理一些副作用
    常用于处理真实dom的操作

2. 使用方式
    使用方式与useEffect方式完全相同，只不过传入的函数触发时间不同。
    在真实dom改变后，但是浏览器还没有刷新时执行，而useEffect是浏览器刷新后执行。
    所以此时处理真实的dom，不会引发闪烁的效果。
    如果使用useEffect处理真实的dom，可能会闪一下，然后切换到设置的状态。


3. 传入函数的执行时间
   1) **在组件对应的react元素已经构建完成，但是真实的dom还没有生成，执行**
      1) 一定要注意其执行时间
      2) 如果借助，副作用函数，实现一些功能，并且后面或者子组件中要立即使用到该功能
         1) 立即使用的过程，发生在`react`元素创建前
      3) 该功能是无法使用的，此时还没有执行，功能还没有创建
      4) 在重新渲染，或者事件函数中可以使用



3. 示范代码
```js
import { useLayoutEffect } from "react";
function A() {
    useLayoutEffect( () => {
        console.log("副作用");
        // 返回一个函数，销毁时执行，副作用处理函数运行前执行(第一次除外)
        return () => {
            console.log(123);
        }
    }, [])

    return <div>
        <div>标签</div>
    </div>
}
```

4. 注意事项(执行顺序的问题)
    1) 如果多个useLayoutEffect连用。当传入的处理副作用函数重新执行时，会先执行返回的函数。
    并且所有的返回函数按照顺序执行完，才会处理副作用的函数。

    2) 如果useLayoutEffect与useEffect共用，执行顺序为: useLayoutEffect的返回函数、处理副作用函数、useEffect的返回函数、处理副作用函数。

    3) 如果组件销毁时，就与useLayoutEffect和useEffect没有关系，会按照顺序，从上到下依次执行。并不是先执行useLayoutEffect的，然后在执行useEffect的。







# HOOK无法实现的功能

1. 函数组件，想要在开始时，即react元素构建前，执行一些功能
   1) 并且重新渲染时，这些功能不再执行，即componentDidMount函数的功能
   2) 是没有对应的HOOK的，只能使用类组件