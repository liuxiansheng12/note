

# 通过script标签引入vue的方式

```html
<script src="https://cdn.jsdelivr.net/npm/vue"></script>
```







# vue挂载的方式

1. 内部挂载
   1) 通过`el`属性进行挂载
   2) 比如: `new Vue({ el: "选择器的名称"})`
   

2. 外部挂载
   1) 通过Vue构造函数的返回值上的`$mount`方法
   2) 比如: `new Vue({}).$mount("选择器的名称")`


3. 获取vue挂载的dom
   1) 通过`new Vue({}).$el`获取







# 获取vue组件配置对象中的自定义属性值

1. 通过`this.$options.?`，可以获取到配置对象中，自定义属性的属性值







# 重新渲染分析及注意点
 
1. 在vue中，直接修改对象中的属性对应的属性值，是可以引发重新渲染的

2. 修改数组，比如新增和修改一个位数的数据，是无法引发重新渲染的
   1) 不是通过数组的方法进行修改，而是通过下标的方式修改
   2) 操作数据的方法都已经进行了重写，内部加上了重新渲染的执行代码

3. 向data中新增数据，然后进行修改，是无法引发重新渲染的

4. 重新渲染，会查看所有的数据，只要与当前渲染的数据不符和，也会顺带着给重新渲染了
   1) 比如当前操作了数组，没有引发重新渲染
   2) 下次操作了一个对象的属性，引发了重新渲染
   3) 则当前的重新渲染，会顺带完成重新渲染数组数据


5. 原理
   1) 底层通过`object.defineProperty`方法进行了监管
   2) 分析模板时，建立了对应模板与数据的关系
   3) 当数据发生变化时，触发set函数
   4) 然后根据数据与模板的关系，找到对应的dom，进行重新渲染




# $set的使用

1. 作用
   1) 强制刷新页面，但是有限制条件
   2) **触发条件: 数据必须发生了变化，并且发生变化的数据，在模板中进行了使用**
      1) 在分析模板，创建dom的时候，对应dom与使用的对应数据建立了联系
      2) 当数据发生变化的时候，根据建立的关系表，重新渲染该节点
   3) **解决修改数组无法引发重新渲染的问题**
      1) 直接修改数组，无法引发页面的重新渲染
      2) 除非修改数组使用的是数组上的一些方法，这些方法已经进行了重新
      3) 内部，加上了获取数组与对应dom的关系，从而进行重新渲染
      4) 或者使用`$set`，直接引发重新渲染



2. 使用方式
   1) 该函数在vue的环境对象中，所以调用该函数有两种方法
      1) 在vue的内部通过`this`调用
      2) 通过new Vue()的返回值对象调用
   2) 该函数接收三个参数
      1) 第一个: 要修改那个对象中的属性，即该对象的索引
      2) 第二个: 要修改的属性
      3) 第三个: 将要赋予的值，即新值
   3) 要修改数组中的某个数据，传入的也是这三个参数
      1) 数组就是一个特殊的对象
      2) 第一个参数，找到该数组(特殊对象)
      3) 数组的属性，就是0、1、2 ··· ··· ，第二个参数只需要传入对应的位数即可



3. 示范代码
```js
   mounted() {
      // 修改对象中的属性
      this.$set(this, "a", ?);
      // 修改数组中的数据，修改第1位数据(即第二个数据)
      this.$set(this.arr, "1", ?)
   }
```







# vue中的指令(不是很常用，但是也有它的作用)

1.  `v-pre`   禁止解析数据(正常情况下会对{{}}进行解析，但是给标签设置了v-pre就进行解析，直接展示{{}}这种形态)

2. `v-cloak`  vue加载时存在，解析完消失(配合css使用`[v-cloak] {   display: none;  }`, 可以避免加载过慢，产生从{{}}到正确数据的变换过程(效果不好))

3. `v-once`   对数据进行缓存，即使修改数据，页面刷新，也是从缓存中取数据(页面不会再发生变化)

4. `v-html`   通过`v-html="data"`，可以把data数据解析成html格式(正常情况下为字符串)。并且以data替换掉整个之前的innerHTML。

5. `v-text`   该指令就是插入文本元素，可以不使用{{}}，直接`v-text="属性名"`，就可以把数据插入到标签中，并且把之前的innerHTML替换掉。


# 标签的行间属性从vue中取值的方式
需要借助一个属性`v-bind:(可以简写成:)`，并且不用加{{}}，直接""。

```html
<img v-bind:src="imgSrc">
<img v-bind:class="class">
<img :src="imgSrc">
<img :style="style">
```

# class从vue中取值的方式

1. 取一个值
   1) 直接取值: `v-bind:class="a"`
   2) 运行表达式: `:class=" da ? 'a' : 'b' "`
   3) 赋值固定值: `:class=" 'a' "`
   4) 原理: 把表达式的结果运算完，作为class名

2. 取一个值或者取多个值
   1) 直接取值: `v-bind:class="[a, b, c]"`
   2) 运行表达式: `:class="[a, da && 'c', da ? 'a' : 'b']"`
   3) 赋值固定值: `:class="['a', b, da && 'c']"`
   4) 原理: 把数组中的每一项表达式的结果运算完，作为class名



3. 取一个值或者取多个值
   1) class名，提前定义好，然后根据条件判断进行添加，无法从data数据中获取
   2) `v-bind:class="{a: a, b: b, c}"`
      1) 当属性值为true时，属性名作为class名
      2) 没有属性值的属性名则直接作为class名，不进行判断添加


4. `:class`可以与`class`共存，两者定义的class名最终会进行合并




# style从vue中取值的方式

1. css样式比较特殊，必须有一个属性名和一个属性值。


2. 获取方式
   1) 把所有样式写成一个字符串，然后进行获取
      1) 比如: 定义的数据为`sty: "color: #f0f; "`
      2) 取值方式: `v-bind:style="sty"`
      3) 运行表达式: `:style="a && sty"`
         1) 把表达式的运算结果，赋值给style
   2) 把样式定义成对象格式(常用)，可以定义多个对象
      1) 比如: 定义的数据为`sty: {color: '#f0f', fontSize: '14px' }`
      2) 取值方式: `v-bind:style="[ sty, a ]"`
         1) 可以取一个或多个样式对象
      3) 运行表达式: `v-bind:style="[ a && sty, b ]"`
   3) 样式只定义键值对中的键值，键名(样式名)在模板中设置
      1) 比如: 定义的数据为`color: "#f0f", fontSize: '16px'`
      2) 取值方式: `v-bind:style='{color: color, fontSize: fontSize}'`
      3) 运行表达式: `:style='{color: a && color, fontSize: fontSize}'`
      

3. `:style`可以与`style`共存，不会发生覆盖现象。但是`:style`会替换`style`中相同的样式





# 组件或dom的显示与隐藏

1. v-if和v-else和v-else-if控制显示与隐藏
   1) `v-if`和`v-else-if`必须写上条件判断，`v-else`不需要写条件判断
   2) 联合使用，`v-if`必须写在前面，其次后面跟`v-else-if`，最后写上`v-else`
      1) `v-if`和`v-else`只能使用一次，`v-else-if`可以使用多次，或者不使用
      2) `v-else`也可以不使用，如果使用，前面必须存在`v-if`或者存在`v-if`和`v-else-if`
      3) 中间不能插入其它的组件
   3) 就相当于js中的`if -> else if -> else`，使用规则相同，功能不同


2. v-show控制显示与隐藏
   1) 后面跟上判断条件就可以控制组件的显示与隐藏了


3. v-if和v-show控制显示与隐藏的区别
   1) v-if会彻底的销毁组件或者dom，即组件会启用销毁周期
      1) 下次满足条件后，会重新创建组件，是一个全新的组件，重新走生命周期
      2) 与key值存在密切的关系
      3) 在解析时，如果条件不满足，组件是不会被解析的，不会被激活
   2) v-show只是控制css样式的`display`为`block`还是为`none`，来控制组件的显示与隐藏
      1) 在解析时，所有的组件都会激活声明周期函数，即使组件隐藏，也会激活
      2) 然后把隐藏的组件的`display`设置为`none`
      3) 无法与key建立关系，因为组件并不会被销毁
      4) v-show无法使用到vue提供的辅助标签`<template>`上
   3) 如果是频繁的显示与隐藏，建议使用`v-show`，效率较高






# 事件的绑定

1. 通过原始方法绑定事件
   1) 选中元素，可以借助ref，然后进行事件的绑定


2. 使用vue中提供的`v-on`指令进行事件的绑定
   1) 直接在模板中绑定事件，以及事件处理函数
   2) 使用方法
      1) 比如: 绑定click事件，`v-on:click="func"`
      2) `func`是自定义的事件处理函数名
      3) 简写: 可以使用`@`替换`v-on:`
         1) 比如: `@click="func"`
  
3. 事件函数的默认值传参
   1) 事件函数默认接收一个参数event，除了默认参数，还可以传递其它的数据，作为默认值
   2) 要想传入默认值，需要写成函数调用的方式
      1) 比如: `@click="func('aaa')"`
         1) 会替换传入的默认参数，接收的第一个参数是默认值`"aaa"`
      2) 要想即传入默认值，又传入event对象，需要借助vue提供的`$event`。
         1) 比如: `@click="func($event, 'aaa')"`  
         2) 第一个参数接收event对象，第二个参数接收默认值`"aaa"`


4. 事件函数内部的this指向
   1) 事件函数在执行时，内部的this，指向的是当前的vue环境对象，并不是触发事件的事件源
   2) 要想获取到触发的dom，需要借助event对象上的target属性






# 列表循环渲染

1. 作用
    1) 遍历vue中的一个数组，生成对应的html模板结构，渲染vue数组中的数据
    2) 可以快速书写出大量相同结构的HTML结构

2. 遍历方法
   1) 借助vue中的`v-for`指令实现遍历，需要`key`的配合
   2) 比如: `v-for="(item, index) in arr" :key="index"`
      1) item对应arr数组的每一项的数据
      2) index为对应的数组索引
      3) v-for内部的模板就可以使用item和index，渲染对应的数据
   3) 如果只使用数据，不使用索引，可以把`()`省略不写
      1) 比如: `v-for="item in arr" :key="item.id"`

3. 与v-for循环配合使用的还有一个`template`标签
   1) 该标签在实际渲染的时会消失，起一个辅助的作用
   2) 通常用于，父级节点使用v-for进行遍历，但是真实的dom结构中，该父级节点并不存在
   3) 需要注意，`key`必须要加在实际展示的标签上
      1) `template`标签不能使用key值，但是v-for必须借助key的辅助
      2) 所以只能加在`template`标签下的第一级子标签上，每个标签都需要进行添加
      1) 所以，为了保持每一个子节点的key都不相同，通常拼接一个后缀
         1) 比如: `<div :key=" 'key.id + a' "> {{ key.name }}</div>`




# key

1. 作用
   1) 为了优化重新渲染时的渲染效率
   2) 复用节点


2. 具体表现
   1) 当数据发生变化，又有可能引发重新渲染。
   2) 此时就可能涉及到了组件或者dom的创建与销毁
      1) 比如使用v-if，涉及到了组件或者dom的销毁与创建
   3) 如果销毁的组件或者dom，与将要创建的组件或者dom
      1) **定义的key相同，并且dom名或者组件名相同，并且位于同级**
      2) 三个条件都满足，就会产生dom或者组件的复用，即不在创建新的
   4) 组件节点使用key的表现形式
      1) 如果进行复用(满足上方的三个条件)，复用的是组件环境，即数据还是之前的数据
      2) 此时，如果组件进行过重新渲染(更改数据引发的)
      3) 由于环境被复用，所以，展示的还是重新渲染后的样式，并没有复原
      4) 如果涉及了`slot`的使用，并且新组件与复用的不同。相当于innerHTML不同
         1) 节点复用，并不涉及`innerHTML`，即`innerHTML`依旧进行判断，如果相同，继续复用
         2) 如果不同进行替换
         3) `slot`的使用会进行更新，不会继承复用环境中的`slot`，如果相同继续复用(优化效率)
      5) 如果没有进行复用，之前的组件就会进行卸载，然后创建新的组件
         1) 会还原成初始的状态，组件是新创建的，是一个新的环境，所有的数据都是初始数据
   5) 普通节点使用key的表现形式
      1) 如果进行复用(满足上方的三个条件)，复用的是dom节点
      2) innerHTML是不会进行复用的，需要继续判断
         1) 如果dom名相同，继续复用，如果标签名不同，创建新的
            1) 然后继续判断dom中的innerHTML
         2) 如果文本内容相同，继续复用，如果文本内容不同，创建新的
         3) 如果旧的多余，进行卸载，如果旧的没有，进行创建
      3) 不会整个结构都进行复用
         1) 只复用当前节点，html结构由节点树构成，复用的是枝杈的头
         2) 枝杈会继续判断
            1) 如果相同，才继续复用
            2) 如果不同，创新新的，替换旧的
         3) 这样，即保证了效率，又保证了与实际相符
   6) 所以，key用于复用节点，而不是复用整个结构


3. `v-for`指令必须配合`key`的使用
   1) `v-for`，涉及到了大量的节点的创建与销毁
      1) 数据发生变化，循环就会重新执行
      2) 此时如果没有key的辅助，所有的节点都会重新生成，大量浪费效率
   2) `key`的值最好不用使用index
      1) 如果使用index作为key值，每次循环都会进行复用
      2) 如果循环过程中，某个节点需要重新创建，index是无法进行操作的
      3) 如果使用其他数据作为key值，是可以进行动态控制的


4. `key`必须加在实际的标签上，`template`标签不能使用key值，它不参与渲染




# 双向数据绑定

1. 作用
   1) 数据与用户操作进行绑定，可以获取用户操作的数据

2. 使用
   1) vue中提供了一个`v-model`指令
   2) 可以使用`v-model`指令的标签有
      1) `<input type="text">`
      2) `<textarea name="abc" cols="30" rows="10"></textarea>`  
         1) 多行文本输入框
      3) `<input type="checkbox" value="ss" v-model="arr">`      
         1) 复选框
         2) input上要定义好value
         3) 用于v-model绑定的数据，必须为一个数组，因为复选框可以选中多项
         4) 选中对应的input，把定义的value存放到数组中，取消选中，从数组中移除对应的数据
      4) `<input type="radio" value="hh" v-model="arr">`         
         1) 单选框
         2) 虽然单选框只能选中一项，但是v-model绑定的数据，也必须是一个数组
         3) 选中对应的input，把定义的value存放到数组中，取消选中，从数组中移除对应的数据
      5) `<select v-model="checkbox"> <option value="A">A</option> </select>`  
         1) 下拉菜单组件
         2) 下拉菜单的`v-model`绑定在父标签select上
         3) 子标签option上也提前定义好value。
         4) 当option被选中时，对应的value就会赋值给v-model绑定的vue数据
         5) 赋值方式不为数组

3. 原理
   1) 底层借助的是`v-bind:value="***"`和`input`事件相互配合实现双向数据绑定
   2) 并且v-model和@input事件没有冲突
      1) 事件是可以多次绑定的





# 修饰符

常用的修饰符有两种，一种是事件修饰符，一种是v-model使用的修饰符。

事件的修饰符(给事件的触发在加上限制条件)
比如:  `<input @keyup="func">`   只要键盘按下就会触发func事件
加上修饰符，比如: `<input @keyup.enter="func">`  当回车键按下时才触发func函数(多了一条限制条件)
`enter`也可以用对应的键值来替换`<input @keyup.13="func">`。   键值就是`keyCode`

**给键盘修饰符起个别名**
```html
<input @keyup.a-b="func">
<script>
    Vue.config.keyCodes = {
        // 不支持小驼峰式的写法，也就是不能写成aB。要写成a-b
        "a-b": 13   //给键值为13的按键起一个别名(回车键)
    }
</script>
```


v-model修饰符
1. `v-model.lazy`    当输入框失去焦点时，才改变vue中的数据
2. `v-model.number`  当输入框输入的是纯数字时，vue获取的是number类型的数据(正确情况下获取的都是string类型的数据)
3. `v-model.trim`    当输入框中输入的内容两侧存在空格时，vue获取的数据去除两侧的空格(不影响展示样式，input中的空格依旧存在)
    


# 自定义指令

1. 作用
   1) 使用简单的指令，实现复杂的功能，类似黑科技

2. 自定义指令的定义
   1) 全局
      1) 借助Vue的静态方法`directive`进行创建，传入两个参数
      2) 第一个参数传递`自定义指令的名称`，第二个参数传入`指令的处理方式`
      3) 第二个参数有两种赋值方式
         1) `传入一个对象`，对象中有三个属性，属性值都是函数，对应三个阶段的处理函数
            1) `bind`: 使用该指令的dom创建后，但是还没有插入页面时，触发该函数
               1) 只执行一次
               2) 由于对应dom还没有插入，所以实现不了input初始时自动聚焦
                  1) 聚焦的方式: `dom.focus()`
            2) `inserted`: 使用该指令的dom，插入页面后，触发该函数
               1) 只执行一次
               2) 由于对应的dom已经插入页面中，所以可以实现input的自动聚焦
            2) `update`:  当使用该指令的dom的innerHTML进行重新渲染时，触发该函数
               1) 只要重新渲染，该函数就会执行
               2）如果标签进行了重新构建，比如v-if或者key值不同，与之前的就没有关系了
                  1) 从新执行`bind和inserted`
         2) `传入一个函数`，相当于传入对象中的bind和update的合成体
            1) 创建没插入时执行一次
            2) innerHTML重新渲染时执行一次

   2) 局部
      1) 利用Vue使用时的传参对象中的`directives属性`，属性值为一个对象
      2) 对象中的每一个属性，就是一个自定义指令，`属性名为指令名，属性值为指令的处理方式`
         1) 指令属性值，也有两种赋值方式，与全局一样。一种为函数，一种为对象格式。


3. 自定义指令函数接收的参数分析
   1) 指令处理函数，一共接收三个参数。
      1) 哪怕是对象格式中的三个参数，在执行时也接收三个参数。
   2) `el`(第一个参数): 传入使用该指令的dom
   3) `bindings`(第二个参数): 传入该指令的一些基础信息，格式为对象，内部常用的有四个属性
      1) `arg`: 存放的是指令，`:后面，=前面`的一段字符串标记
      2) `value`: 存放的是指令，`=后面`在vue中的实际数据(数据赋值)
      3) `expression`: 存放的是指令，`=后面`的字符串(数据名称)
      4) `modifiers`: 存放的是修饰符的相关信息，格式为对象
         1) 修饰符的名称作为属性名，属性值为true
         2) 表示该修饰符已经启用，具体的功能在指令函数中进行判断创建
         3) 比如: {inn: true}，判断inn为true，执行相应的代码
   4) `vnode`(第三个参数): 使用该指令的虚拟节点信息，内部常用的属性只有一个。
      1) `context`: 指向的就是当前的vue环境


4. 示范代码
```js
Vue.directive("abc", {
    bind(el, bindings, vnode) {
        // 无法进行聚焦，没有效果
        el.focus();  
    },
    update(el, bindings, vnode) {
    },
    inserted(el, bindings, vnode) {
        // 可以进行聚焦
        el.focus();  
    }
})
```

5. 使用时，通过`v-自定义指令名`进行使用。


6. 注意
   1) 如果指令中，涉及到了数据变化，从而引发重新渲染，或者绑定一些事件
      1) 要使用对象的赋值方式，然后在bind中进行实现
      2) 如果使用函数的赋值方式，或者在对象模式中的update中进行实现
         1) 会操作死循环，或者事件重复定义



# 过滤器

1. 作用
   1) 改变将要展示的数据，对数据进行加工
      1) 比如`老马 -> 姓名: 老马`
      2) 实际对应的数据(data)，还是`老马`，数据不会发生变化

2. 原理
   1) 当渲染时，分析vue模板
   2) 当分析到具有过滤器符号的模板，就会触发定义的过滤器
   3) 把vue中的数据，传入过滤器中，**实际上，用于替换模板的数据，是过滤器的返回数据**
   4) 即: 本来是`老马`替换，现在变成了`姓名: 老马`替换。展示的自然为`姓名: 老马`
   5) 影响的是模板的替换过程
   

3. 触发环境
   1) **只有渲染时(初始渲染、重新渲染)，分析到过滤器模板，过滤器才会触发**


4. 过滤器的定义
   1) 局部过滤器
      1) Vue的传参对象中的`filters`属性，用于定义局部过滤器，属性值为一个对象
      2) 对象中的每一个属性，就是一个具体的过滤器，属性值为过滤器函数
      3) 比如: `filters: { abc() {} }`，abc就是一个局部过滤器
   2) 全局过滤器
      1) Vue有一个`filter`静态属性，用于定义全局过滤器，属性值为一个函数
      2) 调用一次函数，创建一个全局过滤器
         1) 第一个属性，传入过滤器器的名称
         2) 第二个属性，传入过滤器处理函数
      3) 比如: `Vue.filter("abc", () => {} )`，abc就是一个全局过滤器
   3) **如果全局过滤器与局部过滤器重名，优先使用局部过滤器**

5. 过滤器的使用
   1) `<div>{{name | a | b}}<div>`
      1) a、b为定义好的过滤器
      2) **过滤器函数默认接收一个参数**
         1) 第一个过滤器接收的是: 前面对应的vue数据(即name对应的数据)
         2) 后面使用的过滤器函数，接收的参数，是前面过滤器的返回值
            1) 相当于进一步加工
      3) 最终替换模板所使用的数据，是最后一个过滤器的返回值
         1) **渲染的是最后一个过滤器的返回值**
   2) `<div>{{name | a(1, 2) | b(3, 4)}}<div>` 
      1) **给过滤器传递其它的数据**
      2) 过滤器函数，默认接收一个参数，作为第一个参数
      3) 过滤器函数，接收的数据，从第二个位置开始，对应模板中传入的数据


6. 过滤器运行在重新渲染时，所以需要了解重新渲染机制
   1) 修改数据，不造成重新渲染，过滤器是不会运行的
   2) 使用$set，强制重新渲染，哪怕数据没有发生变化，都要重新渲染
      1) 只要重新渲染，就会分析模板，分析到过滤器，过滤器就会运行
      2) $set使用一次(处理使用过滤器的数据)，过滤器运行一次









# vue执行的流程

1. 查看传入的参数有没有el
   1) 如果没有el，查看是否使用了wn.$mount
   2) 如果也没有，则vue停止处理直接退出
   3) 如果有则进行挂载

2. 挂载完成后就要获取到对应的模板
   1) 首先查看传参中是否有template属性，如果有则把模板取出
   2) 如果没有定义template属性，则通过$el.outerHTML取出实际的模板

3. 获取模板后，就要形成虚拟dom，构建虚拟dom树
   1) 首先查看传参中是否有render属性，如果有则使用自定义的render方法构建虚拟dom
   2) 根据模板构建虚拟dom树

4. 根据虚拟的dom，形成真实的dom。然后进行替换，浏览器正常渲染。









# vue传参对象中的template属性

1. 作用
   1) 创建vue的分析模板
   2) vue的核心就是分析模板
   3) 如果没有该属性，则使用默认的模板，即通过el绑定的节点，调用`outerHTML`方法获取默认模板

2. 使用方式
   1) 属性值是一个字符串，字符串就是当前组件分析的vue模板
   2) 如果模板中使用了其它的组件，需要借助`components`属性，进行声明
   3) `template`中使用的组件，就是一个字符串
      1) vue需要拿到该组件的配置对象，才能分析对应的组件
      2) 对应组件的配置对象，就是通过`template`中的组件字符串，从`components`对象中进行获取
      3) 所以需要在`components`对象中，声明对应的组件配置对象，以便查询使用







# vue传参对象中的render属性

1. 作用
   1) 创建vue的虚拟dom树，根据该虚拟dom树，创建真实的dom树
   2) 如果没有该属性，使用vue模板创建对应的虚拟dom树

2. 使用方式
   1) 该属性对应的属性值，是一个函数
   2) 函数接收一个参数，接收的参数也是一个函数
      1) 利用接收的函数，可以创建出一个vue的虚拟dom
      2) render函数，返回接收函数所创建的虚拟dom(返回的是根节点)
   3) 接收函数，在使用时
      1) 传入一个参数
         1) **传入的就是vue的配置参数对象，即将要创建的节点的配置参数对象**
         2) 由于直接传入的是组件配置对象
            1) 可以直接获取到该组件配置对象，进行分析
            2) 不需要在`components`对象中进行声明
      2) 传入三个参数
         1) 第一个参数: 当前的节点名(标签名)，格式为字符串
         2) 第二个参数: 当前节点的行间属性，格式为对象
            1) `class属性`: 设置该节点的class名
               1) 有三种赋值方式，与vue模板中class的三种赋值方式一样
               2) 分别为字符串、数组、对象
            2) `style属性`: 设置该节点的行间样式，有三种赋值方式
               1) 有三种赋值方式，与vue模板中style的三种赋值方式一样
               2) 分别为字符串、数组、对象
         3) 第三个参数: 当前节点的子节点
            1) 如果是多个子节点，需要放在数组中传入
            2) 如果是文本节点，直接写文本信息
            3) **如果是元素(标签)节点，可以再次使用接收的函数进行创建**
               1) 该函数就是创建虚拟dom的函数


3. 该函数在执行时，内部的`this`指向当前的组件环境对象，可以正常使用数据


4. render函数传入的第三个参数，为虚拟节点对象或者虚拟节点对象组成的数组
   1) 通过接受的函数，也是创建虚拟节点对象，所以第三个参数传入的是虚拟节点对象
   2) 可以与插槽(`this.$slots.?`)联合使用
   3) 通过`this.$slots.?`获取到的就是对应的插槽虚拟节点对象，所以可以直接使用






# vue的生命周期函数

1. 初始化以及初始渲染阶段
   1) 初始化vue
   2) 初始化完成后，执行周期函数`beforeCreate`
   3) 初始化自定义的数据(data)
   4) 初始化完成后，执行周期函数`created`
      1) `this`指向正常，可以操作`data`的数据，可以进行`ajax`请求
   5) 查看是否有el，$mount。
   6) 获取模板
      1) 获取自定义的模板: 即`template`
      2) 获取默认模板，即`el.outerHTML`
   7) 创建虚拟节点
      1) 使用render创建
      2) 根据模板创建
   8) 虚拟节点创建完成后，执行周期函数`beforeMount`
   9) 根据虚拟节点创建真实的节点
   10) 真实节点创建完成后，执行周期函数`mounted`    (通常发送ajax请求)
   11) 把真实的节点进行插入


2. 重新渲染阶段
   1) 当重新渲染前的时候，执行周期函数`beforeUpdate`
      1) 可以修改`data`中的数据
      2) 由于重新渲染时异步的，此时还没有重新渲染完成
      3) 修改数据，不会再次引发重新的渲染的过程
   2) 当重新渲染完成时，执行周期函数`updated`  
      1) 不能修改`data`中的数据
      2) 由于此时重新渲染完成
      3) 再次进行修改的话，会再次触发重新渲染流程，陷入死循环


3. 销毁阶段
   1) 当前组件不在重新渲染，触发销毁生命周期，比如`v-if`，`v-show`无法触发销毁周期
   2) Vue销毁前，执行周期函数`beforeDestroy`
      1) 通常用来消除vue中使用到的定时器
   3) Vue销毁完成，执行周期函数`destroyed`  





# vue中的计算属性

1. 作用
   1) 对一个数据，进行进一步加工，然后在进行显示
   2) 但是对原数据不会产生任何影响，和过滤器的作用差不多


2. 计算属性的创建
   1) 组件属性对象中，存在一个`computed`属性，属性值是一个对象
   2) 对象的每一个属性，就是一个计算属性，并且属性值有两种赋值方式
      1) 赋值为一个函数，相当于对象格式中的get
         1) 函数默认接收一次参数，为当前vue的环境对象
         2) 比如: `computed: { a() {} }`
         3) 修改数据，还是需要修改原始数据，data中的数据
      2) 赋值为一个对象，对象中有两个属性
         1) `set属性`，属性值为一个函数
         2) `get属性`，属性值为一个函数
         3) 修改数据，可以给计算属性赋值，运行set函数，然后把赋的值作为参数传入
            1) 然后在set函数中，修改data中的数据
            2) 这样就可以通过计算属性，完全控制data中的数据
            3) 相当于`Object.defineProperty`中的get和set


3. 计算属性的使用
   1) 如果是vue执行程序中使用
      1) 和data中的数据使用方式相同，直接通过`this.计算属性名`使用
      2) 计算属性虽然运行的是一个函数，但是**不能写成函数调用的形式**
      3) 比如: `mounted() { console.log( this.a ) }`
   2) 如果是vue模板中使用
      1) 和使用data中的数据相同，直接`计算属性名`
      2) 比如: `{{ a }}`


4. 计算属性的特点
   1) 计算属性**第一次获取**，运行计算属性函数
      1) 根据运行过程中执行的代码，如果使用了data中的数据，与该数据建立起联系
      2) 比如: `a -> compuA(); b -> compuA();`，并把a、b的值保存起来。
   2) 获取完成后，对计算属性函数的返回值进行缓存
   3) 如果再次获取计算属性值(js获取，模板获取)，先判断data依赖中的数据有没有发生变化
      1) 与上次缓存时，**所依赖的data数据对应的当时的值**，进行比较
      2) 如果发生变化，从新执行计算属性函数，然后把**返回值再次缓存**
      3) 如果没有发生变化，则计算属性函数不再执行，**直接使用缓存中的缓存数据**
   4) 修改计算属性所依赖的data数据，需要注意的问题
      1) 修改依赖数据，**data中的数据发生变化，但是不会对计算属性产生影响**
         1) 此时不会更新计算属性
      2) 如果是vue模板中使用了计算属性，修改依赖数据，会进行重新渲染
         1) 重新渲染，需要重新读取计算属性，此时就会判断依赖是否发生变化
         2) 如果变化，重新执行计算属性函数，然后更新缓存
         3) 造成了修改依赖，直接影响计算属性的效果，底层进行了读取

5. 注意事项
   1) 只有依赖数据发生了变化，重新读取计算属性时，才重新运行计算属性函数
   2) 只要依赖数据没有发生变化，就一直从缓存中取数据
   3) 哪怕使用`this.$set()`，强制重新渲染，只要数据没有变化，还是从缓存中取数据



# vue中的侦听器

1. 作用
   1) 用来监听vue中data数据的变化
   2) 当数据发生变化时，即不影响原先的功能，然后添加附加功能


2. 创建侦听器
   1) 组件对象中，存在一个`watch`属性，属性值为一个对象
   2) 对象中的每一个属性，就是一个侦听器，属性值有两种格式
      1) 对象格式，常用属性
         1) `handler`: 属性值为一个函数，侦听器执行函数
         2) `immediate`: 属性值为布尔值
            1) 当`true`时，初始时，侦听器函数就执行一次
            2) 当为`false`时，初始时，侦听器函数不进行执行，相当于直接赋值函数
               1) 只有当侦听的数据发生变化，侦听器函数才会执行
         3) 比如: `watch: { name: {  handler(res) { }, immediate: true } }`
      2) 函数格式
         1) 函数接收一个参数，就是数据的变化值(新赋值的值)
         2) **在初始时，侦听器函数不会进行执行，只有侦听属性发生变化时才进行执行**
   3) 利用`$watch函数`创建侦听器
      1) 不像watch属性创建侦听器一样，利用函数可以动态创建侦听器
      2) 通过`this.$watch()`创建侦听器
      3) `$watch`函数的传参
         1) 第一个参数: 侦听器的名称，必须与侦听属性相同
         2) 第二个参数: 侦听器执行函数
         3) 第三个参数: 侦听器的配置对象
            1) 比如: `immediate`，就在该对象中进行设置
            2) 如果第三个参数没有传递，`immediate`默认为false
               1) 开始时不进行执行，只有侦听属性发生变化才进行执行
               2) 如果想要开始时执行一次，需要把对应的属性值设置为true
      4) 比如: `this.$watch("a", function (res) {}, { immediate: true })`
   4) 侦听器名称，需要与被侦听的数据相同。
      1) 比如侦听data中的a数据，侦听器的名称必须为a
   5) 侦听器函数，只有一个参数
      1) 初始时执行，传入侦听属性的初始值
      2) 侦听属性值变化时，传入新赋值的值
   6) 侦听器函数中，如果想要通过this读取到当前组件的vue环境对象，不能使用箭头函数


3. 注意事项
   1) 只有侦听的数据发生了变化，侦听器函数才会执行
   2) 哪怕使用`this.$set()`，强制重新渲染，只要数据没有变化，侦听器函数是不会触发的
      1) 与上次的值一比较，发现一样，侦听器函数就不会执行





# 自定义组件

1. 创建方式
   1) 全局组件
      1) Vue上有一个静态方法`component`，通过该方法就可以创建一个全局组件
      2) component函数，共接收两个参数，第一个参数是组件名，第二个参数是组件数据对象
   2) 局部组件
      1) 在Vue的传参对象中，有一个`components属性`，属性值为一个对象
      2) 对象中的每一个属性，就是一个自定义组件。属性值为一个对象，对象用于描述自定义组件
      3) 自定义组件的描述对象中的属性，和Vue传参对象中的属性相同，功能也相同
      4) data属性的属性值比较特殊，不是一个直接的对象，而是一个函数
         1) 函数的返回值，是一个对象，内部定义该组件中使用的数据
   3) 组件的嵌套
      1) 可以在组件中再定义一个局部子组件，获取使用定义好的全局组件
      2) 局部子组件的创建方式，也是利用组件数据对象中的`components属性`进行定义


2. 自定义组件的声明周期问题
   1) 自定义组件声明周期的起点发生在父级周期的`beforeMount`和`mounted`之间
      1) 创建真实dom的时候
      2) 父组件的声明周期函数`beforeMount`，执行完，紧接着开始分析子组件，激活子组件周期
      3) 子组件的周期执行完`mounted`后，表示子组件渲染完成，父组件的`mounted`才会执行
         1) 所有的子组件全部渲染完成  
   4) 子组件重新渲染，触发自己的`updated`函数，不会触发父级的`updated`函数


3. 正是由于每个组件都是一个对象，所以就可以把这些组件对象单独的提取出来，形成专门的模块化开发
   1) vue框架，使用的就是这种方法，通过loader，把以vue为后缀的文件解析成组件对象，然后抛出







# 组件间的传参

## 子组件获取父组件定义的数据

1. 父组件通过行间属性v-bind向子组件进行数据的传递
   1) 子组件通过props属性，获取行间传入的数据
      1) 比如: `props: ["a"]`
      2) 获取行间传入的a数据
   2) 如果行间使用了某个属性进行传参，但是该属性没有在props中引入，会在行间显示出来
      1) props中引入的数据，行间是不会显示出来的，只显示那些传入但是没有引入的数据
      2) 可以通过 `inheritAttrs: false`进行消除
   3) 行间传参，但是没有被props引入的数据，会放在`$attrs`对象中
      1) 子组件可以通过`this.$attrs`获取到剩余的，没有被props引入的行间传参
      2) props中引入的行间传参，`$attrs`对象中是没有的
      3) 可以解决跨级传参的问题(中间一级没有使用某个数据，props也需要进行引入)
         1) 行间使用`v-bind="$attrs"`，把$attrs对象中的数据继续向下传递

2. 子组件直接获取父组件的vue环境，然后获取父组件中的数据
   1) 通过`this.$parent`，获取父组件的vue环境对象
   2) 相当于父组件的this，这样就可以通过`this.$parent.?`获取到父组件中的某个数据
   3) 计算属性可以进行监管
      1) 比如: `computed: { aa() { return this.$parent.a } }`


3. 执行期上下文传递数据
   1) 没有层级限制，只要位于执行期上下文的环境中，就可以使用内部的数据
   2) 在组件中，通过`provide属性`创建执行期上下文。
      1) 比如: `provide: { a: 123 }`
   3) 某个组件创建了执行期上下文，则该组件的所有子组件都位于该上下文的环境中
      1) 子组件，要想使用上下文中的数据，通过`inject属性`进行获取
         1) 和props的使用方式一样
         2) 比如: `inject: ["a"]`
      2) 创建执行期上下文中的组件，是不位于该上下文中的
         1) 也就是不能通过inject获取上下文中的数据
   4) 创建执行期上下文的组件，是无法使用上下文中的数据的
      1) 要想使用，可以直接通过`this._provided.?`，是可以访问到上下文空间对象的
      2) 通过`this._provided.?`是无法造成，使用上下文数据的子组件的重新渲染的
         1) 直接通过inject取数据，然后{{}}中使用，是无法造成重新渲染的
            1) 相当于，取出数据，然后赋值给了某个属性，数据变化是不会重新赋值的
            2) props可以引发重新渲染，是父组件行间传参，建立的对应关系。
               1) 数据变化，根据对应关系，找到对应的组件，直接重新渲染
               2) inject是无法建立关系的，没有关系自然无法重新渲染
         1) 计算属性也无法进行重新渲染
   5) 子组件先从距离最近的父组件创建的上下文中取数据，如果没有，在继续向上查询         



## 父组件获取子组件中的数据

1. 获取子组件的环境
   1) 当前的组件环境有一个`$children`属性，通过该属性可以获取到下一级子组件的vue环境
      1) 由于下一级子组件可能有多个，所以该属性是一个数组
      2) 数组的每一项对应一个子组件的vue环境对象
      3) 比如: `this.$children[0]`，获取第一个子组件的vue环境对象
   2) 无法进行跨级获取，如果想要进行跨级获取，需要进行`$children`的连用
      1) 比如: `this.$children[0].$children[0]`


2. 通过数据引用的方式，获取到子组件的数据
   1) 其实获取的也是下一级子组件的vue环境，类似$children
   2) 在vue的行间中，有这么一个属性`ref`
      1) 行间，通过`ref="ref名称，自定义"`，启用ref
      2) 比如: `ref="a"`
   3) 普通的dom，使用ref
      1) 通过`this.$refs.对应的ref名`。获取到的是该dom节点
   4) 组件，使用ref
      1) 通过`this.$refs.对应的ref名`。获取到的就是该组件对应的vue环境
   5) 注意同一个组件下，ref不要重复，否则发生替换
   6) v-for循环对应的ref比较特殊
      1) 由于，v-for循环产生对应的html结构，ref势必会相同
      2) 虽然相同，但是不会进行替换，而是把它们放在一个数组中
      3) 通过`this.$refs.对应的ref名`，获取到的就是一个数组
      4) 数组的每一项，对应循环产生的dom节点或者组件的vue环境对象



3. 通过函数传参的方式，获取子组件的数据
   1) 父组件中声明一个函数，然后把函数传入子组件中
   2) 子组件调用函数，把对应的数据传入，这样父组件就可以获取到子组件中的数据



4. 子组件通过手动触发组件上绑定的事件，向父组件传参
   1) 原理借助的还是函数传参
   2) 组件上绑定的事件可以是自定义的，也可以是原生的
      1) 绑定方式，比如: `<App @a="func" />`
   3) 子组件中，就可以通过`$emit()`方法，手动触发组件上绑定的事件
      1) 使用方式: `this.$emit(事件名, 传递的参数1，传递的参数2，··· ···)`
      2) 比如: `this.$emit("a", this.b)`
         1) 触发func函数，然后把b传入
   4) 子组件中，通过`this.$options._parentListeners`，可以获取到组件上绑定的事件函数
      1) 得到的是一个对象，对象的属性名为事件名，属性值为事件函数
      2) 这样就可以手动直接调用事件函数，进行传参，不用通过`$emit`进行触发
      3) 比如: `this.$options._parentListeners.a( this.b )`，但是有些麻烦
   5) 子组件中，通过`this._events`，可以获取到组件上绑定的事件函数
      1) 得到的是一个对象，对象的属性名为事件名，属性值为一个数组
         1) 数组中的数据为对应的事件函数
      2) 可以直接调用事件函数，进行传参，，不用通过`$emit`进行触发
      3) 比如: `this._events.a[0]( this.b )`，但是有些麻烦



## 兄弟组件间的传参

1. 借助共同的父级
   1) 先把数据传入共同的父级中，然后共同的父级在把数据传入另一个组件中
   2) 过程过于麻烦


2. 利用事件总线的方式，实现兄弟组件间的传参
   1) 原理，在事件总线上绑定函数，然后其它的组件手动触发事件总线上绑定的函数，进行数据传递
      1) 类似事件传参
      2) 往事件总线上绑定函数，是在组件中完成的，利用组件上的一个方法。
      3) 创建一条事件总线，`Vue.prototype.自定义事件总线名 = new Vue()`
         1) 该条事件总线，就会贯穿整个组件
      4) 组件中，往事件总线上绑定方法
         1) 通过`this.总线名.$on("自定义事件名", 事件处理函数)`
         2) 如果事件处理函数中，需要使用this，获取到当前组件的vue环境对象
            1) 必须写成箭头函数的形式
            2) 如果使用function关键字定义的事件处理函数，则this指向有问题
               1) 指向的是创建事件总线时new Vue()，返回的vue环境对象
         3) 由于，事件处理只需要注册一次，所以通常周期函数`mounted`中注册
         4) 并且事件名可以重复，不会发生覆盖现象
            1) 会按照注册的顺序，全部触发
            2) 甚至多个组件中，都可以注册同一个事件名
            3) 触发的时候，多个组件中注册的事件函数，都会触发
            4) 只要是该事件名，全面触发
      5) 组件中，触发事件总线上绑定的事件，进行传参
         1) 通过`this.总线名.$emit("将要触发的事件名称", 传参, 传参, ··· ···)`
         2) 父子级间的传参，也可以使用事件总线的方式，进行传参
   






# 父子级组件间的双向通信

1. 作用
   1) 父子级组件共用一个数据


2. 原理
   1) 父组件定义数据，然后通过行间传参的方式传入子组件中
   2) 同时在传入一个函数，子组件通过传入的函数，可以实现对父组件中的数据进行修改


3. vue中专门提供了一种方式
   1) 把传入函数与传入数据绑定在一起
   2) 即: `:b.sync="?"`
   3) `?`表示用来进行双向数据绑定的数据
   

4. `:b.sync`的原理
   1) 和v-model实现双向数据绑定的原理一样
   2) 使用的是绑定事件的方式
   3) 绑定的事件为: `update:b`
   4) 子组件要想修改`:b.sync`中绑定的数据，需要手动触发`update:b`事件
      1) 具体代码: ``this.$emit("update:b", 123)``



5. 借助`v-model`来实现父子级组件的双向数据通信
   1) 该方法给组件绑定的事件为`input`事件
   2) 子组件需要手动触发`input`事件，来修改绑定的数据
      1) 具体代码: `this.$emit("input", 123)`



   






# props数据的验证

1. 作用
   1) 只作用于开发阶段
   2) 限制父组件，通过props向子组件所传参数的格式
   3) 如果不符合设置的格式，则控制台打印出错误，但是赋值正常
   4) 给开发者起一个提示的作用


2. 具体使用
```js
Vue.component('my-component', {
   props: {
      // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
      propA: Number,
      // 多个可能的类型
      propB: [String, Number],
      // 必填的字符串
      propC: {
         type: String,
         required: true
      },
      // 带有默认值的数字
      propD: {
         type: Number,
         default: 100
      },
      // 带有默认值的对象
      propE: {
         type: Object,
         // 对象或数组默认值必须从一个工厂函数获取
         default: function () {
         return { message: 'hello' }
         }
      },
      // 自定义验证函数
      propF: {
         validator: function (value) {
         // 这个值必须匹配下列字符串中的一个
         return ['success', 'warning', 'danger'].indexOf(value) !== -1
         }
      }
   }
   })
```








# 组件上的事件操作


1. 使绑定的事件起作用
   1) 在组件上绑定的事件，是无法自动触发的
      1) 比如: 绑定click事件，点击该组件下的元素，是触发不了事件的
      2) 组件标签，并不是一个原生的标签，无法进行用户操作监控
   2) 要想使绑定的事件发生作用，需要加上修饰符`native`
      1) 比如: `<a-b @click.native="func"></a-b>`


2. 组件中，获取组件上绑定的事件
   1) 通过`this.$listeners`可以获取事件对象
   2) 事件名作为属性值，事件绑定的方法作为属性值
   3) **注意: 如果事件使用了native修饰符，则通过$listeners获取不到**


3. 手动触发事件
   1) 标准方法: `this.$emit("事件名", 传参)`
   2) 直接取出事件函数进行调用: `this.$listeners.函数名(传参)`



4. 组件内移用组件上的所有事件
   1) 把组件上所有的事件原封不动的，在给其它标签和组件绑定
   2) 借助的是`v-on`和`$listeners`。方法为`v-on="$listeners"`
      1) 只要组件中的某个标签或者子组件的行间写上，上面的方法
      2) 则该标签或者子组件，就会绑定当前组件上所有的事件
   3) 该方式，可以实现组件间的事件函数的传递
      1) 前提是组件上的事件没有使用修饰符`native`
      2) 否则`$listeners`获取不到
      3) 移用的是`$listeners`中的所有事件
         1) 相当于遍历该对象，然后把内部的事件依次进行重新注册












# 组件上的slot插槽

1. 作用
   1) slot插槽的作用，给组件中动态的添加一些html结构
   2) slot插槽分为普通插槽和具名插槽两种


2. 普通插槽的使用
   1) 普通插槽，无需做任何操作
   2) 在使用组件时，直接书写html内容
   3) 组件中，使用插槽，直接通过`<slot></slot>`标签进行使用
      1) 会把使用该组件时，书写的html内容放到该位置
         1) **插入的是，行间没有使用slot属性的节点**
         2) 行间使用`slot`属性的节点，替换的是具名插槽
         3) 相当于提取出所有的没有`slot`属性的节点，然后在进行替换
      2) 比如: `<el-a><a>123</a></el-a>`中的`<a>123</a>`替换组件中的`<slot></slot>`标签
   4) `<slot></slot>`标签不会发生覆盖现象，也不会只替换最后一个
      1) 组件中有几个`<slot></slot>`标签，就替换几个
   5) 如果使用组件时，没有写html，则`<slot></slot>`标签替换为空
      1) 相当于直接删除，啥也不干



3. 具名插槽的使用
   1) 通过`<slot></slot>`标签，行间属性`name`，给`<slot></slot>`标签定义一个名称
      1) 随便定义
      2) 这样，`<slot></slot>`标签就变成了具名插槽，有名字了
   2) 具名插槽的name，与使用该组件时书写的html中，节点的slot属性，形成对应关系
   3) 把所有具有相同的`slot`属性的节点，替换与对应的`name`属性相同的`slot`标签
      1) 相当于把所有相同的具有相同的`slot`属性的节点，提取出来
      2) 然后替换，对应的`name`属性相同的`slot`标签
      3) 有几个替换几个
   4) 如果没有找到对应的`name`属性相同的`slot`标签，则不会进行替换
      1) 不会替换普通的插槽，直接舍弃掉了


4. 在js中使用传进来的插槽节点，即组件的html结构
   1) 通过`this.$slots`可以获取所有的插槽节点
      1) 包括具名插槽，普通插槽
   2) `this.$slots`获取的是一个对象，对象中的属性名就是插槽的名称
      1) 普通插槽的名称是: `default`
      2) 所以，普通插槽也是具名插槽，有默认的名称
   3) 每个插槽的属性值都是一个数组
      1) 不确定有几个符合的节点，所以把所有符合的节点提取出来，放入数组中
         1) 具名插槽根据`slot`属性提取，普通插槽提取没有`slot`属性的节点


5. 与`render`的联合使用
   1) 数组的每一项，是一个虚拟节点对象
      1) **可以直接作为，render函数的第三个参数中的节点，直接传入**
      2) 使用render函数接收的函数，也是创建的虚拟节点
      3) 所以可以直接使用，插槽节点
   2) `render`函数的第三个参数，可以传递数组，表示该节点有不止一个子节点
      1) 而插槽属性，对应的属性值，就是提取出的、对应的虚拟节点组成的数组
      2) 所以可以直接作为第三个参数，传入整个插槽节点数组
      









# 数据库vuex的使用

## vuex的准备工作(下载，创建对应的文件，加入vue中)

1. vuex的下载
   1) 如果使用脚手架创建的项目，下载vuex的方式
      1) 在命令行中，输入`vue add vuex`
      2) 会自动生成store文件。
   2) 只下载vuex仓库依赖，store文件手动创建
      1) 在命令行中，输入`npm i vuex -D`


2. store文件中的代码
```js
// 引入插件依赖
import Vuex from "vuex";
import Vue from "vue";
// 激活Vuex插件
Vue.use(Vuex);

// 导出仓库对象
export default new Vuex.Store({
    // 开启严格模式，false关闭严格模式
    strict: true,
    // 定义数据
    state: {
    },
    // vuex的计算属性(相当于computed)
    getters: {
    },
    // 配合严格模式使用，定义专门修改数据的方法
    mutations: {
    },
    // 定义的方法可以使用异步操作
    actions: {
    },
    // 模块化开发的属性(内部定义一个一个的模块)
    modules: {
    }
})
```

3. vue中植入仓库
   1) Vue的传参对象中，存在一个`store属性`，该属性的属性值是一个对象
   2) `store属性`用于指向仓库对象(保存仓库)
   3) `store.js`文件中，`export default new Vuex.Store()`，导出的就是仓库对象
   4) **把导出值赋值给`store属性`，Vue中就可以访问到仓库对象，从而使用仓库数据**
      1) 导入仓库对象: `import store from "./store.js"`
      2) Vue中植入仓库对象: `new Vue({ store: store })`
   5) **通过`this.$store`访问的就是`store属性`指向的对象(仓库空间)**
      1) 如果给`store属性`赋值其它数据，通过`this.$store`获取的就是其它数据
   6) **`$store`是可以继承的**
      1) 如果当前组件，没有对store赋值，则默认继承父组件的
         1) 即: `this.$store`，获取的是父组件的`store属性`指向的空间
         2) 如果父组件中没有，继续向上查询，最终到达根组件(Vue的传参对象)
         3) 这也是为什么，把仓库对象，在Vue的传参对象中引入
         4) 这样做，整个Vue下的所有组件都可以通过`$store`访问到同一个仓库对象
         5) **达到了组件间相互传参的效果**


4. 操作仓库只能通过`this.$store`
   1) 即使是`vuex`封装的一些方法，利用这些方法快速生成操作仓库的方法
   2) 底层也是使用`this.$store`完成的对仓库的操作




## Vue.use()的详解

1. 作用
   1) 用于激活某个插件，使其可以正常工作

2. 底层代码实现
   1) `Vue.use`在调用时，传入一个对象，并且对象中存在install属性，是一个方法
   2) **`Vue.use`内部自动调用传入对象的`install方法`**
      1) 并且向install方法中传入`Vue构造函数`
      2) 代码实现: `Vue.use = function ( obj ) { obj.install(Vue) }`
      3) 可以在外部手动调用，`install方法`，然后传入Vue，实现的效果相同
      4) 比如: `Vuex.install(Vue)`，激活`vuex`
         1) 相当于`Vue.use(Vuex)`;
      




## 仓库中的state对象

1. 作用
   1) 专门用于存放，仓库数据的对象


2. vue组件，使用`state对象`中定义的数据的方式
   1) 通过`$store`使用
      1) `$store`访问的是仓库对象，进而可以访问到仓库对象中的state中定义的数据
      2) 具体的取值和赋值(修改数据)操作
         1) 取值: `this.$store.state.?`;
         2) 赋值(修改数据): `this.$store.state.? = ?`;
   2) 通过`vuex`导出的方法，创建对应的计算属性，间接的获取仓库数据
      1) 导出创建计算属性的方法
         1) `import { mapState } from "vuex"`;
      2) 创建计算属性
         1) `const a = mapState(['a', 'b'])`;
         2) 想要使用那个数据，就传入对应的属性名，然后自动创建出对应的计算属性
      3) 计算属性生效
         1) `computed: { ...a }`
         2) 连写: `computed: { ...mapState(['a', 'b']) }`
         3) 由于创建的函数的内部，使用的是`this`访问的`$store`
         4) 所以需要，在`computed`中展开，然后通过`this.?`的方式使用，`this`才会指向正常
         5) 如果通过`a.?`的方式使用，此时`this`指向就会出现问题
            1) `this`指向的是`obj`，没有`$store`这个属性
      4) 计算属性的使用
         1) js运行过程中使用: `this.a`
         2) 模板中使用: `{{b}}`
      5) 计算属性名，与传入数组中的对应属性名相同
      6) 对计算属性进行**重命名**，防止与data中的属性名产生冲突
         1) 不需要进行重命名的，正常创建`const a = mapState(['a', 'b'])`
         2) 需要进行重命名的，单独创建`const b = mapState({ mC: (state) => state.c })`
            1) 相当于重写了计算属性，这样就可以自定义名称了
            2) 接收的state数据，就是仓库中的state对象
            3) 这样，当访问计算属性mC时，运行代码，得到的结果为`state.c`，达到了重命名的效果
         3) 启用计算属性，把得到的计算属性对象正常展开就可以使用
            1) 比如: `computed: {...a, ...b}`
   3) 创建的计算属性，不能用于修改state中的数据，即没有提供`set`，只有get的功能
      1) 要想修改state中的数据，需要借助`$store`
   

3. mapState方法的原理
   1) 使用`mapState`创建的计算属性，底层借助的还是`this.$store`，获取仓库中的数据
   2) 具体的示范代码(返回值的示范代码)
      1) `return this.$store.state[key]`
      2) `key`是遍历`mapState`方法执行时传参数组，得到的属性名






## 仓库中的getters对象


1. 作用
   1) 相当于vuex中的计算属性，获取数据时，进一步对数据进行处理


2. 定义
   1) 属性值是一个函数体，函数体接收一个参数，当前仓库的state对象
   2) 比如: `getters: { mC(state) { return state.name + 1; } }`
      1) 定义了一个`mC`属性
      2) 当获取mC时，运行函数体，接收自动传入的state对象，对内部的数据进行加工
      3) 获取的mC，就是函数的返回值


3. vue组件，使用`getters对象`中定义的计算属性的方式
   1) 通过`$store`获取
      1) 取值: `this.$store.getters.?`;
   2) 通过`vuex`导出的方法，创建对应的计算属性，间接的使用
      1) 导出创建计算属性的方法
         1) `import { mapGetters } from "vuex"`;
      2) 创建计算属性
         1) `const a = mapGetters(['a', 'b'])`;
         2) 想要使用那个数据，就传入对应的属性名，然后自动创建出对应的计算属性
      3) 计算属性生效
         1) `computed: { ...a }`
         2) 连写: `computed: { ...mapGetters(['a', 'b']) }`
         3) 由于创建的函数的内部，使用的是`this`访问的`$store`
         4) 所以需要，在`computed`中展开，然后通过`this.?`的方式使用，`this`才会指向正常
         5) 如果通过`a.?`的方式使用，此时`this`指向就会出现问题
            1) `this`指向的是`obj`，没有`$store`这个属性
      4) 计算属性的使用
         1) js运行过程中使用: `this.a`
         2) 模板中使用: `{{b}}`
      5) 计算属性名，与传入数组中的对应属性名相同
      6) 对计算属性进行**重命名**，防止与data中的属性名产生冲突
         1) 不需要进行重命名的，正常创建`const a = mapGetters(['a', 'b'])`
         2) 需要进行重命名的，单独创建`const b = mapGetters({ mC: c })`
            1) 把c重名为mC
         3) 启用计算属性，把得到的计算属性对象正常展开就可以使用
            1) 比如: `computed: {...a, ...b}`



4. mapGetters方法的原理
   1) 使用`mapGetters`创建的计算属性，底层借助的还是`this.$store`，获取仓库中对应的数据
   2) 具体的示范代码(返回值的示范代码)
      1) `return this.$store.getters[key]`
      2) `key`是遍历`mapGetters`方法执行时传参数组，得到的属性名
   3) 通过`this.$store.getters.?`获取属性，运行对应的`getters`中定义的方法的原理
      1) 获取属性，运行方法，是`set函数`的功能
      2) Vuex底层，把getters对象中的方法，进行了特殊的处理。转换成了`set`
         1) 使用`Object.defineProperty()`方法就可以实现
      3) 由于getters对象，底层使用了`Object.defineProperty()`进行了转换
         1) 内部的属性，是不可能通过点点点运算符遍历出来的
         2) 只能通过`$store`进行获取
         3) 直接使用`$store`进行获取
         4) 使用`mapGetters`创建计算属性，间接的使用`$store`进行获取





## 仓库中的mutations对象

1. 作用
   1) **创建修改state中数据的方法**
   2) 虽然可以直接通过`$store`访问到仓库对象，直接修改数据，毕竟不是很保险
      1) 如果组件非常庞大，万一那个组件修改数据，出现了问题，找起来十分麻烦
      2) 这样就可以使用`mutations对象`中创建的方法，间接的修改数据
   3) `mutations对象`中创建的方法。类似仓库的管理者
      1) 当修改仓库中的数据，发生问题的时候，不用每个组件去查询
      2) 直接调试`mutations对象`中，创建的对应的方法即可
      3) 所有修改数据的操作，都是通过`mutations对象`中创建的方法，进行修改
      4) 是数据发生变化的实际操作者，是根源
      5) 组件中修改数据的操作，只是通知实际操作者，你要修改数据了
      6) 出现问题，应该找根源`mutations对象`
         1) 类似中介，出现问题找中介，而不用该找客户
         2) 客户只是创建一个描述信息，通知中介
         3) 如果出现问题，就是中介理解错误，应该在中介处修改
         4) 也有可能是客户使用的描述信息不对，导致中介处理出现了问题，从而引发错误



2. mutations对象中，修改数据方法的创建
   1) 创建方法: `mutations: {  a(state, payload) { }  }`
   2) 分析
      1) a执行的时候，会传入仓库中的`state对象`，进行数据的修改
      2) 传入的第二个参数`payload`，是对本次修改的描述信息
      3) 函数体中，对`payload`进行分析，按照描述信息，对state中的数据进行修改
      4) 组件中，只需要构建`payload`描述信息即可


3. 使用`mutations对象`中，构建的修改数据方法的方式
   1) 使用`$store`进行使用
      1) 使用`$store`获取到仓库对象，但是仓库对象中没有`mutations对象`
         1) 要想访问到`mutations对象`中的方法
         2) 需要借助`$store`中的`commit方法`，进行使用
      2) 比如: `this.$store.commit("a", {});`
      3) 分析
         1) 第一个参数，传入调用的`mutations对象`中方法的方法名
         2) 第二个参数，传入`payload`(描述信息)，可以是任意数据
   2) 借助`vuex`插件提供的方法，快速创建调用`mutations对象`中方法的方法
      1) 导入`vuex`的方法
         1) `import { mapMutations } from "vuex"`
         2) 快速创建对应的方法
            1) `const obj = mapMutations(['a'])`
         3) `mapMutations`返回的是一个对象，需要在`methods`中展开才能使用
            1) 由于对象中的方法，底层借助`this.$store.commit`
            2) 所以，不能直接通过`obj.?`进行使用，否则this指向obj对象，无法使用`$store`
            3) 只有把obj中的方法，在`methods`中展开，然后通过`this.?`调用
            4) 此时创建的函数的内部的`this`，才会指向当前的组件环境，可以正常使用`$store`
            5) 比如: `methods: { ...mapMutations(['a']) }`
            6) 使用: ` this.a( payload ) `，只需要传入`payload`(描述信息)
       2) `mapMutations`创建的对象中，是普通的方法，所以只能在`methods`中展开
          1) `methods`中定义的就是普通的方法，可以通过`this`调用
       3) 对`mapMutations`创建的对象中的属性进行重命名
          1)  `methods: { ...mapMutations({mB: 'b'}) }`
          2) 把`b`重命名为`mB`


4. `mapMutations`构建的方法的原理
   1) 底层借助的还是`this.$store.commit`方法，调用对应的`mutations对象`中的方法


5. `commit`方法的原理
   1) 只能通过该方法，调用`mutations对象`中的方法
   2) 根据`commit`方法的第一个参数，调用对应的`mutations对象`中的方法
   3) 然后，给调用的`mutations对象`中的方法传参
      1) 第一个参数传入state对象
      2) 第二个参数传入`commit`方法的第二个参数


6. `mutations`中定义的方法，不能存在异步操作
   1) 只能同步修改数据
   2) 如果进行异步修改数据，就会报错



## 仓库中的actions对象

1. 作用
   1) 内部代码可以实现异步操作，比如异步修改数据


2. actions对象中方法的创建
   1) `actions: {  a({commit}, payload) { }  }`
   2) 分析
      1) 接收的第一个参数，是一个对象，对象中常用的属性
         1) `state`，指向state对象，可以直接修改数据
         2) `commit`，通过该方法，调用mutations对象中定义的方法，间接的修改数据
            1) 比如: `commit("a", payload)`
            2) 指定，调用那个方法，把外界传入的payload参数，传入进去
            3) 通过把第一个参数，解构使用
      2) 接收的第二个参数，是传入的操作数据的信息对象



3. 使用`mutations对象`中，构建的修改数据方法的方式
   1) 使用`$store`进行使用
      1) 使用`$store`获取到仓库对象，但是仓库对象中没有`actions对象`
         1) 要想访问到`actions对象`中的方法
         2) 需要借助`$store`中的`dispatch方法`，进行使用
      2) 比如: `this.$store.dispatch("a", {});`
      3) 分析
         1) 第一个参数，传入调用的`actions对象`中方法的方法名
         2) 第二个参数，传入`payload`(描述信息)，可以是任意数据
   2) 借助`vuex`插件提供的方法，快速创建调用`actions对象`中方法的方法
      1) 导入`vuex`的方法
         1) `import { mapActions } from "vuex"`
         2) 快速创建对应的方法
            1) `const obj = mapActions(['a'])`
         3) `mapActions`返回的是一个对象，需要在`methods`中展开才能使用
            1) 由于对象中的方法，底层借助`this.$store.dispatch`
            2) 所以，不能直接通过`obj.?`进行使用，否则this指向obj对象，无法使用`$store`
            3) 只有把obj中的方法，在`methods`中展开，然后通过`this.?`调用
            4) 此时创建的函数的内部的`this`，才会指向当前的组件环境，可以正常使用`$store`
            5) 比如: `methods: { ...mapActions(['a']) }`
            6) 使用: ` this.a( payload ) `，只需要传入`payload`(描述信息)
       2) `mapActions`创建的对象中，是普通的方法，所以只能在`methods`中展开
          1) `methods`中定义的就是普通的方法，可以通过`this`调用
       3) 对`mapActions`创建的对象中的属性进行重命名
          1)  `methods: { ...mapActions({mB: 'b'}) }`
          2) 把`b`重命名为`mB`


4. `mapActions`构建的方法的原理
   1) 底层借助的还是`this.$store.dispatch`方法，调用对应的`actions对象`中的方法


5. `dispatch`方法的原理
   1) 只能通过该方法，调用`actions对象`中的方法
   2) 根据`dispatch`方法的第一个参数，调用对应的`actions对象`中的方法
   3) 然后，给调用的`actions对象`中的方法传参
      1) 第一个参数传入，自动构建的对象，对象中放入一些数据
      2) 第二个参数传入`dispatch`方法接收到的第二个参数





## 仓库中的modules对象

1. 作用
   1) 进行仓库的模块化开发，适用于庞大的仓库开发


2. 仓库模块的创建方式
   1) 利用`namespaced`属性，开启命名空间，给当前的仓库模块起一个名字
      1) 属性值，为Boolear类型，为`true`，开启命名空间
      2) 把`modules`对应的属性名，作为仓库名
   2) 其它的属性也是仓库中的那几个属性，并且作用也相同
   3) 甚至，模块中可以利用`modules`属性，继续嵌套模块


3. 具体的示范代码
```js
export default new Vuex.Store({
    modules: {
        // 组件a
        a: {
            // 开启命名空间
            namespaced: true,
            state: { },
            getters: { },
            mutations: { },
            actions: { },
            modules: {
                c: {
                    namespaced: true, 
                }
            }
        },
        // 组件b
        b: { }
    }
})
```


4. 模块化开发
   1) 既然每个模块，都是一个单独的对象
   2) **就可以单独的提取出来，新建一个js文件，然后抛出模块对象**
   3) 引入: `import a from './a.js'`;
   4) 使用: `modules: { a }`


5. 模块化开发，构建仓库的原理
   1) 虽然仓库中的数据，是在各个模块中进行创建定义的
   2) `Vuex.Store`在进行处理的时候，会把各个模块合并到一个对象中，然后抛出
   3) 合并的原理
      1) state中的数据
         1) 以模块名，作为属性名
         2) 属性值: 模块中的state对象
         3) 每个模块，还是单独的state对象
      2) 其它对象中的数据
         1) 不会形成单独的对象，而是合并到一个对象中
         2) 只不过每个模块中的属性名进行修改，防止覆盖
         3) 修改规则: `第一级组件名/第二级组件名/··· ···/模块中对应的属性名`
            1) 比如: `a/b/?`、`a/?`
         4) 只有开启命名空间的模块，才会进行拼接
         5) 没有开启命名空间的模块，直接用属性名，不进行拼接
            1) 如果不同模块中的属性名相同，就会产生冲突，进而报错


6. 命名空间的作用
   1) 不开起命名空间，模块化也可以使用
   2) 但是有几点注意点
      1) state对象是单独的对象，所以没有问题，不会产生冲突问题
      2) 其它对象的属性，用于合并到同一个对象中，所以会自动拼接，但是必须开启命名空间
      3) **没有开启命名空间的模块，直接用属性名，不进行拼接**
         1) 如果不同模块中的属性名相同，就会产生冲突，进而报错
   3) **虽然不开起命名空间，其它对象的属性不进行拼接，但是state对象依旧以模块的方式存在**


7. vue中使用模块化仓库中数据的方式(针对开启命名空间的仓库)
   1) 使用`$store`获取，获取到创建的仓库对象
      1) 获取仓库中state中的数据，向对应模块中获取
         1) 比如: `this.$store.state.a.name`
      2) 获取其它对象中的数据，使用拼接后的属性名获取
         1) 比如: `this.$store.getters.a/myname`
         2) 比如: `this.$store.commit("a/b/myna", {})`
      3) 就是正常的操作对象
   2) 使用vuex提供的方法，快速创建获取方法
      1) 底层借助的还是`$store`
      2) 创建对应属性的使用方法时
         1) 第一个参数传入模块名
         2) 第二个参数传入对应的属性名，不是拼接后的，而是原始定义的
         3) 比如: `...mapState('a', ["name"])`
         4) 比如: `...mapGetters('a/b', ["myname"])`，模块嵌套


8. vue中使用模块化仓库中数据的方式(没有开启命名空间的仓库)
   1) 使用`$store`获取，获取到创建的仓库对象
      1) 获取仓库中state中的数据，向对应模块中获取
         1) 比如: `this.$store.state.a.name`
         2) 虽然没有开启命名空间，但是state依旧以模块的方式存在
      2) 获取其它对象中的数据，使用原始属性获取
         1) 不会进行拼接，在使用拼接属性获取，获取不到
         2) 比如: `this.$store.getters.myname`
         3) 比如: `this.$store.commit("myna", {})`
      3) 就是正常的操作对象
   2) 使用vuex提供的方法，快速创建获取方法
      1) 底层借助的还是`$store`
      2) 创建对应属性的使用方法时，比较特殊
         1) 第一个参数传入的是空间名，但是由于对应的模块没有开启空间名
         2) 所以第一个参数传入的比较特殊，由底层原理控制
            1) 如果是`mapState`，需要传入命名空间
            2) 如果是其它对象，传入空字符串
         2) 第二个参数传入对应的属性名，不是拼接后的，而是原始定义的
         3) 比如: `...mapState('a/c', ["name"])`
         4) 比如: `...mapGetters('', ["name"])`



9. 使用vuex提供的方法，快速创建获取模块化仓库数据的方法的原理
   1) 底层借助的还是`$store`，操作仓库对象
   2) 所以，需要对传入的模块名进行处理
      1) 如果是`mapState`方法，对传入的模块名进行拆分
         1) 然后根据拆分值，去对应的state对象中取数据
         2) 这也是无论是否开启命名空间，都需要传入模块名
         3) 因为它们创建的state相同，都是模块化
      2) 如果是`其它`方法，对传入的模块名与数组中的属性名进行字符串拼接
         1) 拼接完成，形成了真正的属性名，对应仓库中的属性名
         2) 然后借助`$store`进行获取
         3) 这也是没有开启命名空间的模块，传入空字符串的原因
         4) 没有开启命名空间的模块，直接把属性名作为仓库对应的属性的属性名，没有进行拼接
            1) 在获取时，也不能进行拼接，所以传入空字符串，拼接完还是原属性名








# 路由的使用
  
## 准备工作(插件下载)

1. 下载插件
   1) 脚手架下载方式
      1) `vue add router`
   2) 自定义webpack中使用路由的下载方式
      1) `npm i vue-router -D`
      2) 路由的使用需要借助服务器，所以在开发阶段，需要配置服务器
         1) 下载服务器: `npm i webpack-dev-server -D`
         2) 配置服务器: `devServer: { contentBase: "dist" }`


2. 创建router.js文件
   1) 脚手架会自动创建，router.js文件
   2) router.js中的代码
   ```js
   import Vue from "vue";
   import Router from "vue-router";
   
   // 激活Router组件
   // Router.install(Vue);
   Vue.use(Router);
   
   // 导出路由对象(根据传参创建的对象)
   export default new Router({
       // 开启浏览器历史模式
       mode: "history",
       // 路由信息
       routes: [
           {   
               // 父路由信息
               path: "/a",
               component: ?,
               // 子路由信息
               children: [
                   {
                       path: "/a/c",
                       component: ?,
                   }
               ]
           }
       ]
   })
   ```


3. `Vue.use(Router)`的作用
   1) 激活Router
   2) 创建两个组件
      1) 底层运行`Router.install(Vue)`;
      2) 传入Vue，使用传入的Vue创建全局组件
      3) 模板中可以直接使用`router-link`和`router-view`组件
      4) 并没有在对应的组件中使用`components属性`定义这两个组件




4. 把路由对象，引入到vue中
   1) Vue的传参对象中，存在一个`router属性`，该属性的赋值对象就是路由对象
      1) 导入路由对象: `import router from './router.js'`
      2) 使用路由对象: `router: router`
      3) `router属性`向vue环境对象中添加了两个属性
         1) `$router属性`，通过该属性，可以访问到赋予的`router对象`
         2) `$route属性`，通过该属性，可以访问到赋予的`router对象`中的`currentRoute对象`
            1) 即`$route = $router.currentRoute`
            2) 由于该对象使用频繁，所以单独的封装了一个索引
         3) 这两个属性，在vue中，可以通过`this`的方式调用
      4) 由于`router属性`赋值后，在初始化时，需要使用赋值对象中的一些方法
         1) 所以，只能赋值路由对象，赋值其它对象报错



## 普通路由对象的分析与使用

1. 分析创建路由对象的传参(Router的传参对象)
   1) `routes属性`对应的数组中的每一个对象，就是一个路由信息对象
   2) 路由信息对象中的常用属性
      1) 其中，`path属性`，设置的是路径匹配规则，格式是正则
         1) 匹配成功，就会创建对应的组件节点，进而渲染组件
         2) 匹配失败，对应的组件不显示
         3) 类似于组件的显示与隐藏，控制条件为路径是否匹配成功
         4) **如果`path`属性，设置为`"*"`，则所有的路径都可以匹配成功**
            1) **path为"*"的路由信息对象，必须放在最后，否则影响巨大**
      2) `name属性`，该属性不是必须设置的一个属性，作用为给当前路由对象起一个名字
      3) `component属性`，设置的是匹配成功，加载的组件，两种赋值方式
         1) 先引入对应的组件对象，然后直接赋值
            1) 引入组件: `import A from "./A.vue"`
            2) 直接赋值: `component: A`
         2) 当第一次匹配成功后，对应的组件才进行加载，被称为按需加载
            1) 按需加载: `component: () => import("./A.vue")`
            2) 经过打包后，其实对应的文件代码已经打包进来了，只不过没有运行
               1) 如果一开始加载所有的组件，浏览器一打开页面，所有的组件代码就会运行一遍
               2) 而按需加载，是当需要时，才运行对应组件中的代码，节约一部分性能
               3) 运行完，就会进行缓存，即组件代码只运行一次
      4) `children属性`，定义子路由的信息
         1) 属性值为一个数组，数组的每一项，为一个子路由信息对象
         2) 子路由信息对象，与父路由对应的组件密切相关
      5) `redirect属性`，进行重定向的设置


2. **路由匹配成功，加载对应组件的规则**
   1) 路由对应的组件，加载的位置与`<router-view />`标签密切相关
   2) Vue在解析模板，构建对应的虚拟节点时
      1) 如果遇到了`<router-view />`标签，就会与当前的路径进行匹配
      2) 匹配规则: 
         1) **此时解析的模板，并不是路由组件，而是基础组件**
         2) 所以，`<router-view />`使用的匹配`path`，是所有一级路由中的
         3) 那个`path`匹配成功，就会在该位置显示对应的组件
         4) 比如: 匹配成功路由对应的组件为`A`，此时`A`组件就会加载
         5) 相当于把`<router-view />`替换成`<A />`，在该位置显示该组件
         6) 解析时，不受层级的限制
         7) 即使是子组件中的`<router-view />`也使用一级路由中的`path`进行匹配
      3) 每一个`<router-view />`，都会进行匹配，匹配成功就会在该位置加载对应路由组件
      4) **路由匹配成功，开始解析路由组件模板**
         1) 如果解析到了`<router-view />`标签，也会进行匹配
         2) 匹配规则: 按照`该组件对应的路由信息对象中的子路由信息`中的`path`进行匹配
         3) 匹配成功，把`<router-view />`替换成，匹配成功的子路由对应的组件，进行加载
         4) 组件加载完成继续分析子路由对应的模板，处理`<router-view />`标签
         5) 每一个`<router-view />`，都会进行匹配，匹配成功就会在该位置加载对应路由组件
         6) 解析时，不受层级的限制
         7) 即使是子组件中的`<router-view />`也使用子路由对象中的`path`进行匹配
      5) **所以: 子路由组件的显示位置，由父路由组件中的`<router-view />`标签控制**
      6) 某一个`<router-view />`匹配成功，就会加载对应的路由组件，然后进行分析
         1) 如果路由组件中，还存在`<router-view />`匹配成功，继续加载路由组件，继续分析
         2) 直到，匹配不成功，或者没有`<router-view />`，就没有对应的路由组件加载
         3) 然后，才会继续向下分析，如果又遇到了`<router-view />`，继续匹配加载分析
   3) 通常`<router-view />`写在根组件中，并且只写一个，便于管理分析
      1) 如果隐藏在子组件中，工程一庞大起来，后期调换`<router-view />`
      2) 不容易找到其所在的组件位置


3. `path`匹配的注意点
   1) vue中path的匹配都是完全匹配
   2) 如果当前路径被子路由匹配成功，则子路由的父路由组件也会进行加载
      1) 此时，父组件不遵循完全匹配
      2) 如果，父组件遵循完全匹配，子路由对应的路径，父路由一定匹配不上
      3) 如果，父路由匹配不上，则对应的父路由组件不会进行加载
      4) 父路由组件不进行加载，无法提供子路由组件显示位置的`<router-view />`
   3) 父路由组件的显示位置，由该路由的父级路由组件中的`<router-view />`控制
      1) 如果没有找到`<router-view />`，路由组件就不会进行加载，造成子路由组件也无法加载
      2) 如果是一级路由，没有父级路由，则由基础组件中的`<router-view />`控制显示位置
   4) 如果有一个路由的`path`，就不在进行向下匹配
      1) 所以`path: "*"`号的使用，只能最后，当前面的所有路由都匹配失败，该路由匹配成功
      2) 如果，放在前面，则无论是什么路径，它都能匹配成功，然后立刻停止匹配
      3) 则下方所有的路由对象都失效，对应的路由组件也不会被加载


4. 多级路由的path设置的注意点
   1) 必须要写全: 比如: `path: /a/b/c`
   2) 即必须以`/`开头，如果没有`/`开头会进行路径的拼接
   3) 拼接方式: 前面拼接上父路由设置的`path`，然后加上`/`，然后拼接上当前路由设置的`path`
      1) 比如: 父路由设置的`path`为`/a`，子路由设置的`path`为`b`
      2) 最终: 子路由的`path`会变成`/a/b`，进行拼接





## 路径的跳转
   
1. 作用
   1) 只是单纯的实现跳转路径
   2) 但是路径只要发生变化，就会自动触发路由的重新匹配，相当于对路径进行了监听

2. 跳转路径的方式(无刷新跳转)
   1) 通过js跳转
      1) 创建的路由对象中，它的原型上，有一个`push`方法
         1) 通过该方法就可以实现路径的无刷新跳转
         2) `push方法`的实现原理
            1) 该方法是重写后的方法，并不是浏览器元素的`push方法`
            2) 底层也没有进行过多的处理，只是进行判断，当不符合条件时，抛出一个错误
            3) 当没有问题的时候，调用`this.$router.history.push方法`进行路径的实际操作
            4) `this.$router.history.push方法`也是进行重写的方法
               1) 底层借助浏览器的`push`方法实现路径无刷新跳转
               2) 在原有的无刷新跳转页面的基础上，重启路由的匹配
      2) 由于路由对象，赋值给了`router`属性
         1) 所以在js中就可以通过`this.$router`访问到该对象
         2) 从而使用`push`方法，进行路径的无刷新跳转
         3) 比如: `this.$router.push("/a")`
         4) 也可以借助: `this.$router.history.push方法`进行跳转
         5) `this.$router.push`的底层借助的就是该方法
   2) 通过点击组件跳转
      1) 组件的使用: `<router-link to="?">a</router-link>`
      2) 当点击该标签后，路径跳转到`to属性`设置的值
      3) **该标签默认解析成`a标签`，可以通过`tag属性`指定创建什么标签**
         1) 比如: `<router-link to="?" tag="li">a</router-link>`
      4) 原理
         1) 绑定一个`click事件`，阻止a标签的点击默认刷新页面的默认功能
         2) **事件处理函数中，还是借助`this.$router.push()`实现**
         3) `push`方法的传参，就是to的属性值，原封不动的传入进去
      5) to的赋值方式
         1) to有两种赋值方式，一种为字符串格式，一种为对象格式
            1) 字符串格式: `<router-link to="/a">a</router-link>`
            2) 对象格式: `<router-link :to="{{name: 'a'}}">a</router-link>`
               1) 跳转路由，关键的是`path`，`name`没有用处
               2) 但是会根据name对应的值，找到路由数据中对应的`path`值，然后进行跳转
               3) 直接使用path: `<router-link :to="{{path: '/a'}}">a</router-link>`
         2) to的属性值会作为`push`的参数传入
         3) `push`的传参方式有两种，所以`to`的赋值方式也有两种
         4) **如果to赋值为对象格式，to必须写成`v-bind:to`或者`:to`**
      
      



## 动态路由的配置方法

1. 动态路由的path设置方式
   1) 借助`:`，完成动态路由的匹配
   2) 比如: `path: "/dong/:id/:c"`
   3) 只要是`/dong/?/?`的路径，都可以匹配成功，加载对应组件，`?`表示任意字符串

2. 把路径跳转到动态路由的方式
   1) 使用组件`<router-link to="?"></router-link>`进行跳转
      1) 比如: `<router-link to="/dong/a/d">`
      2) 动态路由中的to，如果采用对象格式的赋值方式
         1) **如果使用path，则path要写全，此时的params不起作用**
            1) 已经有path属性了，不会在重新构建
            2) 比如: `<router-link :to="{ path: "/dong/a/d" }">`
         2) 如果使用name，会进行比较特殊
            1) 取出对应的path，然后进行替换
            2) 比如: `<router-link :to="{ name: "a" params:{id: 'a', c: 'd'} }">`
            3) 根据name取出对应的path值，发现为`"/dong/:id/:c"`
            4) 此时，就会使用params中的数据，进行对应的替换
            5) 替换完的path变成: `"/dong/a/d"`
            6) 然后使用替换完的path，进行跳转



3. 动态路由加载的组件中获取动态路径的方法
   1) 获取设置的path，对应的带`:`的字符串，表示这是动态的路径
   2) 通过`this.$route.params.?`，可以进行获取
      1) 比如: `this.$route.params.id`
      2) 比如: `this.$route.params.c`
      3) `this.$route`对象，是`this.$router`对象中的一个属性指向的对象
         1) 为了便于使用，单独提取出来的
   3) 根据不同的路径，显示不同的组件内容


4. 获取动态路由的注意点(重点)
   1) 由于动态路由加载的都是同一个组件，如果路径切换完，动态路由还是可以匹配成功
   2) 此时虽然路径，发生了变化，但是路由组件不会重新加载，触发的也不是重新渲染
   3) 如果在mounted中获取动态路由，进而加载不同的组件内容，就会出现问题
      1) 一开始，组件激活，可以正常获取到动态路由，可以正常的进行判断处理
      2) 但是路径切换，此时的动态路由已经不符合条件，应该加载另一个符合条件的组件内容
      3) 但是发现，组件内容不会发生变化，原因就在于，组件没有重新加载
   4) **所以动态路由的获取，不光在`mounted`中获取，也需要在`beforeRouteUpdate`获取**
      1) 当前组件的环境依旧存在，但是路径发生了变化，`beforeRouteUpdate`函数就会执行
         1) 初次进入，`beforeRouteUpdate`函数不会执行，此时环境刚激活
         2) 激活后，路径并没有发生变化，所以`beforeRouteUpdate`是不会执行的
         3) 路径发生变化，但是匹配失败，组件进入卸载周期
            1) 环境都即将卸载，`beforeRouteUpdate`也是不会执行的
         4) 下次匹配成功，重新激活组件，是一个全新的环境
            1) 环境是一个新环境，初次进入，`beforeRouteUpdate`也是不会执行的
   5) `beforeRouteUpdate`使用的注意点
      1) 该方法共接收三个参数，前两个参数都是对象
      2) 只有第三个参数是一个函数，只有调用该函数，路径才允许发生变化
      3) 比如: `beforeRouteUpdate(to, from, next) {  next();  }`




## 重定向
 
1. 在Router构造函数的传参对象中的路由参数对象中，借助`redirect`属性进行配置

2. 具体的配置方式
   1) `redirect`属性有两种赋值方式
      1) 字符串
         1) 比如: `redirect: "/a"`
      2) 函数
         1) 比如: `redirect: (to) => { }`
   2) 当对应的路由匹配成功，重定向到`redirect属性`设置的路径
      1) 如果是函数赋值，则匹配成功，执行函数，并且传入当前的路径对象
      2) 然后函数运行的返回值，作为重定向的地址
      3) 传参对象中，存在一个`path`属性，通过该属性，可以获取到当前的路径
         1) 这样就可以根据当前的路径，进行动态的重定向，不用一次写死
   3) **函数赋值，通常用于`path: "*"`路由参数对象中**
      1) 这种path，所有的路径都可以匹配成功，即每个路径都会运行一次重定向函数
         1) 这样才能动态的判断`传参对象中的path属性`，实现动态重定向
      3) 如果写在path为固定值的路由参数对象中
         1) 每次匹配成功，运行重定向函数，得到的`传参对象中的path属性`都是一个值
         2) 其它值匹配不成功，重定向函数不会运行
         3) 这样的话，每次运行得到的返回值都相同，直接采用字符串赋值即可
         4) 除非有一些其它的处理，必须使用函数式赋值

3. 使用`path: "*"`进行重定向匹配的注意点
   1) 路由参数对象必须放在最后
   2) 重定向后的路径，在该路由参数对象的上面必须存在可以匹配成功的路由
   3) 如果上方不存在匹配成功的路由，会陷入重定向的死循环
      1) 上方匹配失败，被`path: "*"`匹配成功，重定向到另一个路径
      2) 底层借助的是`history.push`方法完成的路径跳转
      3) 跳转后，就会重新进行匹配，如果上方没有定义可以匹配的路由
      4) 又会被`path: "*"`匹配成功，继续跳转，继续匹配，陷入死循环
   4) 如果匹配成功，匹配终止，`path: "*"`不进行匹配，也就不会陷入重定向死循环了


4. 通常使用`path: "*"`进行重定向匹配，加载404页面
   1) 上方的所有路由，都匹配失败，表示没有该路由
   2) 然后`path: "*"`匹配成功，重定向到一个路径中
   3) 重定向的路径，在上方有定义，匹配成功，加载404组件
   4) 重定向到404的示范路由参数对象
   ```js
   {
       path: "*",
       redirect: (to) => {
           console.log(to);
           // 处理根路径的重定向和404的重定向
           if(to.path === "/"){
               // 该路径对应的路由参数对象，加载初始路由组件
               return "/home"    
           }else {
               // 该路径对应的路由参数对象，加载404路由组件
               return "/404"  
           }
       }
   }
   ```



5. 进行重定向的路由数据对象，不用写component，引入对应的组件
   1) 永远也不会进行显示
   2) 匹配成功，就进行重定向，然后重新匹配，加载其它的组件







# 以vue为后缀的文件介绍

1. VScode的辅助插件
   1) 插件名称`Vetur`
   2) 作用: 让vue代码高亮显示


2. 以vue为后缀的文件
   1) 相当于Vue中的components属性中的组件对象
   2) 它是一个普通的文件，要想转换成组件，需要借助webpack的loader进行处理


3. 每一个vue文件中定义的style样式，是会对全局起作用的，而不是只针对当前的vue文件
   1) 最终打包形成行间标签`style`中的样式，作用于全局









# 利用脚手架搭建专门的vue开发环境

1. 下载vue插件
   1) 在命令行中输入: `npm install @vue/cli -D`




2. 创建项目的步骤
   1) 在命令行中输入`npx vue create 文件名`，敲击回车键
   2) 选择`Manually select features`，表示重新创建一个项目，
      1) 在该选项上面还有一些选项，都是之前创建项目时，保存的该项目的创建流程(预设)
      2) 点击这些流程模板(预设)，会按照保存的流程快速创建出一个项目
      3) 如果重新创建，创建流程需要重新，一步一步的进行配置
   3) 进入一个选择项，选择一些依赖，选择和取消状态的切换，通过空格键来完成
      1) `Babel`: 把Es6语言降级成为Es5语言，适用于不支持Es6语言的浏览器
         1) 如果想对语言进行降级，可以选中该依赖，在创建的过程中，会下载对应的第三方插件
      2) `TypeScript`: 如果工程中设计到了`TypeScript`语言
         1) 浏览器不识别`TypeScript`
         2) 如果涉及到了该语言，需要选中该依赖，进行语言转换
      3) `Progressive Web`: 
      4) `Router`: 是否启用路由
      5) `Vuex`:
      6) `CSS Pre-processo`: 选中css预处理语言
      7) `Linter / Formatt`: 检查代码，如果不规范，进行提示
         1) 一个大项目，可能有多个开发人员共同开发，但是由于属于同一个项目，所以要求风格相同
         2) 此时，就可以使用该工具，约定风格格式，如果不符合进行提示
         3) 这样开发出来的代码，便于管理
      8) `Unit Testing`: 进行单元检测的
      9) `E2E Testing`: 
   4) 如果第三步选择依赖时，选择了`router`，会进入一个选择页面
      1) `Use history mode for router?`: 表示是否使用路由器的历史模式
   5) 如果第三步选择依赖时，选择了`CSS Pre-processo`，会进入一个选择页面
      1) 选择一些css的预处理语言，比如`scss`、`less`
   6) 如果第三步选择依赖时，选择了`Linter / Formatt`，会进入一个选择页面
      1) 选择一种语言规范，通常选择`ESLint + Airbnb config`语言标准
      2) 选择完语言标准，会进入一个选择页面，选择什么时候进行语言规范检测
         1) `Lint on save`: 代码一保存，就进行检测，通常选择该选项
         2) `Lint and fix on commit`: 向git仓库提交的时候进行检测
   7) 进入一个选择页面，选择一个测试的框架
      1) 自动生成一些代码(页面)，用于框架的测试
      2) 通常选择`Jest`
      3) 选哪个都可以，只是自动生成一些测试框架是否可以正常使用的一些代码，最终也是要删除的
   8) 进入一个选择页面，选择把配置文件放在那里
      1) `In dedicated config files`: 单独形成文件，常用
      2) `In package.json`: 把配置放在package.json，如果配置过长会导致`package.json`文件过大
   9) 进入一个选择页面，问是否保存本次创建流程
      1) `Save this as a preset for future projects?`
         1) 意思为: 将本次流程，保存为将来项目的预设
      2) 如果保存了，则下次在使用`npx vue create 文件名`创建文件时
      3) 第一项就会多一个选项，为本次的创建流程(上面选择的一些东西)
      4) 会按照本次流程，快速的创建出文件
   10) 选择完，点击回车，就会自动创建出一个项目




3. 自动修复不规范的代码
   1) 启用了代码规范检测，如果代码不规范，在打包时会报出不规范的地方
   2) 如果一个一个的修改，比较麻烦
   3) 可以另外打开一个终端(当前终端正在监听)
   4) 在新打开的终端，输入`npm run lint --fix`
      1) 会自动修改不规范的地方，直接修改源文件(读出来修改，在写进去)
      2) 修改完，监听的终端就会重新打包
      3) 该指令是生成文件的时候，根据所选的代码规范检测的方法，自动生成的
      4) 该指令不会开启监听，运行完直接结束
      5) 下次代码不规范，需要重新开启该命令
   5) 如果使用该指令修改完，还报不规范的地方，就需要手动修改了



4. 开启服务，运行工程
   1) 进入创建的文件: `cd 项目文件`
   2) 开启服务: `npm run serve`









# 手动使用webpack工具进行vue的开发

1. vue工作的入口是: `new Vue()`，就会进行模板的解析与替换

2. 需要借助的插件
   1) `vue`: 提供vue构造函数
   2) `vue-loader、vue-template-compiler`: 用于解析`.vue`为后缀的文件
      1) 如果不涉及vue为后缀的文件引入，这两个插件不需要下载。
         1) 配置文件中也不需要配置对应的代码
      2) **原理(vue模块化开发的原理)**
         1) 浏览器是不认识以vue为后缀的文件的，所以需要时webpack工具进行打包
            1) 借助loader，把以vue为后缀的文件进行代码替换
         2) 把以vue为后缀的文件，解析成对应的一个模块对象
         3) 就是Vue传参对象中components属性，定义的模块对象
         4) 当使用`import或者request`引入以vue为后缀的文件时，得到的就是模块对象
            1) loader对以vue为后缀的文件中的代码进行了重写
            2) 把原先的代码解析成对应的模块对象，然后把模块对象进行抛出
            3) 比如: `const obj = {};  export default obj;`
            4) 初次引入以vue为后缀的文件，运行的就是替换代码，然后得到模块对象
            5) 之后，就是从缓存中取模块对象


3. 配置文件代码
```js
const VueLoaderPlugin = require("vue-loader/lib/plugin");
module.exports = {
    entry: "./src/index.js",
    mode: "development",
    output: {
        path: __dirname + "/dist",
        filename: "index.js"
    },
    module: {
        rules: [
            {
                test: /\.vue$/,
                use: ["vue-loader"]
            },
        ]
    },
    plugins: [
        new VueLoaderPlugin()
    ],
    resolve: {
        alias:  {
            vue: "vue/dist/vue.js"
        }
    }
}
```
