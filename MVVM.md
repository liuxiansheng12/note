<!-- [toc] -->
# 谈谈MVVM
MVVM是一种分层次开发思想,它是CommonJS规范的实现
M代表module模型层
V代码view视图层
VM模型层和视图层之间没有任何的联系,而VM会充当一个调度者,将他们联系起来,实现双向数据绑定


# 1 实现数据的代理
主要作用是实现数据的监控，只要数据发生变化，触发对应数据的重新渲染。
方法: 定义一个方法，接收传入的数据对象，对对象中的属性进行遍历判断，是对象，创建对象的监听。
是数组对数组的方法进行重写(重写方法是定义一个空对象，然后让数据的__proto__继承创建的对象，然后使用数据监控的value在对方法进行重写)。

# 2 创建虚拟dom树(渲染的核心)
根据传入的el，选出标签，分析节点，并且进行行间属性的判断。然后通过new的方式，创建出虚拟dom对象。然后使用递归的方式，创建出虚拟dom树。

# 3 创建模板与虚拟dom的关系(渲染的核心)
根据创建好的虚拟dom树，对内部的节点进行分析，如果使用到了模板，创建两个关系表
一个是节点与模板之间的关系
一个是模板与节点之间的关系

# 4 节点的渲染(实际开始渲染)
对当前节点进行分析，从创建好的节点与模板的关系中，先进行读取，如果读取到了，说明使用到了动态添加数据的方式。读取数据进行innerHTML的替换即可。
并且使用递归的方式分析子节点。
读取数据需要写一个工具方法。
读取数据的位置有两个，一个是data，另一个是私有属性vnode.env(v-for产生的私有数据，比如item)

# 5 重新渲染
使用到创建的模板与节点的关系，如果一个数据发生了变化，如果有节点使用到了该数据，就需要进行重新渲染。
如何查询有哪些节点使用到了该数据。
通过模板与节点的关系进行读取，如果读取到，则读取的节点中都使用了该数据。
只需要遍历读取到的所有节点。
然后依次使用 节点渲染的方法，对该节点进行重新渲染(从新读取数据，这样就是最新的数据)。 这样就会达到重新渲染的效果。

# 6 行间指令v-model的分析
在构建虚拟dom的开头部分进行行间属性的分析。
先读取行间属性，查看有没有使用v-model，如果有。进入一个方法，然后给该标签绑定上input事件，只要一触发该事件，对v-model绑定的数据进行重新修改赋值。
需要写一个赋值的工具方法。

# 7 双向数据绑定
两步: 创建模板与节点之间的关系，渲染节点的时候进行分析
修改数据，可以影响input的value。
分析: 修改数据，会根据模板与节点的关系，找到与该数据有关系的节点。所以要先在创建关系的时候也进行分析，如果行间属性有v-model(并且节点类型是1)，读取出对应的属性值(这就是模板)，进行保存即可。

在重新渲染的时候也需要进行判断，如果渲染函数触发，分析标签节点的行间有没有v-model，如果有把读取到的数据设置到value中。这样就实现了双向数据绑定。

# 8 行间属性v-for的分析(重点，难点)
__循环创建标签__
分为三步：根据数据，创建出对应个数的标签，创建模板与节点的关系，渲染分析。
如果标签的行间有v-for，对它进行分析，首先分析父级标签的nodeType是否为0，如果为零直接退出(表示父级也是一个模板标签，而模板标签是要进行删除的，所以即使解析也没用，直接返回)。

然后在把带有v-for的标签是作为模板标签进行处理，把它变成虚拟dom，并且标签类型设置成0(表示模板标签)，并且分析v-for，把遍历的数组存在虚拟dom对象中，构建关系的时候方便。
然后在父级中进行删除(由于删除存在bag，需要在添加一个文本节点)。删除后父级标签就会变空。

此时在对v-for的属性值进行分析，取出调用的数组，从data和vnode.env中读取出对应的数组数据，然后在循环数组数据，生成对应个数的标签，同时设置新生成的标签的innerHTML与模板的一样。

由于v-for循环可以使用循环产生的数据，比如(item，index)。所以需要设置循环产生的新标签的私有属性。定义一个方法，传入标签，当前标签对应的数组的数据，以及对应的数组的索引，以及解析出来的模板名(比如:item，index)。分析模板有几个，如果两个都有生成一个对象{item: , index: }。然后把对象转成json格式，存放在标签的行间。

创建完标签后，把模板标签的虚拟dom进行返回，这样下次数据变化的时候还可以找到模板标签，重新生成。


__新增标签的虚拟dom的创建__
在创建虚拟dom的时候，分析标签，行间存在v-for，执行上方的方法，生成对应个数的标签，并且可以接收到返回的模板的虚拟dom。由于虚拟dom已经生成，所以下方的创建虚拟dom的方法就不用执行(添加if判断)，并且子节点的递归遍历也不必执行，因为是模板标签，遍历生成虚拟dom也没用。

由于创建好的标签直接插到父级中，此时新生成的标签还没有创建虚拟dom，无法进行vue语法解析渲染。但是会自动执行，由于新生成的标签，和模板标签位于同一级。而此时刚好解析完模板标签，就会解析模板标签的兄弟标签，即新生成的标签。此时产生虚拟dom(和直接写的效果就会一样)。

由于标签的私有属性是存在虚拟dom对象的env属性中，所以需要进行分析，在创建标签的时候，已经把私有属性放在行间了，并且起了一个属性名，分析只需要行间有该属性，就把属性值读取出来，赋给env。并且还需要继承父级节点的env。


__建立关系__
新增的标签的关系无需通过代码构建，因为是直接插入的，就相当于手写。但是v-for的模板节点需要与数组建立一个关系。在建立关系中，判断节点类型是否为0，如果为0，取出之前设置在虚拟dom对象中的模板，直接进行添加即可。


__从新渲染__
如果执行数组的一些方法(重写后的方法，比如push)，v-for就需要重新分析，如果整个数组都进行了替换，触发属性的监听set函数，也需要进行重新渲染，所以就需要判断指向的数据是否为数组。

首先父级删除上次循环创建的所有标签，然后再把模板标签放入父级中，此时一切复原。然后重新执行创建虚拟dom的方法，分析有v-for，会进行重新的遍历创建。

但是分析节点的位置也是有关的，根据模板找到的是v-for的模板标签，但是新创建的标签与模板标签位于同一级，要想新创建的标签进行解析，创建虚拟dom，所以解析的节点要向上一级，找到父级。

由于创建虚拟dom的方法，也会返回一个虚拟dom，之前的虚拟dom不能再继续使用，所以需要进行替换，重新构造虚拟dom树。
由于返回的是模板标签父级节点的虚拟dom，所以要找到该节点的父级中的子级对象，找到之前该节点虚拟dom所处的位置，然后把该位置替换成新的虚拟dom，这样就会构建出一个新的虚拟dom树。

由于之前创建的节点进行了删除，意味着之前创建的节点与模板之间的关系将不能再使用，所以需要整个进行清空，重新开始创建关系表(从头开始创建不会浪费性能)。

返回的新的虚拟dom，表示是已经变化完成的，所以只需要再次执行节点渲染函数(从新的虚拟dom开始分析)。就会自动根据新的关系表，渲染出正常的页面。

# 9 v-bind的实现
v-bind有两种写法(v-bind:，:)。并且它给行间赋值的方式有两种，比如: v-bind:class="a"、或者v-bind:class="{ y: a > 2 }"、或者v-bind:class="{ b + 1 }。
前面一种可以看成是直接从数据库中把a的值取出赋给class。后面带有括号的表示先进行运算，然后在赋值给class。

第一种可以实现数据的监管，第二种由于存在运算，没有什么规矩可言，以现在的知识无法实现监管，只能在初始的时候进行赋值。

__第一种方式的监管和第二种方式的渲染__
可以写在构建关系的方法中，对每一个节点都进行分析，比如定义一个方法，如果有返回值，则进行监管，如果没有返回值说明使用的是第二种方式，直接进行运算赋值。并且返回值是第一种方式对应的模板，这样建立关系比较方便。

首先获取节点的行间属性(只限标签节点)，然后循环遍历，如果属性存在v-bind或者:。进入处理函数。
先判断有没有{}。如果没有直接返回属性值，进行绑定。
如果有{}，直接进行赋值，首先去掉{}，然后按照,进行分割(有多个表达式)。分割完成后，循环执行每一个表达式。

首先先判断有没有:,如果有，表示:后面为真，前面的值为属性值，如果为假，什么也没有。所以要按照:进行拆分。
然后取出第二个(表达式，进行执行)，但是表达式是一个字符串，所以需要构建一个运行环境。进行表达式的运行如果为真把第一个值，通过设置行间属性的方式设置上去(需要把v-bind:或者:去掉，动态添加)。
如果第一个值带引号，表示直接添加，如果不带引号，表示需要重js中获取数据，使用工具方法从data和env中提取数据即可。

如果没有:，表示直接进行运算，返回值添加到行间，通过,号进行分割，获取的直接就是表达式，然后在运行环境中执行，把执行后的值赋给行间就可以了(需要把v-bind:或者:去掉，动态添加)。

构建运算环境，eval可以运行字符串代码。比如let a = 0; eval("let b = 1; if(b === 1) { a = 2}")
经过上方的运算，a为2。
所以需要使用字符串拼接的方式，拼接出一个js代码即可。
由于行间表达式可能需要使用到data和env中的数据，所以需要遍历它们，然后转成JSON格式(字符串)，然后进行拼接。
最后结合表达式，一块传入eval即可

__第一种方式的渲染__
节点渲染的过程中，分析标签节点的行间有没有v-bind:或者:。有的话，取出该行间属性对应的属性值，首先判断有没有{}(有多个v-bind:, 并且其中有第一种和第二种)，如果没有{}, 向data和env中进行读取，读取到了设置到行间即可。(需要把v-bind:或者:去掉，动态添加)

# 10 v-on的实现
首先需要在数据初始化的时候，对methods中的方法进行初始化(读取，放在vm._methods和vm中，以便使用)。

然后分析节点，查看行间的属性中是否包含v-on:或者@。如果包含，返回后面跟着的事件类型，然后进入绑定事件的函数中进行事件的绑定，并且改变this的指向，指向的是Due对象。

在获取属性值的时候，还需要进行分析，有没有()。如果没有正常处理。
如果有()，如今的知识实现不了，所以抛出个错误。

# 周期函数(传入参数对象中的其它属性)
都是在数据初始化的时候，进行处理，把方法添加到vm中，这样这些周期函数就能在指定的地方进行调用，达到周期描述的效果。