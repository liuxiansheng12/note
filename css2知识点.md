
# width属性
1. 该属性设置某个容器的宽度
2. 该属性的属性值的默认值为auto
   1) 块盒的width属性值，等于父级容器的`content`区域的宽度
   2) 行盒和行块盒的width属性值，由内容区撑开

3. 该属性的属性值可以设置为百分数
   1) 依据的是父级容器的`content`区域的宽度
   2) 如果当前是`absolute`定位元素，则百分数依据的是最近有定位的父级的容器宽度
      1) 不是`content`区域的宽度，而是`content、padding、border`三个区域的和
   3) 如果没有有定位的父级，则参考的是body的容器宽度



# height属性
1. 该属性设置某个容器的高度
2. 该属性的属性值的默认值为auto
   1) 默认由内容区撑开

3. 该属性的属性值可以设置为百分数
   1) 依据的是父级容器的`content`区域的高度
   2) 如果当前是`absolute`定位元素，则百分数依据的是最近有定位的父级的容器高度
      1) 不是`content`区域的高度，而是`content、padding、border`三个区域的和
   3) 如果没有有定位的父级，则参考的是body的容器高度
   


# margin属性
1. 设置元素间的间隔
2. 该属性会造成margin-top塌陷和margin-top合并
3. 该属性的属性值，可以设置为百分数
   1) 依据的是父级容器的`content`区域的宽度
   2) 哪怕是top和bottom，依据的也是宽度，而不是高度
   3) 如果当前是`absolute`定位元素，则百分数依据的是最近有定位的父级的容器宽度
      1) 不是`content`区域的高度，而是`content、padding、border`三个区域的和
   4) 如果没有有定位的父级，则参考的是body的容器宽度




# padding属性
1. 该属性的属性值，可以设置为百分数
   1) 依据的是父级容器的`content`区域的宽度
   2) 哪怕是top和bottom，依据的也是宽度，而不是高度
   3) 如果当前是`absolute`定位元素，则百分数依据的是最近有定位的父级的容器宽度
      1) 不是`content`区域的高度，而是`content、padding、border`三个区域的和
   4) 如果没有有定位的父级，则参考的是body的容器宽度

   


# vertical-align属性

1. 该属性设置的是，某一行中文本元素的对应方式
   1) **简单来说，该属性就是使一个文本元素进行上下移动，在上下方向调节其对应的位置**


2. 默认，一行中的文本元素显示在基线的位置显示
   1) 文本元素，(块盒，行块盒也具有文本元素的特性)，自动排成一行
   2) 排成一行，依据的就是基线的位置，基线的位置，为字母X的下方的那条横线
      1) 简单理解就是，基线为: 一行中最低元素的下边界
          1) 由于文字的高度不相同，基线并不等于下边界
      2) **一行中所有元素的底边，与基线重合**
      3) **这样就会造成，一个元素通过margin下移，其它元素也会跟着下移，原因基线下移了**


3. 通过`vertical-align`属性，可以影响文本元素的排列位置(进行上下调节)
   1) 每一行都有一个基线，所有的元素都是按照基线进行排列的
   2) 该属性，可以调节对应元素相对于基线的位置，即上下移动
   3) 对应的属性值以及作用如下
      1) `baseline`，默认值，当前元素位于基线位置
      2) `top`:  顶端对齐，当前元素的上边界与父级容器的上边界重合，不在位于基线位置
         1) `margin-top`依旧有用
      3) `bottom`:  底端对齐，当前元素的下边界与父级容器的下边界重合，不在位于基线位置
         1) `margin-bottom`依旧有用
      3) `text-top`:  文本的顶端对齐
         1) 当前元素的上边界，与上基线重合，即`X`的上边界，并不是元素的上边界
         2) 所以，会表现出，上边界与前面元素的上边界不重合
         3) 其它元素的移动，不会造成上基线的移动，即前一个元素向上向下移动，不影响基线
      4) `middle`:  中部对齐；  
      6) `text-bottom`:    文本的底端对齐；
      7) 百分比和长度:  CSS2，可为负数
         1) 在当前元素的当前位置的基础上进行上下移动，正值向上移动，赋值向下移动
         2) 如果向上移动的范围超出了，即已经到达父级容器的上边界，其它一行中的元素会向下移动
         3) 如果其它元素的属性值设置的是`top`，不会向下移动，还是在父级容器的顶部
         4) 百分比取自当前元素的`height`
   4) 如果一个元素的`vertical-align`的属性值设置的是具体的像素，并且是向上移动的
      1) 如果当前元素已经到达了顶端，无法在往上移动，为了表现出该元素是向上移动的效果
      2) 该行中的其它元素，会进行下移相同像素，以突出该元素向上移动了多少像素
      3) `margin-top`不受影响，虽然在表现形式上没有到达边界，上方有`margin-top`
      4) 其实在原理上已经到达了边界，无法进行向上的移动


    

4. 该属性的特点
   1) 上移存在边界，移动到顶端，当前元素不在上移，本行中的其它元素进行下移
   2) 下移不存在边界，可以一直下移，如果父级容器设置了高度，则移出高度外
      1) 如果没有指定高度，移动高度会增加，由内容区撑开，内容区高度增加，容器的高度就会增加
   3) 如果上一行的文本元素下移，下面的所有元素都会随之下移，上一行下移，会把下面的挤下去




# display: grid属性

1. 形成网格布局
   1) 把容器分成一个一个的盒子
   2) 每一个盒子中，放入一个子元素容器
   3) 每一个盒子都是按个排列的，有专门的属性设置盒子间的间隔
      1) 子元素的margin，无法影响盒子的间隔，而是设置的对应元素在当前盒子中的间隔
      2) 比如: 先把子元素容器放在对应的盒子中，相当于放在对应的房子中
         1) margin影响的是元素在房子中的位置，无法影响房子的位置
   4) 每个盒子的尺寸，也是单独设置的，并不是根据放在内部的元素的尺寸进行自适应的
   5) 如果盒子的高度没有设置，会有当前行中的所有盒子中的最高元素进行决定
      1) 不是由当前盒子的内容区撑开

2. 如果盒子的尺寸是固定的，但是里面的元素的尺寸超出了其范围，不会把其它盒子往边上挤
   1) 表现样式为: 后面盒子中的元素，遮住前面盒子中超出到当前盒子中的部分
   2) 相当于，后面盒子中的层级比前面的高

3. 设置一行有多少个盒子以及盒子的宽度
   1) 如果没有设置，会使用默认值，一行一个盒子，并且盒子的宽度为容器的`content`区域的宽度
   2) 通过`grid-template-columns`属性，可以设置一行有多少个盒子，以及每个盒子的宽度
   3) 使用规则: `grid-template-columns: 100px 100px 200px`
      1) 表示: 容器中一行只有三个盒子，第一个和第二个盒子的宽度为100px，第三个为200px
   4) 可以填写百分数，依据容器的`content`区域的宽度

4. 设置每行盒子的高度
   1) 如果没有设置，该行中的所有盒子的高度，等于该行中最高的元素的高度
   2) 通过`grid-template-rows`属性，可以设置每一行的盒子的高度
   3) 使用规则: `grid-template-rows: 100px 100px 200px`
      1) 表示: 第一行和第二行盒子的高度为100px，第三个为200px
      2) 如果存在其它行，则等于该行中最高元素的高度
   4) 可以填写百分数，依据容器的`content`区域的高度
   


5. 设置盒子间的间隔
   1) `grid-column-gap: 10px;`
      1) 表示每个盒子间的横向间隔为10px
   2) `grid-row-gap: 10px;`
      1) 表示每个盒子间的纵向间隔为10px
   3) `grid-gap: 10px 10px`
      1) 表示每个盒子间的横向间隔为10px，纵向也为10px
      2) 如果只写一个值，表示两个值相同
   4) 根据最新标准，上面三个属性名的`grid-`前缀已经删除
      1) `grid-column-gap`和`grid-row-gap`写成`column-gap`和`row-gap`
      2) `grid-gap`写成`gap`。


6. 行分块的简化操作
   1) `grid-template-columns: repeat(8, 100px)`;
      1) 意思: 一行分八块，每块宽为100px
   2) `grid-template-columns: repeat(8, 10px 20px 30px)`;
      1) 意思: 一行分24块，三个一组，第一个为10px，第二个为20px，第三个为30px


7. 行分块自适应容器的尺寸
   1) 行分块需要指定，每一块的宽度
   2) 行分块自适应容器的尺寸，每会尽可能的多容纳块
   3) `grid-template-columns: repeat(auto-fill, 100px);`
      1) 意思: 如果行宽为550px，每一行会自动划分出5块，如果是400px，每一行为4块
      2) 尽可能的多容纳


8. 行分块，块的宽度自适应容器的尺寸(按照比例进行划分)
   1) 把容器的`content`区域的宽度分成几份，每一个盒子占多少份
   2) `grid-template-columns: 1fr 1fr 1fr 2fr;`
      1) 意思: 共有5个fr，把容器的`content`区域的宽度分成5份
      2) 每一个盒子的宽度，占对应的份数
   3) `grid-template-columns: 150px 1fr 2fr;`
      1) 意思: 第一列的宽度为150px，剩余的空间分成三份
      2) 每一个盒子的宽度，占对应的份数


9. 给盒子加一个长度范围
   1) 比如: `grid-template-columns: 100px 100px minmax(100px, 200px);`
      1) 意思: 前两个盒子的宽为100px，最后一个盒子最大尺寸为200px，最小尺寸为100px
      2) 当容器的content区域的宽度大于300px，小于400px，最后一列盒子的宽度自适应
      3) 当宽度大于400px，最后一列盒子的宽度达到最大值200px，不会在往上增加
      4) 当宽度小于300px，最后一列盒子的宽度达到最小值100px，不会在向下减少
   2) minmax方法设置的范围，会进行平分
      1) 比如: `grid-template-columns: 100px minmax(100px, 200px) minmax(100px, 200px);`
      2) 容器的content区域的宽度为420px，第一个占满100px后，还剩320px
      3) 即第二个和第三个的宽度都为160px
      4) 有特殊情况，不会进行平分
         1) 比如: `grid-template-columns: repeat(auto-fill, minmax(100px, 200px))`
         2) 虽然该属性，会让一行尽可能多的多显示，但是不会进行100~200的平分，
         3) 表现形式为: 
            1) 只要容器的content区域超过了200px
            2) 并不会一行有两个盒子，然后两个盒子平分
            3) 而是只有一个盒子，盒子的长度为200px
            4) 即只有容器的content区域的宽度小于最大值，一行容纳一个盒子
            5) 然后盒子的宽度才会，取中间值，即自适应
            6) 只要content区域的宽度大于最大值，则盒子的宽度就会固定在最大值
            7) 剩余宽度不够最大值，则盒子的位置另起一行，即不会进行平均分配
      5) 指定了个数是会进行平均分配的
         1) 比如: `grid-template-columns: repeat(3, minmax(100px, 200px))`
         2) 表现形式为: 三个盒子的宽度相同，如果content区域的宽度小于600px;
         3) 并不会，前两个盒子的宽度为200px，第三个盒子的宽度为剩下的
         4) 而是会进行平分，即三个盒子的宽度永远相同
         5) 这种写法就相当于: 
            1) `grid-template-columns: minmax(100px, 200px) minmax(100px, 200px), minmax(100px, 200px)`


10. 与`fr`功能相似的`auto`
    1) `fr`，把content区域的剩余宽度分成几份，然后每个盒子占对应的份数，即盒子尺寸进行自适应
    2) `auto`，也是盒子的尺寸进行自适应，比例是一个特殊的比例，`1:1:1`等等
       1) 不像`fr`可以调节比例，可以变成1:2:1
    3) 表现形式为: 有几个auto，就把剩余空间分成几份，每个auto个占一份
       1) 比如: `grid-template-columns: 100px auto 100px auto;`
       2) 如果容器的宽度为340px，去除200px，还剩140px，分成两份，每份为70px
       3) 这样每列的宽度分别为: 100px、70px、100px、70px;
       4) 与: `grid-template-columns: 100px 3fr 100px 3fr;`
       5) 或者: `grid-template-columns: 100px 1fr 100px 1fr;`的效果一样
       6) 只要比例满足1:1即可


11. 填充顺序
    1) 分好盒子后，就开始把子元素依次放入盒子的区域，默认是一行一行的填充
    2) 使用`grid-auto-flow: column;`可以改变这种填充规则
    3) 变成了一列一列的填充
       1) 即先填充完第一列，在填充第二列，即第二个子元素，不在放在一行二列的位置
       2) 而是放在二行一列的位置，即一列二行的位置，先填充一列


12. 设置每个盒子中元素的位置(对齐方式)
    1) `justify-items` 属性，设置单元格内容的水平位置(左中右)
    2) `align-items` 属性，设置单元格内容的垂直位置(上中下)
    3) `place-items` 属性，上面两个属性的混合写法
       1) 第一个属性值代表: `align-items`
       2) 第二个属性值代表: `justify-items`
       3) 如果只写一个，则表示两个属性值相同
       4) 比如: `place-items: start center`
    4) 两个属性的属性值，是相同的
       1) `start`: 对齐单元格的起始边缘。
       2) `end`: 对齐单元格的结束边缘。
       3) `center`: 单元格内部居中。
       4) `stretch`: 拉伸，占满单元格的整个宽度(默认值)


13. 放入对应盒子中的元素，没有定义尺寸，则元素的尺寸就会进行自适应
    1) 宽和高等于，对应的grid盒子的宽和高
    2) 哪怕元素是块级元素，没有设置尺寸，宽和高依旧会进行自适应
    3) 就是`justify-items`和`align-items`属性的默认值，起的作用，占满单元格的尺寸
       1) 所表现的效果就是: 宽和高等于，对应的grid盒子的宽和高
       2) 如果对应属性改成其它的值，比如: `justify-items`的属性值改成`center`
          1) 如果没有设置宽度，则宽度不在进行自适应，而是有内容区撑开
          2) 即使是块级元素，宽度依旧有内容区撑开
          3) 高度依旧自适应，没有操作高度
          4) 如果元素由内容区撑开的宽度小于盒子的宽度，则在`center`的作用下
          5) 横向就进行居中
          6) 操作`align-items`属性，表现形式相同


