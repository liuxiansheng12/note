
# Deferred回调

1. 构建回调环境
   1) 借助`Deferred`构建回调环境
   2) 具体代码: `const df = $.Deferred()`


2. 往回调中添加方法(done、fail、progress)
   1) `done`: 注册成功回调函数
   2) `fail`: 注册失败回调函数
   3) `progress`: 注册正在进行时回调函数

3. 注册回调函数的链式调用
   1) 上面的三个注册回调函数的方法，都返回回调环境对象，所以可以实现链式调用
   2) 可以传递一个函数，多次调用，绑定多个方法
   3) 可以传递多个函数，一次调用，绑定多个方法
   4) 比如: `df.done().fail().done().progress().fail()`

4. 回调函数的触发
   1) `df.resolve(3)`: 触发注册的所有的成功状态的回调函数
   2) `df.reject(4)`: 触发注册的所有的失败状态的回调函数
   3) `df.notify(5)`: 触发注册的所有的正在进行时状态的回调函数              
   4) **注意点**       
      1) 只要是成功或者失败状态一经触发，则所有的回调函数(成功、失败、正在进行时)都会销毁
      2) 即后面，在触发相应状态的回调函数，没有效果
         1) 比如: 触发了成功状态，又触发了失败状态，则失败状态对应的回调函数不会执行
      3) 触发正在进行时状态，不会清空函数，依旧可以触发其他状态的回调函数
   5) 传参: 传入对应的所有的回调函数中，即执行的回调函数接收的参数是相同的
      1) **触发所有的注册的对应的方法**


5. `then`的使用
   1) 简化了不同状态对应的回调函数的注册方式
   2) 通过一个then，就可以注册三个状态的回调函数
      1) 底层借助的还是上面的三个方法
      2) 第一个参数，对应成功回调函数
      3) 第二个参数，对应失败回调函数
      4) 第三个参数，对应正在进行时回调函数
   3) 并且`then`也返回回调环境对象，即也可以实现链式调用
   4) **注意点**
      1) 虽然`then`返回的也是一个回调环境对象，但是返回的是一个新创建的回调环境对象
      2) 下一个`then`绑定的回调函数(链式调用)，与之前的回调环境没有关系
      3) 新创建的回调环境上注册的方法，触发的条件
         1) 前一个环境中执行的状态函数的返回值，为普通值
            1) 链式调用，前一个环境中执行的状态函数没有发生运行错误，就会触发成功状态
            2) 链式调用，前一个环境中执行的状态函数发生了运行错误，就会触发失败状态
            3) 只要正常运行，就会一直沿着then链，执行注册的回调方法
            4) **造成，第一个环境触发成功状态，then上绑定的所有成功状态回调函数都会执行**
            5) 仿佛，所有的then上绑定的回调函数，都绑定在了开始的环境上(同一个环境上)
         2) 前一个环境中执行的状态函数的返回值，为`Deferred`环境对象
            1) then中注册的方法，不在受前一个环境中执行的状态函数是否发生错误，所控制
            2) 而是由前一个环境中，执行的状态函数，返回的`Deferred`环境对象所控制
               1) 即，返回的`Deferred`环境，什么时候触发对应的状态
               2) `then`返回的环境，就会触发对应的状态，执行对应的回调函数
               3) 然后，继续后面`then`返回的环境的，状态的变化处理
               4) 前一个`then`返回的环境的状态，没有触发，后面的then绑定的函数是不会执行的
               5) 后面的环境，由前一个环境控制


