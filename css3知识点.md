# 学习CSS3的原因

1. 功能更加强大

2. 可以实现动画效果
   1) 如果是采用的css2，想要实现动画的效果，必须借助js才能完成

3. 另外css3还可以实现立体的效果

4. **实现动画和立体，也是我们学习css3的根本原因**







# css3学习前的知识扩展

## css3的诞生
css3就是css2的一个升级版本，但是在css3诞生的时候肯定有一个权威的标准。什么是权威标准，简单来说就是一个公司，先把css研制成功。然后把它的一些使用方法与函数发给各大浏览器公司，然后告诉他们，我们研发了一个css3，刚才发给你的就是它的使用规则。你们的浏览器用不用，如果用就得按照我写的规范来。所以权威标准也就是css3的用法，你要使用css3就得按照别人定义的规范来。




## css3前缀的由来
Css3的权威公司定义了css3的用法以及功能，然后告诉各大浏览器公司你们按照我定义的标准来实现吧。然后各大浏览器公司一看，这个css3实现的效果还不错，于是就都开始往自己家的浏览器中添加css3的功能，也就是升级浏览器。
但是吧，在各大浏览器升级的过程中就产生了一个问题，那就是有的浏览器公司比较强大，然后它就升级的比较快。有的公司比较弱小，然后他就升级的比较慢。
我们取一个css3中的一个属性来概括一下。就比如: border-radius加圆角。然后各大浏览器开始升级的过程中。
有一天google/safari率先升级完成，在它们的浏览器上就可以使用css3的属性，但是其他浏览器还在升级过程中。google/safari一看，哎就我实现了。为了区分google/safari就给css3的属性加了一个前缀为:-webkit-，也就是直接写border-radius不管用了，必须写成-webkit-border-radius，加上前缀才好使。
又有一天IE也完成了升级，他一看我是第二个完成的，为了区分它也定义了一个前缀，为-ms-。这样在IE中加圆角就要写成-ms-border-radius才好用。

firefox也实现了，他也定义了一个前缀为-o-。

opera也实现了，他也定义了一个前缀为-moz-。

在随着其它的浏览器的继续升级，然后就产生了很多的前缀。这样就造成了，你在我浏览器上设置css3上的一些属性，必须要加上我定义的前缀，否则不好使。这样就造成了，代码写起来有些麻烦。




## css3前缀的取消
还是以border-radius为例。
然后又随着浏览器的继续升级，市面上的大多数浏览器都实现了css3的引入。然后那些浏览器一看，好家伙，border-radius都能用了，那它就不是自己什么私有的属性了，因为大家都实现了。然后浏览器一看好吧既然大家都实现了，那我在升级一次，就把前缀取消了，也就是直接写border-radius也能用了，但是之前他们的各自的前缀写法也没失效，依然可以使用。
这样随着各大浏览器的继续升级，border-radius都能直接使用了。也就是每个浏览器都支持两种写法了，加前缀和不加前缀。不加前缀的写法，就保持了css3的干净性。所以发展到今天，几乎所有的浏览器都支持这种干净的写法了。




## 各大浏览器升级css3过程中的问题
我们都了解一个css中有很多属性，css3中也有很多属性，并且浏览器在升级过程中。开始阶段为了显示私有性，各家浏览器都定义了一个前缀。然后随着各大浏览器的继续升级，前缀逐渐取消，支持干净的写法。但是在取消前缀的过程中，并不是把整个css3中所以属性的前缀都取消了，他们是一部分一部分的取消。也就是这次升级的版本把css3中的一些属性的前缀取消，然后下次升级在取消下一部分。
但是由于浏览器升级的快慢，这就造成了一个什么问题，那就是一家浏览器已经支持css3中的某些属性干净式的写法，但是其他浏览器的这些css3属性可能还没有升级完，操作的过程中还必须加上前缀才能使用。
这样就造成了一个css3属性要想兼容全部的浏览器，就必须写很多次，还是以border-radius。要想使一个页面的border-radius在各大浏览器上都好用，就必须写成下面类似的格式，代码如下:
{
    -webkit-border-radius: 50%;
    -o-border-radius: 50%;
    border-radius: 50%;
}
这样写的原因就是，由于各大浏览器的升级速度不同，然后有些浏览器支持border-radius的干净写法，有些浏览器还必须加上前缀才能用，但是又由于每个公司的前缀不同，所以要都设置上。直到今天，有些属性浏览器还必须写成带前缀的样式，但是大部分属性所有浏览器都已经支持干净式的写法了。那些必须带前缀写法的属性也不是由于浏览器发展迟缓造成的，也有可能是这个属性只有该浏览器支持，所以设置时要加上前缀，比如: -webkit-text-fill-color属性，只有webkit内核支持，所以使用时必须要加上前缀。






## 查询某个属性还需要加前缀的网址文档
reference manual website: http://css.doyoe.com
Authoritative inquiry website : http://www.caniuse.com









 
# css3新增的选择器

## 关系型选择器模式

1. 介绍
   1) 这种选择器并不是一种新的类型，它只是一种新的模式
   2) 那什么是选择器的模式，比如: 我们之前接触过的
      1) 父子选择器(`div span`)，对应的模式为: `E F`
      2) 直接子元素选择器(`div > span`)，对应的模式为: `E > F`
      3) 除了上面的两个模式，其实还有两个模式
         1) 分别为`E + F`、`E ~ F`
      4) 模式中的`E、F`代表的为选择器


2. E + F模式的选择器
   1) 作用
      1) 选中某标签下面的第一个、并且满足条件的**兄弟元素节点**
   2) 比如 
      1) 有这样一个结构: `<div></div> <p></p> <p></p>`
      2) `div + p { }`，选中的就是`div`下面第一个`p`标签
   3) 注意点
    1) `E + F`模式只能匹配到下方第一个兄弟标签
    2) 然后验证一下是不是满足条件(比如看看是不是p标签)。如果不是就不会向下匹配
    3) 比如: `<div></div> <span></span> <p></p>`这样一个结构
    4) 如果使用`div + p`是选不出p标签的



3. `E ~ F`模式的选择器
   1) 作用
      1) 选中某标签下面的所有的满足条件的**兄弟元素节点**
   2) 比如 
      1) 有这样一个结构: `<div></div> <span></span> <p></p> <span></span> <p></p>`
      2) `div ~ p { }`，选中的就是`div`下面所有的`p`标签，不受`span`标签的影响
   





## 属性选择器

1. `[data ~= "a"]`
   1) 标签的行间存在`data属性`，并且data属性值中含有`a`子字符串，都会被选中
      1) `a`不能与其它字符串连用，必须是单个的，即以`空格`隔开
   2) 比如: `<div data="a"></div> <div data="b a"></div>`

2. `[data |= "ab"]`
   1) 标签的行间存在`data属性`，并且data属性值为`ab`或者以`ab-`开头字符串，都会被选中
   2) 比如: `<div data="ab"></div> <div data="ab-c"></div>`

3. `[data ^= "ab"]`
   1) 标签的行间存在`data属性`，并且data属性值为`ab`或者以`ab`开头字符串，都会被选中
   2) 比如: `<div data="ab"></div> <div data="abc"></div>` 

4. `[data $= "ab"]`
   1) 标签的行间存在`data属性`，并且data属性值为`ab`或者以`ab`结尾字符串，都会被选中
   2) 比如: `<div data="ab"></div> <div data="cab"></div>` 


5. `[data *= "ab"]`
   1) 标签的行间存在`data属性`，并且data属性值为`ab`或者含有`ab`的字符串，都会被选中
   2) 比如: `<div data="ab"></div> <div data="cdab c"></div>` 





## 伪元素选择器


1. `::placeholder`
   1) 这个伪元素选择器，必须写两个冒号
   2) 并且这个伪元素只有input标签上有
   3) 作用
      1) 选中带有`placeholder`属性的input标签
      2) `placeholder`属性的作用
         1) 提示文字
         2) 当输入框中什么内容信息都没有的情况下，这个文字信息显示
         3) 不管鼠标聚没聚焦
      3) **这个伪元素选择器只有一个作用，就是改变`input`标签中`placeholder`的文字颜色**
   4) 比如: `input::placeholder{ color: #f40 }`
   5) 并且使用这个方法的时候，要考虑到兼容性的问题
      1) 可能有的浏览器需要加上前缀
      2) 比如: `input::-moz-placeholder{ color: #f40 }`



2. `::selection` 
   1) 作用
      1) 设置选中文字的样式
      2) 即进行复制文字时，用鼠标选中的文字的样式
      3) 默认是: 背景变成蓝色，文字颜色不变
   2) 该伪元素选择器也必须书写两个冒号
   3) 该选择器中只能设置三个属性，即: `color`、`background-color`、`text-shadow`
      1) 其它样式设置上也没用
   4) 比如: `.a::selection{ color: #f40 }`
      1) 当选中.a元素下的文字时，文字颜色变成淘宝红
      2) 选中其它元素下的文字时，还是使用默认样式







## 伪类选择器


1. 作用
   1) 先选中一堆符合条件的元素
   2) 然后在对选出的元素进行筛选
   3) 取出符合条件的元素，设置其样式


2. `:not()`
   1) 选出除什么之外的元素
   2) 比如: `div:not(.b)`
      1) 选出所有的div元素，然后去除`class为b`的元素，取剩下的元素设置样式



3. `:root`
   1) 选中当前脚本的根标签，即`html`或者`xml`标签
   2) 比如: 在css文件中，写`:root { ? }`，就相当于`html { ? }`
      1) 选中html标签对其设置样式
   3) 如果在xml项目中，`:root { ? }`，就相当于`xml { ? }`
   4) `:root {}`选中的范围比`html {}`广泛
      1) 所以: `:root {}` 不等于 `html {}`
   5) 加限制条件
      1) 比如: `html:root {}`，则只能在html中使用，也就相当于`html {}`
      2) 这样操作，不如直接书写`html {}`，纯属多此一举
      3) 所以，通常`:root`直接书写，不加任何条件



4. `:target`
   1) **选中被锚点标记的标签**
   2) 锚点介绍
      1) 标签都有id，id除了作为选择器，还可以作为锚点标记
      2) 当网址的锚点，与某标签的id对应起来，滚动条就会滚动到对应id的节点位置
      3) 锚点可以手动修改，也可以通过a标签进行修改
      4) 由于锚点切换，不会刷新页面，所以通常用于单页面开发
   3) 当锚点与对应标签的id对应起来，然后在结合当前伪类选择器，当前节点就会被选中
      1) 锚点不匹配的节点，是不会被选中的
      2) 通过该方法，可以设置与锚点，对应起来的节点的样式
      3) 比如: `div:target{ color: #f40; }`
         1) 选中所有的div，当某个div符合锚点，则对应节点的字体颜色就会变成淘宝红
         2) 其它div的文字颜色正常，当锚点切换到其它，选中的节点就不符合锚点
         3) 选中的节点，取消选中，文字颜色恢复正常
         4) 某个节点的文字颜色，受锚点的控制
   4) 该伪类选择器，可以与`:not()`配合使用
      1) 选中除符合锚点的元素的，其它元素
      2) 比如: `div:not( :target ){ display: none; }`
         1) 隐藏，不符合当前锚点的，所有div元素
         2) 只显示，符合当前锚点的元素
         3) 不用js，实现动态显示某些元素


5. `:first-child`
   1) 选中，某个节点下面的第一个子节点
   2) 如果当前伪类选择器的前面，存在其他选择器
      1) 查看某个节点下面的第一个子节点，是否可以被前面的选择器选中
      2) 如果可以选中，则才会选中第一个节点，如果不可以选中，则不会选中
   3) 如果想要选中，某节点下面除第一个节点之外的，所有子节点(一级子节点)
      1) 可以使用`:not()`
      2) 比如: `.demo:not( :first-child )`
         1) 查看某节点，下面的第一个子节点是否为`.demo`
         2) 如果符合条件，选择器起作用，选出所有的，除第一个节点的`.demo`子节点
   4) 代码分析
   ```html
   <div class="a"> 
       <div class="dome">1</div>
       <div class="dome">2</div>
       <div class="dome">3</div>
   </div>
   <div class="b"> 
       <div class="c"></div>
       <div class="dome">1</div>
       <div class="dome">2</div>
       <div class="dome">3</div>
   </div>
   <!-- :first-child，会选中a下面的第一个demo元素，b下面的第一个c元素，前面没有选择器限制 -->
   <!-- .dome:first-child，只会选中a下面的第一个demo元素，b下面的第一个元素不符合条件 -->
   ```




6. `:last-child`
   1) 选中，某个节点下面的最后一个子节点
   2) 如果当前伪类选择器的前面，存在其他选择器
      1) 查看某个节点下面的最后一个子节点，是否可以被前面的选择器选中
      2) 如果可以选中，则才会选中最后一个节点，如果不可以选中，则不会选中
   3) 如果想要选中，某节点下面除最后一个节点之外的，所有子节点(一级子节点)
      1) 可以使用`:not()`
      2) 比如: `.demo:not( :last-child )`
         1) 查看某节点，下面的最后一个子节点是否为`.demo`
         2) 如果符合条件，选择器起作用，选出所有的，除最后一个节点的`.demo`子节点
   4) 代码分析
   ```html
   <div class="a"> 
       <div class="dome">1</div>
       <div class="dome">2</div>
       <div class="dome">3</div>
   </div>
   <div class="b"> 
       <div class="dome">1</div>
       <div class="dome">2</div>
       <div class="dome">3</div>
       <div class="c"></div>
   </div>
   <!-- :last-child，会选中a下面的最后一个demo元素，b下面的最后一个c元素 -->
   <!-- .dome:last-child，只会选中a下面的最后一个demo元素，b下面的最后一个元素不符合条件 -->
   ```



7. `:only-child`
   1) 选中，某个节点下面的子节点，并且只有一个子节点
      1) 如果有两个或者多个，是不会被选中的
   2) 如果当前伪类选择器的前面，存在其他选择器
      1) 查看某个节点下面的唯一子节点，是否可以被前面的选择器选中
      2) 如果可以选中，则才会选中唯一子节点，如果不可以选中，则不会选中
   3) 代码分析
   ```html
   <div class="a"> 
       <div class="dome">1</div>
   </div>
   <div class="b"> 
       <div class="dome">1</div>
       <div class="dome">2</div>
   </div>
   <!-- .dome:only-child，只会选中a下面的唯一demo元素，b下面子元素过多，不会被选中 -->
   ```



8. `:nth-child()`
   1) 正着查选中指定位置的一组标签，**所有的兄弟标签为一组标签**
   2) 比如: `:nth-child(1)`，选中一组标签中的第一个标签
   3) 比如: `.demo:nth-child(1)`，选中一组标签中的第一个，并且为.demo的元素
   4) 比如: `.demo:nth-child(n+1)`
      1) n会递增，查看一组标签，对应位置的标签，如果为.demo，就选中
      2) 如果不是，n继续增加，直到超出一组标签的范围
   

9. `:nth-of-type()`
   1) 正着查选中指定位置的一组标签
   2) 比如: `:nth-of-type(1)`，选中一组标签中的第一个标签
   3) 比如: `.demo:nth-of-type(1)`，选中一组标签中的第一个，并且为.demo的元素
   4) 比如: `.demo:nth-of-type(n+1)`
      1) n会递增，查看一组标签，对应位置的标签，如果为.demo，就选中
      2) 如果不是，n继续增加，直到超出一组标签的范围
   5) 根据伪类选择器，前面的其它选择器进行分组
      1) 比如: `:nth-of-type`，前面没有选择器，则单个元素为一组
      2) 比如: `p:nth-of-type`，所有，元素为p元素的兄弟元素节点，为一组
   6) 与`:nth-child`的不同之处，在于分组的方式上
   7) 代码分析
   ```html
   <div class="dome">
       <span>2</span>
       <p>2</p>
       <p>2</p>
   </div>
   <!-- p:nth-of-type(1)，两个p为一组，选中第一个p元素 -->
   <!-- :nth-of-type(1)，每个元素为一组，现象为选中所有的元素，一组只有一个元素 -->
   ```


10. `:nth-last-child()`
    1) 倒着查选中指定位置的一组标签
    2) 比如: `:nth-last-child(1)`，选中一组标签中的最后一个标签
    3) 比如: `.demo:nth-last-child(1)`，选中一组标签中的最后一个，并且为.demo的元素
    4) 比如: `.demo:nth-last-child(n+1)`
       1) n会递增，查看一组标签，对应位置的标签，如果为.demo，就选中
       2) 如果不是，n继续增加，直到超出一组标签的范围
       3) 倒着查询
    5) 根据伪类选择器，前面的其它选择器进行分组
       1) 比如: `:nth-last-child`，前面没有选择器，则单个元素为一组
       2) 比如: `p:nth-last-child`，所有，元素为p元素的兄弟元素节点，为一组
    6) 代码分析
    ```html
    <div class="dome">
        <span>2</span>
        <p>2</p>
        <p>2</p>
    </div>
    <!-- p:nth-last-child(1)，两个p为一组，选中最后一个p元素 -->
    <!-- :nth-last-child(1)，每个元素为一组，现象为选中所有的元素，一组只有一个元素 -->
    ```



11. `:first-of-type`
    1) 选中一组标签中的第一个标签
    2) 根据伪类选择器，前面的其它选择器进行分组
       1) 比如: `:first-of-type`，前面没有选择器，则单个元素为一组
       2) 比如: `p:first-of-type`，所有，元素为p元素的兄弟元素节点，为一组
    3) 代码分析
    ```html
    <div class="dome">
        <span>2</span>
        <p>2</p>
        <p>2</p>
    </div>
    <!-- p:first-of-type，两个p元素为一组，选中第一个p元素 -->
    <!-- :first-of-type，每个元素为一组，现象为选中所有的元素，一组只有一个元素 -->
    ```



12. `:last-of-type`
    1) 选中一组标签中的最后一个标签
    2) 根据伪类选择器，前面的其它选择器进行分组
       1) 比如: `:last-of-type`，前面没有选择器，则单个元素为一组
       2) 比如: `p:last-of-type`，所有，元素为p元素的兄弟元素节点，为一组
    3) 代码分析
    ```html
    <div class="dome">
        <span>2</span>
        <p>2</p>
        <p>2</p>
    </div>
    <!-- p:last-of-type，两个p元素为一组，选中最后一个p元素 -->
    <!-- :last-of-type，每个元素为一组，现象为选中所有的元素，一组只有一个元素 -->
    ```




13. `:only-of-type`
    1) 选中一组标签，并且这一组标签中只有一个元素，就会选中该元素
    2) 比如: `p:only-of-type`，按照p分组，如果p分组中只有一个p元素，就会选中该元素
       1) 如果p分组中，有多个p元素，则不会选中
    3) 根据伪类选择器，前面的其它选择器进行分组
       1) 比如: `:only-of-type`，前面没有选择器，则单个元素为一组
          1) 正好符合该伪类选择器的选择条件，会选中所有元素
       2) 比如: `p:only-of-type`，所有，元素为p元素的兄弟元素节点，为一组






14. `:empty`
    1) 一组标签中，选出子节点只包含注释或者没有子节点的标签。哪怕有一个空格也不可以
    2) 分组规则
       1) 所有的兄弟元素节点
    3) 代码分析
    ```html
    <div>
        <div><!--123--></div>
        <div>12</div>
        <div> </div>
        <div></div>
        <!-- div:empty，只会选中第一个和第四个元素节点 -->
    </div>
    ```



15. `:checked`
    1) 只能作用于单选框和复选框，当处于勾选状态时，则选中对应的input元素设置样式
    2) 代码分析
    ```html
    <input type="checkbox">
    <span></span>

    <style>
        /* 当input被勾选上后，input:checked生效
           然后查看当前input下的第一个兄弟元素节点是否为span
           如果是，选中其伪元素after设置样式

           当勾选取消后，对应的input:checked失效，则后面的选择器不再进行判断
           样式取消
        */
        input:checked + span::after{
            content: "haha"
        }
    </style>
    ```




16. `:disabled`
    1) 选中带有`disabled`属性的`input`标签，设置其样式
    2) `disabled`作用为: 禁止输入
    3) 使用案例
       1) 可以利用该属性加上`:hover`做一个
       2) 禁止输入的输入框，在鼠标移入的时候改变鼠标样式
       3) 变成专门的禁止输入的鼠标样式，用于提醒


17. `:read-only`
    1) 选中带有`readonly`属性的`input`标签，设置其样式
    2) `readonly`作用为: 禁止使用，即禁止输入
    3) 使用案例
       1) 可以利用该属性加上`:hover`做一个
       2) 禁止输入的输入框，在鼠标移入的时候改变鼠标样式
       3) 变成专门的禁止输入的鼠标样式，用于提醒



18. `:read-write`
    1) 选中带有`readwrite`属性的`input`标签，设置其样式
    2) `readwrite`的作用为: 当前input标签，可以正常使用








# 圆角弧度

1. 一次操作4个角(混合属性)
   1) `border-radius: 10px;`  四个角的弧度都是10px;
   2) `border-radius: 10px 20px;`  左上、右下10px，右上、左下20px
   3) `border-radius: 10px 20px 30px;`左上10px，右上、左下20px，右下30px
   4) `border-radius: 10px 20px 30px 40px;`左上10px，右上20px，右下30px，左下40px


2. 一次操作一个角
   1) `border-top-left-radius: 10px;`   只设置左上角的弧度为10px
   2) `border-top-right-radius: 10px;`   只设置右上角的弧度为10px
   3) `border-bottom-right-radius: 10px;`   只设置右下角的弧度为10px
   4) `border-bottom-left-radius: 10px;`   只设置左下角的弧度为10px

3. 一次操作一个角的上下弧度
   1) 弧度都是从上到下或者从下到上的拐弯，形成弧度
   2) `border-top-left-radius`: 10px 20px;   
   3) `border-top-right-radius`: 10px 20px;   
   4) `border-bottom-right-radius`: 10px 20px;   
   5) `border-bottom-left-radius`: 10px 20px;

4. 设置弧度的原理
   1) 一个弧度，分为两个值，其它简写的方式，两个值是相同的
   2) 首先画一个圆或者椭圆，椭圆的情况是两个值不同
   3) 然后圆，与对应的角进行相切
   4) 两条切线(即元素的两条边)中间的弧度，就是设置的弧度
   5) 圆的构建规则
      1) 第一个值，为横向半径，第二个值为纵向半径，然后形成圆
      2) 如果两个值不同，即横向、纵向的半径不同，就会形成椭圆



5. 把一个元素做成圆
   1) 即两条切线中间的弧度，为四分之一的圆，这样四个角一拼接，就构成了圆
   2) 只有一种圆，可以形成这种现象
   3) 即，横向半径和纵向半径，等于元素尺寸的一半
   4) 比如: `border-radius: 50%`






# 背景色

1. 通过`box-shadow`添加阴影

2. 加外阴影
   1) 方式: `box-shadow: 横向偏移 纵向偏移 阴影的模糊程度 阴影的扩散量 阴影颜色`
   2) 横向偏移量: 可正可负，单位px
   3) 纵向偏移量: 可正可负，单位px 
   4) 阴影的模糊程度: 单位px，设置的是四周同时模糊
      1) 模糊规律，以四周为对称轴，同时向外和向内进行模糊，是对称关系
   5) 阴影的扩散量: 在原始阴影的尺寸的基础上，在加上设置的扩散量，为阴影的最终尺寸
      1) 并且是四周同时加，单位为px
   6) 通常横、纵向偏移量设置为0，依靠阴影的模糊程度，给某个容器添加一个四周都有阴影的外阴影



3. 内阴影
   1) 方式: `box-shadow: inset 横向偏移 纵向偏移 阴影的模糊程度 阴影的扩散量 阴影颜色`
      1) `inset`为关键字，表示设置的是内阴影，也可以写在最后面
   2) 横向偏移量: 可正可负，单位px
      1) 正值: 从左向里偏移
      2) 负值: 从右向里偏移
      3) 如果移动的尺寸大于容器的width，则没有效果
   3) 纵向偏移量: 可正可负，单位px 
      1) 正值: 从上向里偏移
      2) 负值: 从下向里偏移
      3) 如果移动的尺寸大于容器的height，则没有效果
   4) 阴影的模糊程度: 单位px，设置的是两个边同时模糊
      1) 模糊规律，以两个边为对称轴，同时向外和向内进行模糊，是对称关系
      2) 内阴影最多只能显示两条边
   5) 阴影的扩散量: 在原始阴影的尺寸的基础上，在加上设置的扩散量，为阴影的最终尺寸
      1) 并且是两条边同时加，单位为px
      2) 内阴影最多只能显示两条边



4. 加内外阴影的连续调用
   1) 方式: `box-shadow: inset 5px 6px 3px 0px #f40, 3px 4px 5px 6px #fff`
      1) 多个阴影中间用逗号隔开
   2) 后面的阴影会覆盖前面的阴影，即后面添加的阴影，在之前添加的阴影的上面
      1) 并且覆盖之后，颜色会相应的发生变化，相同颜色会加深






# 给边框设置背景图片

1. 填充规律
   1) 边框填充背景图片，并不是简单的把图片放入边框中
   2) **会把图片按照一定的规律进行切割，然后在进行填充**
   3) 切割分为: 边框切割、图片切割。
      1) 然后切割出的图片，对应放入边框切割的位置，进行图片的填充


2. 切割填充的原理
   1) 切割图解
   ```js
   /**
         边框切割            图片切割
       _____________      _____________
      |_1_|__2__|_3_|    |_1_|__2__|_3_|
      |_8_|__9__|_4_|    |_8_|__9__|_4_|
      |_7_|__6__|_5_|    |_7_|__6__|_5_|
   */
   ```
   2) 切割分析
      1) 无论是切割边框，还是切割图片，都是横向切两刀，纵向切两刀
      2) 然后按照，对应的编号顺序依次，把对应的图片放入到指定的边框位置中
      3) 并且切割出的图片，大小会自适应边框对应位置的尺寸，然后在进行放入
      4) 其中，边框切割的四刀，位置已经固定，根据内容区的尺寸，进行切割
         1) 第9块，就是内容区，并且第9块是不进行填充的，即引入图片的中间部分没有用
         2) 沿着内容区的四周，切四刀，边框的切割就算完成
      5) 将要填充的图片的四刀位置，需要手动设置


3. 填充图片，四刀位置的设置
   1) 引入填充图片: `border-image-source: url(图片路径);`
   2) 设置四刀的位置: `border-image-slice: 50 50 50 50;`
      1) 可以进行简写，表示四个值相同: `border-image-slice: 50;`
      2) 切割时，是按照图片像素进行切割的，但是四个值均不能设置`px`
      3) 这四个值，设置的就是，四刀距离各自图片边的距离，单位为`px`
      4) 具体代表: `上、右、下、左`
      5) 这四个值，还可以设置百分数，相对于图片的尺寸，来进行切割
   3) 如果不写`border-image-slice`这个属性
      1) 即没有图片的切割位置，则图片不在进行切割，而是整张使用
      2) 并且填充规则也发生变化，只会把整张图片，自适应，填充到边框切割出的四个角
      3) 其它的四个部分，不进行填充



4. 让边框图片进行延伸
   1) 类似于扩大内容区，本质不同
   2) 原理
      1) 图片的填充，会自适应，对应边框的尺寸
      2) 图片无法扩大，如果把边框进行拉伸，则对应位置的图片就会拉伸
      3) 而边框无法进行拉伸，只能被内容区撑开，扩大边框的尺寸，不是拉伸
      4) 由于边框的尺寸没有发生变化，所以四个角的尺寸是不会发生变化的
      5) 拉伸的是其它四个部分
   3) 通过: `border-image-outset: 100px;`，可以实现内容区的扩增
      1) 原理，四周都扩增100px，即横向扩增200px，纵向扩增200px。
      2) `width`和`height`不会发生变化，还是设置的值
      3) 像素值，填写负值没有效果，并不会进行缩小



5. 设置边框图片的展示宽度
   1) 相当于修改边框的粗细，本质不同，对实际的边框尺寸没有影响，还是那么大
   2) 通过，`border-image-width`进行设置，有三种赋值方式
      1) 第一种: 直接写数字，相当于是边框尺寸的倍数
         1) 比如: `border-image-width: 1`
      2) 第二种: 填写具体的像素值，作为尺寸，不可为负，否则没有效果
         1) 比如: `border-image-width: 20px;`
      3) 第三种: 填写`auto`，自适应切割下来的对应位置的图片的尺寸
         1) 即: `border-image-slice`的值
         2) 比如: `border-image-width: auto;`
         


6. 让边框图片填充内容区(即第9块区域)
   1) 默认是不会进行填充的
   2) 通过操作，设置填充图片四刀位置的属性，进行设置
   3) 即操作: `border-image-slice`属性，在最后添加上`fill`
      1) 比如: `border-image-slice: 100 fill;`




7. 设置边框图片的拉伸和平铺
   1) 背景图片在进行填充的时候，会进行自适应填充，这就是拉伸的效果
   2) 通过属性`border-image-repeat`，进行设置，该属性有四个值
      1) `stretch`，默认值，填充图片时，进行拉伸
         1) 往对应位置填充切割好的图片时，自适应，对应边框的尺寸，小的就进行拉伸
      2) `round`，填充图片时，进行平铺
         1) 往对应位置填充切割好的图片时，不进行自适应
         2) 如果对应位置的边框尺寸过大，会多显示几个
         3) 即把填充的图片，复制几份出来，然后拼接成填充尺寸的大小，进行填充
         4) 如果拼接时，如果加一张，超过了尺寸，不加小于边框的尺寸，就会进行裁剪
         5) 把超过的，裁剪掉，变成对应尺寸的大小
      3) `repeat`，填充图片时，进行平铺，但是也具有拉伸效果
         1) 先进行平铺，后进行拉伸
         2) 如果填充的图片尺寸，小于将要填充的位置的尺寸
         3) 会先复制图片，然后进行拼接，拼接成对应尺寸的大小后，在进行填充
         4) 如果在拼接过程中，如果加一张，大于了边框的尺寸，不加又小于边框的尺寸
         5) 该属性不会，在多取一张，然后进行裁剪
         6) 而是，把当前拼接的图片，进行拉伸，使用边框的尺寸
         7) 如果拼接完尺寸刚好，则不进行拉伸处理
      4) `space`，填充图片时，进行平铺，兼容性不是很好
         1) 如果填充的图片，尺寸过小
         2) 先复制图片，进行拼接
         3) 在拼接的过程中，如果加一块，尺寸过大，不加尺寸又不够
         4) 该属性既不会拉伸，也不会裁剪拼接
         5) 而是，把拼接好的图片，放到一个合适的位置，即对称位置
         6) 由于填充的图片，尺寸还是不够，其它的位置用空白填充
            1) 即均分空白，类似`margin`的`auto`
         7) 如果拼接完，尺寸刚好，则啥都不干，直接填充
   3) 四个角的填充样式，不受该属性的控制，只能设置四条边的
      1) 四个角的填充样式，依旧是拉伸效果，即自适应四个角的尺寸
   4) 并且`border-image-repeat`，这个属性还可以设置两个值，最多只能设置两个值
      1) 比如: `border-image-repeat: space repeat;`
      2) 意思: 横向的边符合`space`填充规律，纵向的边符合`repeat`填充规律






8. 设置边框图片的联合写法
   1) 把设置填充方式，切割位置，引入图片放在一个属性中进行引入
   2) 利用属性: `border-image`，这是一个混合属性
   3) 属性的赋值顺序: 引入图片路径、切割位置、填充方式
      1) 比如: `border-image: url(./tp/t1.jpg) 100 space;`
      2) 比如: `border-image: url(./tp/t1.jpg) 100 100 100 100 fill space;`
      3) 最后填充样式可以不写，使用默认值`stretch`






# 边框渐变色


1. 渐变色其实就是类似图片，先生成渐变色图片，然后在进行填充


2. 边框填充渐变色，和填充背景图片的操作方式一样
   1) 把边框分割成9个部分，渐变色图片分割成9个部分

3. 填充方式
   1) 引入渐变色图片，需要用到两个函数创建渐变色图片
      1) 比如: `border-image-source: linear-gradient(#f0f, #0ff)`
      2) 比如: `border-image-source: radial-gradient(#f0f, #0ff)`
      3) 线性渐变:`linear-gradient()`、径向渐变: `radial-gradient()`
      4) 传入的颜色数据，从什么颜色渐变到什么颜色，在渐变到什么颜色，等等
   2) 设置分割位置
      1) 比如: `border-image-slice: 10 10 10 10;`
      2) 通常: **切割的位置，设置的值，与边框的宽度是相同的**
      3) 目的: 防止渐变，进行拉伸填充，与四个角的衔接不密切
   3) 混合写法
      1) `border-image: linear-gradient(#f0f, #0ff, #ff0) 100 fill;`
      






# 背景渐变色





8 给背景颜色设置成渐变色(background-image)
你会发现background-image属性是引入背景图片的，而上面的边框的渐变色设置使用的也是引入背景图片的一个方法，所以设置渐变色，就是当做是设置背景图片。也就是把渐变色当成背景图片来处理的。
那如何设置渐变色呢，也需要借助渐变色的产生器，具体代码如下:
background-image: linear-gradient(#f0f, #0ff, #ff0)   线性渐变
background-image: radial-gradient(#f0f, #0ff, #ff0)   径向渐变










9 引入背景图片的知识扩充(background-image)
9.1  设置背景图片开始展示的位置(background-origin)
我们也都了解，背景图片开始展示的位置，也就是背景图片的左顶点是从padding区域开始填充的。但是这个位置我们是可以调整的，它一共有三个值，具体使用如下:
background-image: url(t1.jpg)     引入一张背景图片
background-origin: border-box     从border开始显示
background-origin: padding-box    从padding开始显示(也是默认显示的位置)
background-origin: content-box    从content(内容区)开始显示
虽然经过上面的设置，我们可以设置图片显示的位置，但是由于背景图片填充会进行平铺，也就是虽然我们设置从padding开始展示，但是border区域也会自动填充上背景图片。所以我们要取消这种效果，就需要借助: background-repeat。
所以设置开始显示位置的属性，一般都配合background-repeat来使用。具体代码如下:
background-origin: content-box    从内容区开始显示
background-repeat: no-repeat      取消平铺现象

并且background-origin这个属性会对background-position产生影响，因为这个属性设置的就是背景图片的显示位置，具体效果就是从当前位置x和y移动多少像素，然后达到目标位置，由于background-origin这个属性设置的就是背景图片开始展示的位置，所以会对这个属性产生影响。
9.2  设置背景图片结束展示的位置(background-clip)
背景图片的结束显示位置，如果不进行设置的话，它会一直填充到border区域。但是这个背景图片结束显示的位置我们也是可以进行调节的。也有三个调节值。
background-image: url(t1.jpg)     引入一张背景图片
background-origin: border-box;   从border开始显示

background-clip: border-box   在border终止显示(包含border)也是默认值
background-clip: padding-box  在padding终止显示(包含padding)
background-clip: content-box  在内容区终止显示(包含内容区)

9.3  引入多张背景图片
background-image是一个css2中的属性，但是在css3中又对这个属性进行了扩充，使它可以一次引入多张背景图片。具体操作如下:
background-image: url(), url()     多张背景图片以逗号隔开。
我们知道与background-image配合使用的还有多个属性，用来设置背景图片的样式，比如: 设置大小: background-size、调整位置: background-position等等。以设置背景图片大小简单介绍一下，background-size: 100px 100px; 设置背景图片的大小为100px*100px。
但是上面我们介绍了在css3中可以引入多张背景图片，那如何设置它们的大小，代码如下:   background-size: 100px 100px, 100px 100px; 也是以逗号隔开，这样每个属性就对应每张背景图片的大小了，其它属性用法一样也是用逗号隔开。
引入多张背景图片的使用场合:
但是这个引入多张背景图片的使用次数是非常少的，就算使用，一般也是作为容错机制来使用的。打给比方说，一个区域要显示一个背景图片，但是这个背景图片的像素比较高，在加上网速有又比较慢，这样就会造成背景图片半天加载不出来。这个时候就需要引入两张背景图片了，一张正常的，一张像素非常低的。当第一张加载不出来或者引入的路径出了问题，这样就可以显示第二种，这样给用户的体验就会稍微好一些。
9.4 按照文字显示背景图片(background-clip)
什么意思，打个比方说，有这么一个标签<div>123</div>。这个标签里面有一个文本信息123，想要给它加一个背景图片，但是这个背景图片的展示样式有要求，就是只在123文本信息存在的位置显示，其它区域不显示，即图片展示的样式就是123。并且和文本123同样大小同一位置。
实际代码如下:
background-image: url()      先引入一张图片
-webkit-background-clip: text   由于兼容性不是很好，所以要这样写
background-clip: text
这样与文本展示的文字一样的背景图片就产生了，但是光这样还不够，看不到效果。为什么这样说，那是因为产生的这个文字样式的背景图片与文字展示的大小位置都一样，所以文字就会覆盖背景图片。所以说要想使背景图片展示出来，就需要把文字设成透明的，这样我们才能看见背景图片展示的样式。
设置文字颜色为透明的方法有两种，一种是color: transparent;
另外一种就是下面的写法，也是新增的一个属性，如下:
-webkit-text-fill-color: transparent;    兼容性不是很好，所以要加上前缀
text-fill-color: transparent;
经过上面的文字颜色的设置，背景图片就变成文字样式，并且我们也能看到效果。
9.5 把渐变色背景裁切成文字样式(background-clip)
既然背景图片可以按照所填的文本信息进行文字类型的裁剪。那渐变色的背景颜色按理来说也可以，因为渐变色背景也是按照图片进行处理的，经过代码的验证发现是可以的。具体代码如下；
background-image: linear-gradient(#f0f, #0ff, #ff0);
-webkit-background-clip: text;
background-clip: text;
color: transparent;
这样我们就可以把一个标签内的文本展示样式设置的更加绚丽化。
9.6 设置背景图片的填充方式(background-clip)
我们都了解，如果一张背景图片的大小小于它将要填充的区域，那么这个区域就会显示多张。如果我们想要它只显示一张，我们之前一直把background-repeat设置成no-repeat。
其实background-repeat除了no-repeat之外还有很多值，不同的值对应不同的作用。比如:
background-repeat: round;  作用就是如果剩下的区域不足以放下一张图片，那么之前填充完的图片就会先进行一个拉伸，如果区域刚好放下一张图片，之前拉伸的图片在变成原始大小。
background-repeat: space;  作用就是如果剩下的区域不足以放下一张图片，那么之前填充完的图片就会先自适应变成对称的，然后剩下的区域空着，如果区域刚好放下一张图片，之前的图片在变成原始位置。不像round一样会拉伸图片。
并且round和space可以分开设置，比如设置横向的为round，纵向为space。代码如下:   background-repeat: round space;
需要注意的是round和space不能和repeat-x和repeat-y一块使用，写上也没有效果。为什么，因为background-repeat最多只能设置两个值，而repeat-x和repeat-y一个值就相当于两个值。比如:
background-repeat: repeat-x相当于background-repeat: repeat-x no-repeat
background-repeat: repeat-y相当于background-repeat: no-repeat repeat-y 

9.7 设置背景图片相对于谁进行定位(background-attachment)
背景图片相对于谁进行定位，这个谁一共有三个，它们分别为可视区窗口、容器自身、容器里的文本内容。
如果我们在一个html中定义一个添加背景图片的容器，一个不添加背景图片的容器，这个不添加背景图片的容器就是一个辅助，如果给不添加背景图片的容器定义一个非常大的height，那么可视区窗口就会出现一个滚动条。
然后我们给添加背景图片的容器添加一张背景图片。并且给添加背景图片的容器添加过多的内容。这个时候如果给添加背景图片的容器设置overflow: scroll，这个时候超出部分会隐藏并且在容器上产生滚动条可以进行滚动查看那些隐藏的区域。
此时浏览器就会有两个滚动条，一个是可视区窗口的，一个是添加背景图片容器的。然后我们就可以测试background-attachment，这个属性一共有三个值，如下:
background-attachment: scroll(默认值) 相对于容器本身进行定位，也就是我们滑动容器内部的滚动条，图片不动。滑动可视区窗口的滚动条，图片会随着容器滑动，就相当于绑在了容器上。
background-attachment: local相对于内容区进行定位，也就是这张背景图片就会随着容器内容区的移动而移动，也就是我们滑动容器的滚动条，图片就会随着内容而移动。
background-attachment: fixed相对于可视区窗口进行定位，相当于绑定在了可视区窗口上，如果我们滑动可视区窗口的滚动条，容器进行移动，但是容器的背景图片不动，因为可视区窗口没动。虽然图片不随着容器移动而移动，但是当可视区窗口的滚动条滚动过大，使背景图片滚动到了容器的外面，这个时候在容器外面部分的背景图片还是会进行隐藏。因为即使背景图片向对于可视区窗口进行定位，但是也没有脱离容器，而容器的背景图片超出就进行隐藏。

9.8 设置背景图片自适应容器大小(background-size)
什么意思，比如说有一张图片它的大小为300px*400px，但是容器的大小为100px*100px。如果我们使用下面的方法，那么这张图片就会等比例进行缩放，如果图片小，那就会等比例进行扩大。
这个效果就是使用background-size进行实现的，我们之前学的size是可以设置背景图片的大小，但是在css3中又新增了两个值，分别为:cover、contain。
background-size: cover;   这个值的作用就是让背景图片进行放大或缩小，直到背景图片的一边等于容器的一边，而另一边必须大于或等于容器的另一边。
background-size: contain;  这个值的作用也是让背景图片进行放大或缩小，直到背景图片的一边等于容器的一边，而另一边必须小于或等于容器的另一边。所以这个属性如果不设置background-repeat: no-repeat，可能会多显示一部分。










10 探索背景渐变色
在学习边框渐变色和背景渐变色时，简单使用了一下背景渐变色的产生方法，分别为:  线性渐变:linear-gradient()、径向渐变: radial-gradient()
10.1  设置线性渐变的渐变方向
linear-gradient()这是一个设置线性渐变，比如: linear-gradient(#0ff, #f0f)它就会从上到下进行渐变。我们除了可以设置渐变颜色，还可以设置渐变方向。具体代码如下:
linear-gradient(to left, #0ff, #f0f)    向左渐变，也就是从右向左渐变
linear-gradient(to top, #0ff, #f0f)     向上渐变
linear-gradient(to bottom, #0ff, #f0f)  向下渐变 
linear-gradient(to right, #0ff, #f0f)   向右渐变
linear-gradient(to top right, #0ff, #f0f)   向右上渐变，即从左下到右上渐变，其它四个角以此类推，并且top right的位置可以互换。
上面是通过固定的方向设置的渐变色方向，我们还可以直接通过角度设置方向，代码如下:
linear-gradient(0deg, #0ff, #f0f)   0deg就相当于to bottom
linear-gradient(90deg, #0ff, #f0f)  90deg就相当于to right，以此类推，top = 180deg、left = 270deg、bottom = 0deg = 360deg。
linear-gradient(32deg, #0ff, #f0f)  向32度方向渐变。

10.2  设置径向渐变的渐变中心和渐变半径
radial-gradient()为径向渐变，它的变化原理就是由中心向四周进行渐变，所以没有方向的设置，但是对放射中心的位置进行设置。代码如下:
radial-gradient(circle at 20% 80px, #0ff, #f0f)  
radial-gradient(ellipse at 20% 80px, #0ff, #f0f)
其中circle设置的就是按照圆进行发射扩散渐变，ellipse设置的是按照椭圆进行发散渐变。
其中20% 80px对应的就是扩散中心的x坐标，y坐标。并且这个值不仅可以写像素值还可以写left、top之类的、还可以填写百分数。

其实除了圆心，还可以设置它的整体放射半径，即设置放射到什么位置停止。具体代码如下(中心点到什么位置的长度作为放射半径):
radial-gradient(ellipse closest-corner at 20% 80px, #0ff, #f0f)
放射到最近的边就停止放射
radial-gradient(ellipse closest-side at 20% 80px, #0ff, #f0f)
放射到最近的边就停止放射
radial-gradient(ellipse farthest-corner at 20% 80px, #0ff, #f0f)
放射到最远的角落就停止放射
radial-gradient(ellipse farthest-side at 20% 80px, #0ff, #f0f)
放射到最边的边就停止放射
什么是最近的角落最远的边，一个容器有四个边和四个角，以放射的中心开始，距离中心最近的一个角对应的就是closest-corner，最近的边对应的就closest-side，最远的类似。

10.3  设置渐变过渡区域
什么意思，背景渐变既然叫渐变，肯定有一个区域，从一个什么色慢慢的变成什么色，这个区域就是渐变过渡区域，并且这个区域的长度是可以调节的，代码如下:
linear-gradient(90deg, #0ff 20px, #f0f 80px) 
这段代码是什么意思呢，20px就是#0ff开始渐变的位置，80px就是#f0f开始渐变的位置。由于#0ff是第一个颜色，所以20px之前就都是#0ff，然后20px也是为#0ff。但是到21px颜色就开始朝着第二个颜色值#f0f开始渐变，直到80px，80px处就是#f0f。如果#f0f为最后一个颜色，但是80px并不是容器的终点，那么从80px往后就都为#f0f了，如果还存在颜色值，则从81px开始在朝着下一个颜色值渐变。
而20px到80px就是一个渐变的区域。

径向渐变是可以设置它的渐变过渡区的，它设置的值对应的就是半径。代码如下:
radial-gradient(#0ff 20%, #f0f 80px)  这里的20%就是当前容器的大小的20%，并且20%和80px对应的就是半径，和上面的径向渐变的理解一样。









11 text设置文本的属性
11.1  给文本文字加阴影(text-shadow)
通过这个属性可以设置一个与文字一样的阴影。
具体代码如下: text-shadow(3px 4px 5px #fff) 
其中3px设置的就是x方向偏移量，4px设置y方向偏移量，5px设置的是模糊度，后面设置的就是颜色。并且这个属性也可以设置多个阴影，代码如下:
text-shadow(3px 4px 5px #fff, 3px 4px 5px #fff) 
同理第一次设置的背景会覆盖第二次设置的背景，重叠也会加深颜色显示。

给文字加阴影常用实例
文字浮雕效果:  text-shadow(1px 1px 0px #000, -1px -1px 0px #fff)
文字镂刻效果:  text-shadow(-1px -1px 0px #000, 1px 1px 0px #fff)

11.2  给文字加阴影与文字背景联合使用的一个问题
在上文我们学到了如果剪切出一个文字背景，这里我们又学到了如何给文字添加背景。但是这两个一块使用就会出问题。代码如下:
background-image: url()      先引入一张图片
-webkit-background-clip: text   由于兼容性不是很好，所以要这样写
background-clip: text
-webkit-text-fill-color: transparent;    兼容性不是很好，所以要加上前缀
text-fill-color: transparent;
text-shadow(0px 0px 5px #fff) 
你就会发现背景文字图片没有了，其实不是没有了，只不过是被我们设置的阴影给覆盖住了。所以我们看不到它了。但是为什么背影会覆盖住文字，它不是背影吗。 
其实就是因为我们给文字设置的颜色为透明，然后展示的那个是背景图片，既然是背景图片，它是在最后的。虽然文字背影也是背景，但是容器背景在最下面。所以文字背景才会遮住文字图片。如果想要文字图片展示出来，我们只需要给文字背景加上一个透明度就可以了，这样文字背景看起来就又成了文字图片的背景。代码如下:
text-shadow(0px 0px 5px rgba(0, 0, 0, 0.5)) 
11.3  给文字加一个描边
就是用笔在文字的最外面在描上一笔，使用代码如下:
-webkit-text-stroke: 1px #f0f;   兼容性不是很好
描边效果最好的一种文字类型: font-family: simsun;(兼容性也不是很好，高版本谷歌可能能用) 这个文字描起来非常炫酷。
然后我们在给文字设置上同名色或者文字背景图片，效果更加好看。








# 引入外部字体包

1. 浏览器，渲染文字，都是从字体包中，找到对应的文字进行渲染
   1) 默认情况下，使用的是自带的，基础的字体包
   2) 也可以手动引入其他的字体包
      1) 这样，当前元素下的所有子元素中的文字，在查询字体样式时
      2) 先去手动引入的字体包中查询，如果查询不到，再去默认的字体包中查询
      3) 如果在手动引入的字体包中，查询到了对应的文字，则进行显示，不再查询默认的字体包


2. 引入外部字体包的方式
```css
@font-face {
	font-family: 'diyfont';    /* diyfont为自定义的字体包的名称，以便元素使用该字体包*/
	src: url('?.eot');   
	src: url('?.eot?#iefix') format('embedded-opentype'), 
	     url('?.woff') format('woff'),
	     url('?.ttf') format('truetype'),
	     url('?.svg#fontname') format('svg'); 
    /* format中，是具体的不同文件类型，对应的字符表示，是固定值 */
} 
```


3. 元素中使用外部字体包的方式
   1) 该元素下的所有文字信息，包括子元素，进行查询是，先去引入的外部字体包中查询
   2) 通过: `font-family: 'diyfont'`，使一个元素启用对应的外部字体包



4. 知识扩充
   1) 一个`@font-face`中，只能有一个`url`，如果写多个，则后面引入的字体库就会替换前面的
   2) 上例中，多个`url`连写，其实是为了兼容
      1) 不同的文件，其实文件内容是相同的，即字体包中的字体样式相同
      2) 起不同后缀名的作用，是因为不同的浏览器，支持的文件格式不同，有的文件打不开
      3) 所以为了兼容不同的浏览器，制定了多个版本，只要有一个引入成功即可
         1) 即使发生覆盖现象，由于他们都是同一个字体包，所以没有影响
      4) 总共有五种文件类型: `.eot`、`.eot?#iefix`、`.woff`、`.ttf`、`.svg#fontname`
    


5. format的作用
   1) 向MIME(协议)中，写入一个可以打开的规则
   2) 浏览器遇到打不开的文件时，会查询MIME(协议)
   3) 如果在该协议的内部找到了该文件的记录，则电脑就会打开该文件，然后返回给浏览器
   4) MIME(协议)中，记录的就是一条一条的，可以打开那些文件的记录
   5) 由于不同的电脑和浏览器，MIME(协议)可能会不相同
   6) 所以在打开文件的时候，同时向MIME(协议)中写入该文件的记录
      1) 防止，MIME(协议)的内部没有该文件的打开记录





11.5  保留文本敲入时的样式(white-space)
如果我们不使用这个属性的话，无论你敲多少个空格、回车、tab最后都会变成一个空格，这是我们知道的，如果使用了这个属性，那你敲多少个空格或回车它就展示多少个空格或回车。 这个属性有很多值，代码如下:
white-space: pre    保留文本写入时的样式

11.6  设置文本的换行(word-break)
如果给一个容器定义一个宽，这个时候我们如果填写的是中文信息或者有空格，那么超出边界就会换行显示，但是设置上这个属性就会取消这个换行。代码如下:
word-break:  keep-all
如果填写的是一串英文，如果没有空格，那么即使超出容器边界也不会进行换行，但是我们设置上下面的属性就会让这串英文在超出边界的地方强制换行，代码如下:
word-break: break-all
还有一个属性比较常用，word-break: break-word。
这个的作用和break-all差不多，只要超出边界就会进行换行展示，但是有一点不同，这个属性会尽可能的保持一个展示信息的完整性，比如一个非常长的英文单词，但是它将要显示的地方，显示不了它，这个时候它就会换行展示，给人的感觉是一个英文单词变成了两个。而这个属性会让这个英文单词先换到下一行，如果下一个整行还展示不了这个内容，那没办法只能一个单词显示两行了，但是如果下一行能显示这个单词，那这个单词就完整的显示在一行，给人的感觉就会比较良好。

11.7  设置文本信息的分栏展示(columns)
意思就是一段文字，在容器中分几栏进行展示，使用属性columns进行设置，它一共可以设置两个值，一个是栏宽、一个是分几栏。代码如下:
columns: 300px  3     分三栏，每栏宽300px
其实这个属性还可以分开来设置，也就是单独设置栏数和栏宽。具体代码如下:
column-count: 3    把文字分成3栏进行展示，如果不设置栏宽，会进行自适应
column-gap: 50px       设置列与列之间的间隙
column-rule: 1px solid #000      设置每一栏中间出现一条竖线，和border的用法一样，比如单独设置颜色column-rule-color
column-width: 300px    设置列宽，可以填auto进行自适应了，这里需要注意的地方就是，你虽然设置的列宽为300px，假如容器的大小为700px，那这样容器顶多放下两栏，但是这两栏的宽度就不是300px，它会进行一个拉伸的效果，直到适应700px这个宽，当然如果刚好的话，就不进行拉伸，大小就是300px。有种平铺的效果。所以我们一般不设置列宽，让它自适应。

它们的使用样式如下:   一个标签<div> 一段文字 <div>
div{ columns: 300px  3;   column-gap: 50px  }   这样可以看出效果

上面的属性是设置分栏显示的，但是在分栏的文本中含有一个标签，这个标签中也有一些文字，它也符合分栏的效果，然后在一栏中显示。但是我们通过下面的设置，就可以使它脱离分栏，并且在这个位置打断分栏，然后下面的内容继续分栏展示，也就是标签上面的内容进行分栏，下面的内容进行分栏。这两栏互不影响。代码如下:
column-span: all    这个方法可以做一些每一栏的标题，它的默认值为1
column-break-after: avoid    该标签中的文字另起一栏进行显示
column-break-after: always   该标签后面的文字另起一栏进行显示
column-break-after的兼容性不是很好，可能要加上-webkit-前缀
它们的使用样式如下:一个标签<div> 一段文字 <p>一段文字</p> 一段文字<div>
div{ columns: 300px  3;   column-gap: 50px  }   
p{ column-span: all;  column-break-after: avoid }  这样可以看出效果

还有一点：进行分栏布局的标签，会继承它父标签的border，有这么一个结构<div> <p></p> </div>，如果给p标签设置分栏布局，如果它的父标签div中有border，那么p标签就会继承这个border。并且还会使p标签脱离div标签，也就是div容器的大小影响不了p标签文字信息的换行展示了。

11.7  利用分栏展示做瀑布流的缺点
现在网上提出使用columns来做瀑布流的效果，但是，用columns这个属性做瀑布流不太适合，为什么，就是因为分栏的原理所限制，分栏的原理就是不能产生一栏独高的现象。如果将要出现一栏独高的现象，它就会自动从有内容的最后一栏中取出内容填充到独高的后面所有栏中。这样就牺牲了最后一栏，使其它的栏等高，或者多栏等高，避免出现一栏独高现象。基于这种现象，最后一栏永远在变化，可能填着填着最后一栏图片就没了，然后后面再补充最后一栏，这样最后一栏永远是最后操作的，所以不太适合瀑布流。

11.8  让分栏布局进行移动
需要借助transform: translateX()/translateY()
比如向左移动-100px，代码如下:
transform: translateX(-100px)









# 混杂盒模型

1. 主要影响的是盒子的尺寸

2. 正常情况下
   1) boxWidth = width + 2*border + 2*padding
   2) content = width

3. 混杂盒模型下
   1) boxWidth = width  
   2) content = width - 2*border - 2*padding 

4. 混杂盒模型的设置方式
   1) `box-sizing: border-box;`







# 弹性盒模型

1. 弹性盒模型一旦进行设置，则内部的所有子元素就会排成一行
   1) 如果子元素，排成一行，尺寸超出了父级容器的尺寸，即弹性盒的尺寸
   2) 所有的子元素，一起进行压缩，直到与弹性盒的尺寸相同
   3) 即超出部分，不会自动换行，需要手动进行设置

2. 弹性盒的设置方式
   1) 通过: `display: flex;`，进行设置

3. 设置弹性盒的主轴方向
   1) 弹性盒中的所有子元素，都会排成一行
   2) 其实是按照，主轴的方向排成一行
   3) 主轴的方向，默认从左向右
   4) 通过: `flex-direction`，可以更改主轴的方向
      1) `flex-direction: row`  方向自左向右(默认值)
      2) `flex-direction: column`   方向自上到下
      3) `flex-direction: row-reverse`  方向自右向左
      4) `flex-direction: column-reverse`    方向自下到上


4. 设置压缩样式(是否可以进行换行)
   1) 默认情况下，超出范围，就进行压缩
   2) 可以通过: `flex-wrap`，进行修改
      1) `flex-wrap: wrap`          允许换行展示，不在进行压缩
      2) `flex-wrap: nowrap`        不允许换行展示(默认值)
      3) `flex-wrap:  wrap-reverse` 允许换行，但是展示的顺序会进行翻转
         1) 也就是第一行展示的会跑的最后一行展示。



5. 设置主轴的对齐方式
   1) `justify-content: flex-start`   左对齐(默认值)
      1) 三个盒子都在弹性盒子的最左侧，并且三个盒子之间没有间隔。
   2) `justify-content: flex-end`     右对齐
      2) 三个盒子都在弹性盒子的最右侧，并且三个盒子之间没有间隔。
   3) `justify-content: center`       主轴方向居中对齐
      3) 三个盒子都在弹性盒子的中间，并且三个盒子之间没有间隔。
   4) `justify-content: space-between` 
      1) 最左侧和最右侧各放一个盒子
      2) 剩下的盒子在中间自适应进行摆放，且尽量看起来对称均匀。
   5) `justify-content: space-around`     
      1) 所有的盒子都自适应摆放，且尽量看起来对称均匀，两边与弹性盒子留有缝隙



6. 设置交叉轴，只有一行内容时的对齐方式
   1) 交叉轴，是与主轴垂直的一个轴，初始方向从上到下，跟随主轴方向的改变而改变
   2) 如果不允许换行，则交叉轴，永远只有一行内容
   3) `align-items: flex-start`   上对齐
      1) 三个盒子都在弹性盒子的最上侧，并且三个盒子之间没有间隔。
   4) `align-items: flex-end`     下对齐
      1) 三个盒子都在弹性盒子的最下侧，并且三个盒子之间没有间隔。
   5) `align-items: center`       交叉轴居中对齐
      1) 三个盒子都在弹性盒子的中间，并且三个盒子之间没有间隔。
   6) `align-items: baseline`     设置的是内容区的自己进行对齐
      1) 找到最低的一个元素，其它元素向下移动，与最低的进行顶部对齐
      2) 比如: 使用`margin-top`向下移动盒子
   7) `align-items: stretch`   默认值    
      1) 如果弹性盒的子元素，没有设置`height`属性
      2) 则在该属性的作用下，自适应弹性盒的`height`，即高度相同
      3) 如果子元素设置的`height`属性，该属性失效，子元素使用自己设置的高度
      4) 所以如果设置的内容盒子没有设置高，但是又想要根据其内部的内容区撑开
      5) 就需要把`align-items`的值改掉



7. 设置交叉轴，存在多行内容时的对齐方式
   1) 如果弹性盒，允许换行显示，则交叉轴可能存在多行内容
   2) 设置多行对齐的方式，对单行没有效果
   3) `align-content: flex-start`   上对齐
   4) `align-content: flex-end`     下对齐
   5) `align-content: center`       交叉轴居中对齐
   6) `align-content: space-between`    两顶点各放一行，中间位置自适应
   7) `align-content: space-around`     所有行都进行自适应
   8) `align-content: stretch`     默认值
      1) 如果子元素没有设置`height`，会进行自适应
         1) 适应规则: 每一行的高度相同
         2) 内容区撑开后，还有空白部分，则平均分配，给每一行都加点
      2) 如果设置了`height`，该属性自动失效
   9) 如果一行中，某个元素的高过大，则该行中其它元素的高度会自适应最高的那个元素
      1) 即使，`align-content`的属性值不为`stretch`，也会自适应最高的那一个



8. 利用弹性盒，作出水平垂直居中的效果
   1) `justify-content: center` 和  `align-items: center`     单行内容居中对齐
   2) `justify-content: center` 和  `align-content: center`   多行内容居中对齐



9. 设置子级的排列顺序(在子级上设置)
   1) 通过属性: `order`进行设置
   2) 比如: `order: 2;`
   3) 该属性的默认值为: `0`;
   4) 弹性盒，子级会顺序排列，其实是根据该属性的属性值，确定位置
   5) 值小的，排在前面，值相同的，根据html的位置，上面的排在前面
   6) 该属性的属性值，可以为负值，正常比大小确定位置



10. 设置弹性盒中，单个元素基于交叉轴的对称方式
    1) 使用: `align-self`，进行设置
    2) 具体的设置方式
       1) `align-self: flex-start`   设置该标签在交叉轴的起点
       2) `align-self: flex-end`     设置该标签在交叉轴的终点
       3) `align-self: center`       设置该标签在交叉轴的中心
       4) `align-self: baseline`     设置该标签与其它标签的基线对齐
       5) `align-self: stretch`      如果这个标签没有设置height，则自适应(不是默认值)
    3) 注意事项
       1) 该属性的权重，大于弹性盒中单行内容区基于交叉轴的对齐方式
          1) 即，弹性盒中，使用了单行内容区基于交叉轴的对齐方式
          2) 则该元素失效，使用自身设置的对齐方式
          3) 其它元素没有影响，依旧使用弹性盒中设置的
       2) 交叉轴上有多行内容区，
          1) 多行内容区中，每一行的高度都是固定的，并且相同
             1) 该属性失效，使用弹性盒上，设置的基于交叉轴的多行内容的对齐方式
          2) 如果某一行的元素高度不固定，则该行的其它元素的高度会自适应最高的那一个元素的高度
             1) **如果设置了该属性，则该元素的高度自适应失效，即由内容区撑开**
             2) 这样，就与最高元素产生了高度差，这样该属性就可以生效
             3) 可以，把这一行存在高度差的元素，看成一个单行弹性盒
             4) 通过该属性，就可以设置矮的元素，基于高的元素的对齐方式
             5) 默认是上对齐，即顶部对齐
             6) 高的元素无法通过该属性设置对齐样式
                1) 高的元素，就固定在那个位置，无法进行移动
                2) 即高的元素，上下没有空白
                3) 矮的，由于本行的高度由高的撑开，所以存在空白，可以设置对齐方式，进行移动



11. 设置单个元素的横向拉伸(沿主轴方向)
    1) 弹性盒中的元素，会排成一行
       1) 如果弹性盒中的元素的宽度和，小于弹性盒的宽度
       2) 会遵循一定的规则，来拉伸每个元素，使其变宽
    2) 具体的拉伸规则
       1) 元素增加的宽度 = 剩余空间 * (对应元素的flex-grow / 所有元素的flex-grow总和)
    3) 通过: `flex-grow`，来进行操作
       1) `flex-grow`的默认值为`0`，根据上方的拉伸规则，计算出的结果为`0`
          1) 所以，即使横向上存在空白区间，也不会分配给当前的元素
          2) 当前的元素的宽度，要不为自己设置的，要不由内容区撑开
       2) 属性值，可以为小数
    4) **该属性的作用，就是分配剩余空间**
       1) 所有的元素，排成一行后，还剩下一些空间
       2) 如果想要把剩余的空间，分配给某些元素，就可以使用该属性
       3) 默认是不进行分配的，那个元素使用那个元素，就设置该属性，进行分配
       4) 分配方式如上，简化分配方式
          1) 剩余空间分配的份数，等于所有子元素该属性的值的和
          2) 然后按照该属性的值，进行分配，等于几就分给几份



12. 设置单个元素的横向压缩(沿主轴方向)
    1) 弹性盒，如果没有设置允许换行
       1) 当所有元素的宽度和超过了弹性盒的宽度，就会进行压缩
       2) 每个元素的所压缩的尺寸，是可以控制的
       3) 默认每个元素都压缩相同的尺寸
    2) 通过属性: `flex-shrink`，可以修改当前元素所压缩的尺寸
       1) 该属性的默认值为`1`
       2) 压缩的尺寸 = 总共超出的宽 * ( (当前元素的宽 * 当前元素的flex-shrink) / 所有元素的(宽 * flex-shrink) 的总和 )
       3) 总共超出的宽，包括每个元素的margin，然后减去弹性盒的content区域的宽度
          1) 即不包括弹性盒的padding和border
       4) 当前元素的宽，不包括margin、padding、border，只包括`content`
       5) 每个元素的margin、padding、border是不会进行压缩的，压缩的为content区域
       6) **属性值可以为小数**
    3) 如果把压缩属性的值设置为0，即不进行压缩
       1) 当前元素多宽，就展示多宽，并且排成一排，最终会超出弹性盒



13. 内容区盒子的width替代值
    1) 通过属性: `flex-basis`进行设置
    2) 该属性有三种赋值方式
       1) `auto`，表示自适应
          1) 自适应的规则，其实就是拉伸
          2) 如果设置了拉伸，即拉伸属性的值不为0
             1) 则当前元素的尺寸为: 
                1) 弹性盒content的宽度 / 所有元素的拉伸属性值的和 * 当前元素的拉伸属性值
             2) 并且会替换width
          3) 如果没有设置拉伸，即拉伸属性的值为0
             1) 如果设置了width，就是要width的值
             2) 如果没有设置width，则由内容区撑开
       2) 还可以设置具体的像素值
       3) 还可以设置百分数，取的是弹性盒content的尺寸的百分数，作为宽度值
    3) 该值，会作为元素的宽度，即替换`width`设置的宽度值
       1) 压缩和拉伸运算，使用的也是该值
       2) 利用该属性，可以实现动态控制弹性盒中元素的尺寸
    4) 该属性的特点
       1) 该属性设置的元素宽度，最终会替换`width`，但是有一个特点
       2) 如果，该元素下书写的是一整个的英文单词，并且长度超过了该元素设置的宽度
          1) 则当前的元素的宽度，由单词进行撑开，相当于该属性设置的宽度失效
          2) 如果，当前元素设置了`width`，则撑开的宽度最大值为`width`
          3) 如果没有设置`width`，则撑开多大，当前元素的宽度为多大
          4) 相当于`width`，变成了最大宽度，当前属性设置的宽度变成了最小宽度
       3) 如果设置的width，比当前属性设置的值小，就会产生一个现象，**固定当前元素的宽度**
          1) 英文单词撑不开当前元素的宽度了
          2) width设置的值相当于宽度的最大值，但是最大值又比宽度的最小值小
          3) 就相当于把宽度给卡在这个值上了，不会在进行变化
       4) 可以使用`word-break: break-word`强制使英文单词换行
          1) 这样，该属性设置的宽度，就为最终宽度，不会再发生由单词撑开宽度的现象了
          2) 只要超过了设置的宽度，就会换行，根本不会进行撑开




14. 压缩和拉伸的综合属性的设置
    1) 通过属性: `flex`进行设置
    2) 比如: `flex: 1 1 auto`
       1) 第一个数，设置拉伸，相当于`flex-grow`
       2) 第二个数，设置压缩，相当于`flex-shrink`
       3) 第三个数，设置当前元素的宽度，相当于`flex-basis`
          







13 文本超出隐藏的设置(overflow)
设置一个容器内容超出隐藏借助overflow就可以实现，overflow有很多属性，依次介绍一下:
overflow: visible; 超出部分不隐藏，也是默认值
overflow: hidden;  超出部分隐藏，不出现滚动条
overflow: scroll;  超出部分隐藏，出现滚动条，可以通过滚动条查看隐藏内容
overflow: auto;  超出部分隐藏，出现滚动条，可以通过滚动条查看隐藏内容
上面是设置整体的即横向和纵向只要超出，就会出现滚动条，除此之外还可以单独设置。
overflow-x:    设置横向
overflow-y:    设置纵向
并且只要overflow-x或者overflow-y只要有一个进行设置，并且设置的值不是visible，则另一个就会自动变成auto。所以如果想要设置只有一个方向有滚动条，另一个最好设置成hidden，否则它会自动变成auto出现滚动条。
移动端横向滑动屏幕，内容会进行横向滚动的效果，就可以使用overflow-x就可以实现效果，因为在移动端滑动屏幕就相当于滑动滚动条。

14 拖动容器边缘改变容器大小的操作(resize)
什么意思，就是用户可以点击容器的右下角可以拖拽容器，改变容器的大小，我们只需要加上一个resize属性就可以了，具体操作如下:
resize: both           可以上下左右拖拽，调节容器的高度和宽度
resize: vertical       只能上下拖拽，调节容器高度，宽度操作不了
resize: horizontal     只能左右拖拽，调节容器宽度，高度操作不了
这里需要注意的是这个属性必须配合overflow来使用才有效果，也就是必须要设置overflow，无论设置什么值，否则拖拽不了。

15 过度动画(transition)
15.1  设置过度动画
过度动画其实也不算是动画，它只不过是让一个标签的一种状态变成另外一种状态。如果进行设置的话，那么这种状态的切换会瞬间完成，看不见变化的过程。但是我们使用transition进行设置的话，就会看见状态变化的过程。这样就体现出一种动画的效果。
transition属性使用方法如下:
transition-property: width;    设置监听的属性，比如设置的是width，那么这个过度动画就会监听width的状态，一旦width发生变化，那么就会产生过度效果。这里还可以设置成all，这个值代表的是监听所有具有过度动画的属性是否进行变化。除此之外我们还可以transition-property: width, height; 以便监听多个具体的属性是否发生变化。
transition-duration: 1;  设置的是这个动画过渡持续的时间(单位是秒)，也就是这个动画变化的时间，也是一个状态变成另一个状态的时间间隔。
transition-timing-function: linear; 设置的是变化状态，比如先快后慢的变化或者匀速变化(linear)。
transition-delay: 1;  设置的是等待时间(单位是秒)，即这个动画过渡要先等多长时间然后再进行过度。
transition过渡动画的设置除了上面的分开设置，还可以进行整体设置
transition: 监听属性  过渡时间  变化状态  等待时间。 比如:
transition; all 2s linear 1;
transition; width,height  2s,1s  linear 1s    width过渡2秒，height过度1秒
并且后面的运动状态和等待时间可以不写，有默认值，但是前面的监听属性和过度时间必须要设置上。
并且不是所有的属性都支持过渡的检测，使用手册上每个属性介绍中都有一个动画性，如果显示的是否，就不支持动画过渡。
这种方式实现的动画只能做到从A状态变化到B状态，如果想要继续变成C状态它是办不到的。

15.2  手动配置过度动画的运动状态
在上文中介绍了一个过渡动画的实现原理，其中提到了一个变化状态，比如linear代表的就是匀速变化。其实这个变化状态我们是可以自己定义的。
自定义运动状态需要借助cubic-bezier()，括号中必须填写上四位数字。其实linear --> cubic-bezier(0, 0, 1, 1)
这个属性的使用手法如下:
transition-timing-function: cubic-bezier(0, 0, 1, 1)
transition; width  2s  cubic-bezier(0, 0, 1, 1)
其实cubic-bezier()的作用就是绘制出一条三次立方贝塞尔曲线。而过渡动画的运动状态就是由贝塞尔曲线决定的。
由于这四个值比较难记算，所以控制台就给我们提供了一个调试的平台，找到我们设置的cubic-bezier，这个时候我们就可以打开贝塞尔曲线的调试平台，如下图:
 
只要我们拖动当前展示的贝塞尔曲线的两端，我们就可以随意的设置出我们需要的贝塞尔曲线。
并且在平台的最上面还有一个小紫球，只要我们设置出了贝塞尔曲线，它就会按照曲线进行运动，通过它我们就可以看出我们到底设置出了一个什么样的运动状态，然后取出对应的四个值即可。
并且cubic-bezier中填的四个数值，前两个其实就是第一个紫球(起点的坐标)，后两个就是第二个紫球(终点的坐标)，并且第二个和第四个(y坐标)可以为负数。第一个和第三个(x坐标)取值范围为0到1。
这里有一个注意点，如果第一点的y坐标小于0，那么运动状态开始时会迅速朝相反的位置移动，然后再正向移动。如果第二个点的y坐标大于1，那么运动状态就会运动到终点的时候会继续移动然后再退回到终点。

16  动画 (animation)
这个属性才是css3中提供的动画效果，通过它我们可以实现从A状态变化到B状态然后再到C状态。可以实现连续动画的效果。
16.1  设置动画
animation也是一个复合属性，我们看一下animation的各个属性
animation-duration: 2    设置整个动画持续的时间，不管中间有多少动画运动
animation-timing-function: cubic-bezier()     设置每一段动画的运动状态
animation-delay: 2           设置动画的等待时间
animation-name: ft              设置动画名，与关键帧@keyframes建立联系
animation-iteration-count: 3    设置动画的执行次数，并且只要动画一执行，哪怕后面循环执行多次，只在第一次动画执行时等待时间才有效，也就是后面循环执行的动画不再等待。并且这里可以填infinite，意思是该动画无限循环执行下去。
animation-direction: normal     设置的是动画执行的顺序，也就是关键帧的执行顺序，默认值为normal，从0%开始执行到100%。reverse是从100%开始执行到0%。alternate是从0%开始执行到100%，然后再从100%执行到0%，也就是这个属性会先正向执行一次，在反向执行一次，所以动画的执行次数要设置成2的倍数次，比较适合做钟摆运动。alternate-reverse开始时反向运动一次，在正向移动一次，动画的执行次数也要设置成2的倍数次。
animation-fill-mode: none     设置动画运动完引用该动画标签的一种状态，none为默认值，不做处理。forwards设置当动画运动完，标签的css样式变成动画运行中100%中设置的状态，也就是最后一帧的状态。backwards设置动画还没开始运动，标签的css样式变成动画运行中0%中设置的状态，也就是第一帧的状态，然后当动画运动完成后恢复本来的css样式。toth设置的就是在动画开始之前，标签变成第一帧的状态，然后动画运动完成后保留最后一帧的状态。

animation既然是复合属性，那么它就可以连写，每一位对应的作用如下:
animation: 动画名  动画持续时间  每段动画运动状态  等待时间  动画执行次数 设置执行方向
其它属性可以省略不写，但是动画名和动画持续时间必须要设置上。

16.2  与动画配合使用的关键帧的处理
要想实现动画效果，还有一个东西是必不可少的，那就是关键帧容器，里面存储的我们设置的一些状态目标点，由于animation可以实现多次动画的持续变化，所以关键帧容器中还存放着一些关键帧，每个关键帧对应一次状态的改变也就是一次动画。
定义关键帧容器代码:
@keyframes 设置的动画名{
    0%{ 目标状态 }
    50%{ 目标状态 }
    100%{ 目标状态 }
}
0%到100%对应的就是关键帧，这个百分数可以随便填，哪怕写小数也没问题。个数也随意。其实这些百分数就是根据动画定义的时间来分配每个目标运动时间的。
比如animation-duration: 2定义了2s，那么在1s的时候就会运动到50%设置的目标点处，然后1.5s就会运动到75%设置的目标点处，2s就会运动到100%设置的目标点处。所以，0%处一般填写的就是将要进行动画运动属性的初始值，如果填的不是初始值，而是填的目标值，那么就会发生瞬移。
其中0%可以换成form，100%可以换成to。比如说:
@keyframes 设置的动画名{
    form{ 目标状态 }
    50%{ 目标状态 }
    to{ 目标状态 }
}
当然了如果定义了多个动画，我们就要使用对应数量的@keyframes，然后在设置上对应的动画名就可以了。
关键帧加前缀的操作代码:   @-moz-keyframes 设置的动画名{}

一个具体的动画代码如下:
    div{
        width: 100px;
        height: 100px;
        background-color: #f0f;
        animation: fd 4s;
    }
    @keyframes fd{
        0%{
           height: 100px;
        }
        50%{
           height: 200px;
        }
        to{
           height: 100px;
        }
    }
并且一个标签是可以设置多个动画的，代码格式如下:
animation: fd 4s, fs 2s;   每个动画之间用逗号隔开，然后再设置对应的keyframes即可，比如:
@keyframes fd{}      @keyframes fs{}
而且不是一个动画运行完另一个在运行，而是同时运行。

16.3  取消动画的过渡效果
取消动画的过渡效果，就是直接运动到每一帧设置的目标点，省去了变化的一个过程，具体代码如下:
animation: fd 4s steps(1, end);    
取消动画的过渡效果就是通过steps实现的，发现它占有的位置是设置运动状态的一个位置，所以设置上steps就不能设置运动状态了。当然如果设置steps，运动都取消了，运动状态也就没有用了。
steps中有两个值，第一个值其实设置的就是当前属性运动到目标属性经过几次变化，并且这几次变化是平均分配的，并且每一帧运动的时间还是存在的。
比如有这么一个动画
@keyframes fd{
        0%{
           height: 100px;
        }
        50%{
           height: 200px;
        }
        to{
           height: 100px;
        }
    }
如果上例代码中，取消过渡效果，并且设置的是steps(n, end)，这里的n可以随意设置一个正整数，如果n设置的就是每一帧在对应时间内经过多少次变化到达目标点。
以上例为例，如果n设置的是1，那么会等待2s直接运动到200px。如果n设置的是4。那么0.5s --> 125px、1s --> 150px、1.5s --> 175px; 2.0s --> 200px;这样就产生了一个轻微的动画效果。
根据上述，如果n设置的值越大，那么变化的次数就会越多，并且变化的时间间隔也会越短，且变化的属性值差距变小，这样就越接近过渡动画的效果。

第二个值一共有两个值，一个是end、一个是start。
end的作用就是保留当前帧的效果，直到这段时间结束。也就是从0%变化到50%的时候，保留的是0%设置的状态。这个值的缺陷就是看不到100%设置的状态，因为在100%之前显示的是上一帧的样式，然后当到达100%的时候动画结束又会变成初始状态，这个时候100%的状态就会一闪而过看不到。
start的作用就是保留下一帧的效果，直到这段时间结束。也就是从0%变化到50%的时候，保留的是50%设置的状态。这个值的缺陷就是看不到0%和初始设置的状态，因为在0%的时候就会显示下一帧的样式。
steps的特殊值
steps(1,  end) --> step-end     steps(1,  start) --> step-start，即
animation: fd 4s step-end  就相当于 animation: fd 4s steps(1, end)

使用场景，每个动画的间隔时间一样，并且有规律的运动，并且需要一个状态直接运动到另一个状态，这个时候我们就可以使用steps，开始状态作为0%处的关键帧，最终状态作为100%处的关键帧。一共运动多少次作为steps的次数。
比如钟表动画，秒针要选转一圈360度，然后每隔1s移动一次，且秒针的移动角度一样(6度)。我们就可以使用steps实现。代码如下:
animation: fd 60s steps(60, end)   60s分60次，如果目标点设置成选转360度，那么就会1s转6度，且是瞬移。没有过渡的效果。

17  旋转 (transform)
旋转分2d旋转和3d旋转。
17.1  2d选转
2d选转比较简单，就是在盒子内找一个选转中心，然后这个标签围绕这个选转中心进行选转。就像一个大风扇似的。
它的实现代码如下;  transform: rotate(180deg)  意思该标签是选转180度，这个角度可正可负，正值顺时针进行旋转，负值逆时针旋转。
上面我们说到2d选转有一个选转中心，如果我们不进行对选转中心的设置，那么选转中心就是整个标签盒子的中心点，也就是两条对角线的交叉点。
其实选转中心我们是可以进行设置的。操作代码如下:
tsform-origin: 0 0    这里0 0 设置的就是旋转中心的位置，相对于标签进行设置，而0 0 就是标签容器的左顶点。

17.2  3d选转
17.2.1  绕3条坐标轴进行旋转
3d旋转就比较复杂了，因为涉及到3d就要设计到X轴、Y轴、Z轴。
在电脑屏幕少，X轴的方向就是横向的从左到右，Y轴的方法就是纵向的从上到下，难的是Z轴，它的方向是垂直屏幕的从内向外，也就是指向自己。
每个轴都有一个对应的旋转属性，如下:
transform: rotateX(180deg)    围绕X轴进行旋转
transform: rotateY(180deg)    围绕Y轴进行旋转
transform: rotateZ(180deg)    围绕Z轴进行旋转

旋转角度也是可正可负。并且3d旋转必须要在一个3d的环境下才能看到比较好的效果，那怎样设置3d环境。就是给它的父级添加一个属性，这样它的父级就会变成一个3d的盒子，这样这个旋转就处在3d环境下了。
给自己设置一个3d属性不行吗，当然不行，因为这个标签是处在父标签的环境下，如果给自己设置一个3d属性，那么是它自己的子标签处在3d环境下，和他没有关系，所以说如果想要一个标签处于什么样的环境下，那我们就需要给它的父标签进行设置。
如果构建一个3d环境呢？ 给父标签设置上perspective: 800px和transform-style: preserve-3d就可以了。
并且需要注意的是，如果一个元素沿着某个轴进行旋转，其实元素参考的坐标轴也会跟着一起旋转。比如：绕着X轴旋转180度，那么它的坐标轴也会随着它绕X轴旋转180度。
所以由于这一特性，那我们的旋转就要产生顺序了。旋转的顺序不同，效果也不一样。比如先绕X轴旋转90度在绕Y轴旋转90度和先绕Y轴旋转90度在绕X轴旋转90度的效果是不一样的。
17.2.2  绕自定义旋转轴进行旋转
我们使用下面的方法，就可以自定义出一个旋转轴，然后容器根据这个自定义旋转轴进行旋转。
实现代码如下:
transform: rotate3d(3, 2, 1, 180deg)
会发现里面有四个参数，其中180deg为绕自定义旋转轴旋转的角度，而前面的三个值就是用来确定旋转轴的。
它的原理是这样的，在一个三维坐标轴中，有X轴、Y轴、Z轴，那么我们要想确定一个点就需要有三个值(x, y, z)。而上面的三个值的作用就是在元素的3d坐标轴中确定一个点，然后过坐标中心点(0, 0, 0)和我们确定的这个点(3, 2, 1)作直线，方向就是从坐标中心点指向我们确定的这个点的方向，这条线就是我们自定义的旋转轴。
17.2.3  绕空间轴进行旋转
也就是在空间中定义一个点，然后过这个点做垂直于平面的一条线作为旋转轴，然后就可以围绕这个轴进行旋转了，代码如下:
transform-origin: 100px 200px 300px;  这样就定义出了一个空间点。
然后绕什么轴进行旋转，就会过这个点做一条平行于什么轴的线作为旋转轴进行旋转。并且上面的值对应的也是旋转半径。
比如:  transform: rotateY(180deg) 绕着Y轴旋转，就会过(100px, 200px, 300px)这个点做Y轴的平行线作为旋转轴，旋转半径为200px，旋转角度为180度。
17.3  改变坐标轴的尺寸(放大或缩小)
放大或缩小坐标轴其实放大或缩小的是坐标轴刻度的距离。比如之前刻度100和刻度200之间的距离就是100，但是刻度放大两倍，那这个距离就变成了200。而屏幕上刻度所代表的就是像素，而像素间的距离就可以体现出一个物体的大小。
比如100px到200px没有扩大的情况下，间距就是正常的100px大小，但是我们进行扩大两倍，虽然它们的差值还是100px。查看盒模型的尺寸也是100px。但是它们的间距已经变成了200px，这样就造成了我们肉眼观看到的物体的尺寸变大了。
具体使用代码如下:
transform: scale(2, 2)   
第一个数代表的是x轴放大的倍数，第二个数代表的是y轴放大的倍数。
这样我们展示的物体的宽扩大1倍，高扩大1倍。由于实际放大的像素之间的距离，所以我们如果设置定位，然后在设置left: 100px。这个时候虽然设置的是100px。但是由于像素间的距离变大1倍，所以我们观察的是这个物体向右移动了200px。
当然如果填写数小于1，就会缩放，比如放大0.5倍，那不就相当于缩小1倍。
并且这个属性可以连续操作，不需要加逗号，加上空格就可以了，并且不会进行覆盖，而是在前一个的基础上在进行放大或缩小。比如:
transform: scale(.5, .5)  scale(2, 1)     X轴刻度先缩小1倍，然后在扩大一倍，所以X轴不变。Y轴先缩小一倍，然后不变，所以Y轴缩小一倍。
并且有一点需要注意是，如果我们在给一个坐标轴进行了放大或缩小后，由于坐标轴有方向，也就是沿着坐标轴方向的距离变大或缩小。这个时候，如果我们对这个元素进行了旋转，那么放大或缩小后的坐标轴也会进行旋转。
这个时候问题就来了，放大或缩小后的坐标轴旋转后，那么就又会指向一个新的方向，那么这个方向的距离在放到或缩小后的坐标轴的影响下也会进行放大或缩小，但是之前的那个放大或缩小的方向的距离是不会再变成本来的状态，还是会保留当前的放大或缩小的状态。
即只要一使用scale进行设置，那么这个地方的影响会一直存在下去。所以如果需要使用scale属性进行放大或缩小，但是还存在旋转。为了避免scale的影响，最好是先旋转在设置scale。

除此之外我们还可以单独对每个坐标轴进行操作，代码如下:
transform: scalex(2)     扩大或缩小x轴
transform: scaley(2)     扩大或缩小y轴
transform: scalez(2)     扩大或缩小z轴
transform: scale3d(1, 2, 3)   通过它我们可以一起设置X轴、Y轴、Z轴，上文中的scale(1, 2)显然易见这个是操作2d界面，而scale3d(1, 2, 3)操作的是3d界面
17.4  倾斜元素的2d坐标轴
具体代码如下:
transform: skew(45deg, 80deg)
效果就是元素看起来朝着平行四边形进行变化，本来是个四四方方的。其实skew操作的是坐标轴，然后由于电脑上屏幕成像是根据坐标轴来进行成像的。所以倾斜坐标轴，能间接的影响元素的展示样式。
并且skew中的参数和上方学习操作坐标轴的方法不太一样，skew中的第一个值倾斜的不是x轴，而是操作的y轴，第二个参数才是操作的x轴。
这个属性也可以单独分开设置，代码如下:
transform: skewx(45deg)    单独操作x轴
transform: skewy(80deg)    单独操作y轴
并且没有3d的用法，也就是操作不了z轴。
skew在起作用倾斜坐标轴的同时，还会把这个坐标轴进行一个拉伸，并且这个拉伸值是不固定的。如果倾斜的是y轴的话，会发现元素的高度是不变的，如果不进行拉伸，那么坐标轴一倾斜，元素肯定会减小。但是高度不变，说明y轴在倾斜时还进行了拉伸。它的拉伸值和倾斜角度和元素尺寸挂钩，所以拉伸值是不固定的。
由于skew可以倾斜和拉伸坐标轴，所以在使用它是要注意，它可以影响后面依靠坐标轴进行操作的属性。

18  沿坐标轴进行平移(transform)
需要借助translate才能实现效果，它也分为2d和3d和单独操作每个轴，代码如下: 
transform: translateX(100px)   单独操作X轴，元素朝着X轴的正方向。
transform: translateY(100px)   单独操作Y轴，元素朝着Y轴的正方向。
transform: translateZ(100px)   单独操作Z轴，元素朝着Z轴的正方向。
transform: translate(100px, 100px)   操作2d环境下的X轴和Y轴。
transform: translate3d(5px, 5px, 5px)   操作3d环境下的X轴、Y轴、Z轴
需要注意的是如果进行平移，也会带动着坐标轴的平移。

并且translate有一个非常强悍的功能，如果括号中填写的是百分数，这个百分数取的不是父标签的尺寸，而是根据自身的尺寸进行取值。比如:
transform: translateX(-50%)  朝着X轴的反方向移动自身的width的一半。
根据这一特性，我们就可以处理一些居中定位但是又不知道自身尺寸的元素。因为不知道自身尺寸，我们就不能写margin-top和margin-left往回移自身的一半。这个时候我们就可以使用translate来往回移，因为translate参考的是自身的尺寸，就算我们不知道，但是电脑会给我们计算。代码如下:
transform: translate(-50%, -50%)

19  自定义transform 的功能(matrix)
matrix是一个非常强大的方法，为什么这么说。因为transform中定义的那些属性功能，比如平移、旋转之类的方法，底层其实就是利用matrix来实现的。而浏览器也把matrix的一个使用接口给我们留了出来，这样我们就可以直接操作matrix，来自己设置一些transform中没有定义的功能。比如元素的镜像显示，通过transform利用上面的方法我们是实现不了的。
下面来介绍一下matrix的原理。
其实matrix就是一个行列式的运算，通过运算我们就可以操作每个像素点的位置。
我们都了解，其实屏幕上的展示的物体其实就是一个一个的像素点拼接而成。如果说我们对这些像素点进行操作，比如整体左移移动，这个时候就会造成物体的左移现象。
既然matrix可以通过行列式的计算控制像素点的位置，那么我们就可以通过matrix来控制一个物体的展示位置与状态。
下面来介绍一下matrix是怎么控制一个像素位置的。
上文中，介绍了matrix是通过行列式的计算来控制像素的位置，那么它是怎么计算的，以二维像素为例。计算代码如下:
| a  b  c |          | x |           | ax + by + c |
| d  e  f |     *    | y |     =     | dx + ey + f |
| 0  0  1 |          | 1 |           | 0  + 0  + 1 |
上面的计算公式，就是二维matrix底层的行间计算公式。其中 * 号右侧的行间式中的x、y就是当前某个像素点的位置。
然后右侧计算出的一个新的行间式就是这个像素点的新位置，新位置的坐标点的坐标为(ax + by + c,  dx + ey + f)。这样之前像素点上展示的东西就会移动到新位置上进行展示。
而  * 号左侧的行间式就是我们通过matrix这个方法进行设置的，发现只需要设置前两行就可以了，最后一行为默认值。设置的代码如下:
transform:  matrix(a, d, b, e, c, f)      要注意填值的顺序
我们分析一下transform: translate(100px, 100px)通过底层matrix实现的原理。pranslate的功能是平移，所以它对应的行间式为下面的样式。
| 1  b  0 |          | x |           | x + b |
| 0  1  f |     *    | y |     =     | y + f |
| 0  0  1 |          | 1 |           | 1     |
只有产生(x + b, y + f)，这样物体才能进行移动。所以写成transform:  matrix(1, 0, b, 1, 0, f) 和 transform: translate(b, f)的效果是一样的。

根据上面的分析，我们就可以写出一个使物体进行镜像显示的matrix，镜像显示对应的行间运算如下:
| -1  0  0 |          | x |           | -x |
|  0  1  0 |     *    | y |     =     |  y |
|  0  0  1 |          | 1 |           |  1 |
对x进行取反，这样横轴上展示的物体就会进行一个翻转，纵轴上展示的物体不变，这样就是一个镜像的原理。
对应的代码为:  transform:  matrix(-1, 0, 0, 1, 0, 0)

使用经验，先把效果转换成运算完的行间式，然后进行反推matrix设置的行间式就比较简单了。

20  景深(perspective)
设置景深，就是给3d效果，加上一个深度，这样立体感就会变得更加强悍。
具体代码:    perspective: 800px;   默认值为auto，设置的值必须要大于0
其实设置景深就相当于操作的是我们的眼睛距离屏幕的距离，设置的值越大就相当于我们的眼睛距离屏幕越远。
perspective需要给父级加上才有效，因为这是构造出一个环境。

但是还有一个属性，我们可以使用它在子级上设置景深，和通过perspective给父级加上景深的效果是一样的。代码如下:
transform: perspective(800pxs)
但是通过transform: perspective(800pxs)给对应的标签直接设置景深，那么就会造成观察的效果是一样的。假如通过transform: perspective(800pxs)给五个标签设置景深，也就相当于我们定义出了5双眼睛观察各自对应的元素，这样观察的效果当然就一样了。
使用perspective时需要注意，必须写在transform的最前面，然后后面再跟旋转、平移。如果写在后面，有些浏览器可能不识别，写上没效果。
使用perspective还不能调节观察点，没有perspective-origin这个属性接口。
但是如果想要实现一个观察效果都是一样的话，就可以使用这个属性。因为通过perspective给父级设置景深，那内部元素的展示效果肯定有区别。如果想要实现不同样式，那我们就要通过perspective给父级设置景深了。

这里还有一点需要注意的是，景深是可以进行叠加的，我们可以给子标签设置上一个景深，并且还可以在给父标签设置上一个景深，这是完全可以的。这两个设置的景深就会进行叠加，并且这种效果可能更好一些。

关于景深的知识点扩充，以及操作景深出现的五种效果，以一个图片为例进行说明，图片如下:
 
上图中的绿色的就相当于我们的电脑屏幕，是固定不动的，白色箭头就相当于设置的景深，相当于我们眼睛到到屏幕的距离，然后由于屏幕是固定的，所以改变景深，只能是移动眼睛到屏幕的距离来适应景深变化。
我们其实看到的是物体在屏幕上的投影，也就是上图中的三个白圈。正是由于我们观看到的其实是投影就造成了下面的五种神奇的现象。
1、如果我们没有设置translateZ，那么物体就在屏幕上，这个时候我们通过白线做投影，投影始终与实际物体大小一致，所以就造成了，如果没有设置translateZ，无论我们怎么设置景深，我们通过白线观看到的物体的大小始终是不变的。
2、然后，把translateZ设置成正数，物体就跑到屏幕的前面去了，这个时候，这个物体通过我们的视线(黄线)，在屏幕上的投影就会变大。造成了如果translateZ越大，那么元素与我们眼睛的距离就会越近，这个时候再通过黄线观看物体在屏幕上的投影就会越来越大。
3、然后，把translateZ设置成负数，物体就跑到屏幕的后面去了，这个时候，这个物体通过我们的视线(红线)，在屏幕上的投影就会变小。造成了如果translateZ越小，那么元素与我们眼睛的距离就会越远，这个时候再通过红线观看物体在屏幕上的投影就会越来越小。
4、如果translateZ值为正数，如果减小景深，就相当于我们的眼睛在朝物体靠近，然后再通过黄线做投影，就会造成景深越小，我们观看的物体就会越大。
5、如果translateZ值为负数，如果减小景深，就相当于我们的眼睛在朝屏幕靠近，然后再通过红线做投影，就会造成景深越小，我们观看的物体就会越小。

21  设置观察屏幕的观察点(perspective-origin)
我们在观察一个物体的时候，如果从不同的角度观看一个物体，我们看到的效果肯定是不一样的，其实我们的电脑屏幕也可以设置一个观察点，代码如下:
perspective-origin: 100px  100px;
这样写的效果，就相当于我们站在100px, 100px这个点的位置然后看我们定义的该标签下的所有效果。如果这个点改变，比如: perspective-origin: 200px  200px; 就相当于我们又站在了200px, 200px这个点的位置观看该标签下的所有效果，肯定与刚才在100px, 100px处观看的效果是不一样的。
观察点需要给父级加上才可以，因为这是构造出一个环境。

知识实用扩充:
如果我们在设置3d效果时，如果对当前展示的样式不满意的话。我们就可以通过perspective-origin来调整观看位置，但是我们也不知道在什么位置观看合适。这个时候我们就可以通过给body绑定上一个鼠标移入触发事件，然后让body沾满全屏，然后把鼠标的X轴坐标点和Y轴坐标点作为perspective-origin的两个属性值。然后我们就可以通过移动鼠标，来找出一个合适的观察点。这样我们就可以把对应的值取出来，给perspective-origin设置上就可以了。

22  构建3d环境(transform-style)
如果不把一个环境设置成3d的话，它就永远是2d的，也就是在z轴的方向永远只有一个渲染面，哪怕设置上了景深。
如果想要z轴出现多个渲染面的话，那就必须设置成3d。那怎么设置呢？
代码为:     transform-style: preserve-3d
所以如果想要Z轴可以渲染出多个画面，看起来更有立体感，就必须给父级设置transform-style: preserve-3d。
    这里需要注意的是 transform-style: preserve-3d属性构建出来的3d环境，只能给第一级子标签使用。如果第二级子标签也想让它处于3d的环境下，那就只能在给第一级子标签也设置上transform-style: preserve-3d

23  让背面的元素是否显示(transform-style)
如果我们旋转一个容器的时候，如果把一个元素旋转到背面是否进行显示，也就是这个元素前面有内容，就相当于它位于背面。
操作代码如下：backface-visibility: visible;    默认值，进行显示
              backface-visibility: hidden;    不显示
这个属性不是设置在父级上，而是设置在具体的展示标签上。


24  页面的性能优化(well-change)
一个电脑上有CPU和GPU两个部分，其中CPU擅长处理一些逻辑运算，与或非之类的东西。然后GPU主要擅长一些高精度浮点数的运算，也就是小数。
也就是CPU的运算能力不如GPU，一个GPU的运算能力能顶几十个CPU。
其中GPU又分为家用的和工业的，工业的肯定比家用的性能更加强悍。家用的CPU在绘制图片时是一块一块的绘制。而工业的GPU是一个一个像素点进行单独操作，精益求精，一点一点描出来的。
但是上面我们介绍了transform就是操作的一个一个像素，也就是transform这个方法，默认我们的电脑使用的就是工业的GPU。但是显然是不可能的，这个时候就涉及到用家用的GPU来做工业GPU的工作，显然是非常烧性能的。
学习性能的优化，就要了解一个页面的渲染步骤，如下:
 

在实际绘制(栅格化)，有些浏览器如果不进行设置的话，它是默认使用CPU进行绘制的。本来CPU就不擅长这个，所以就会非常的浪费性能。但是在Google Chrome中会自动调用方法，利用GPU来进行绘制。
另外还有两种操作是比较耗性能的，我们成它们为reflow和repaint。其中reflow会引发页面的重排，也就是上面的renderTree会失效。然后在重新生成一个renderTree，然后在经过layout和paint两步，重新对页面进行渲染。
而repaint不会引发renderTree的重排，只不过是再次经过paint对页面进行重绘。
所以reflow会引发网页的重排和重绘，repaint只引发网页的重绘，所以引发reflow必然会引发repaint。虽然重排和重绘都会浪费计算机的性能，但是显然repaint比reflow要好很多。
所以在网页设计中尽量避免reflow和repaint的发生，如果避免不了，就尽量触发repaint，或者少触发reflow。、

触发reflow的一些操作如下:
改变窗口大小
改变文字大小
内容的改变，输入框输入文字
激活伪类，如:hover
操作class属性
脚本操作DOM
计算offsetWidth和offsetHeight
设置style属性
所以在js中如果需要大量使用style给一个标签设置css样式。我们都是采用给标签加class名，样式提前在css中写好。这样就会只产生一次reflow重排重绘。

触发repaint的一些操作如下：
repaint：如果只是改变某个元素的背景色、
文字颜色、边框颜色，不影响它周围或内部布局的属性

并且在css3中还有一个非常耗性能的属性，前文中已经提过，那就是transform，这个属性操作的是点阵式，而普通用户的电脑的性能没有达到这种点阵式操作的需求，所以使用transform时就会很耗性能。
    解决的办法就是把transform这个属性交给GPU来处理，并且还不是直接在渲染层上操作，而是GPU另起一个层面，让这个层面单独处理transform。由于没有直接在渲染层上进行操作，所以引发重绘和重排的次数就大大减少。一定程度上优化了性能。
让GPU另起一层的方法有很多种:
opacity、transform: translate3d()、transform: translateZ()都可以触发。所以在使用transform时，最后最好加上一个translateZ(0)，这样对样式没有影响，但是可以使GPU另起一层，可以省很多效率。
但是上面的方法不常用，常用的是下面的方法:
well-change:    这是一个属性，我们可以使用这个属性来监听一个即将发生变化的属性，比如: well-change: transform;  这样，我们再使用transform属性时，GPU另起一层来处理transform，达到提升效率的目的。
这里需要注意的是well-change这个属性如果设置上，就会一直进行监听某种属性是否发生变化，监听也是消耗性能的。
所以在well-change的使用上有进行了优化，在一个属性即将进行变化时我们设置上这个属性，当属性变化完我们在销毁这个属性。这样在属性变化时，既能让GPU另起一层来处理，平常的时候还没有well-change的监听步骤。这样又能进一步优化性能。

比如说: 当我们点击某个标签时让transform进行变化。
well-change监听transform的代码就可以这样写，如下:
div:hover{
    well-change: transform
}
因为在点击之前必定触发hover，而且速度比点击快。这样在点击触发事件，让transform进行变化时，监听已经设置完成。如果鼠标一开，hover消失，well-change的监听也就会被取消。
当然方法有很多，只要在触发的前一刻设置上well-change就可以了，上面只是一个比较典型的用法介绍。

知识点扩充:
浏览器刷新页面的频率为1秒60次，一次我们称为一帧。
一帧的时长大约是16.7mm
如果GPU 可以再一帧里渲染好页面，那么当你改动页面的元素或者实现动画的时候，将会非常流畅。

25  显示器的成像原理和像素的意义
25.1  空间混色法和像素点内部
一个屏幕可以展示各种各样的颜色，其实也是用的是3原色(rgb)进行混合然后形成一个新的颜色。
在光学中，是使用这三个三原色进行混合重叠，然后就可以展示出一个全新的颜色。但是在设备中，三原色就是一个固体，显然办不到三原色的重叠配色。那为什么显示屏又可以显示出不同的颜色? 这里就涉及到空间混色法。
我们都知道，屏幕的成像是靠像素点的配合来完成的。其实一个像素点中是有3个像点的。而这3个像点就是3原色。并且这3个像点(3原色)在像素点中是平铺的，也就是在一个平面上，而不是叠加的。一个像素点类似下图



既然三原色的显像管在一个平面上，为什么它可以混合产生多种颜色。其实是利用了我们人眼的缺点，那就是太小的物体看不清甚至看不见。由于三原色显像管实在是太小了，而距离过近的颜色，在我们眼睛中是分辨不出的，就类似于它们重叠在了一起。所以在我们眼睛中看到的就是一个它们的混合体，所以我们才能看到多种颜色。这种现象就被称为是空间混色法。

25.2  显示屏成像的原理
要想成像，一个必不可少的物品就是显示屏。常用的显示屏分两种。
一种是crt显示屏:        老式的大头电视机所用的显示屏
一种是LCD显示屏:        也就是现在的液晶显示屏

Crt屏的成像原理:
Crt屏成像，主要是依靠一个屏幕后方的电子枪打出高频电子束，由于屏幕上涂满了荧光粉(三原色对应的荧光粉，按照像素点的方式进行分布)。然后当屏幕上每个像素点中的三原色荧光粉接收到电子束，就会发光，并且发光强度也是随着电子束的强弱有关。这样crt屏幕上接收到电子束的像素点，根据电子束的强弱，发出不同的光，这些像素点在一组合就可以成像了。
并且荧光粉的发光原理是接收到一次电子束就发一下光，所以为了让屏幕持续的亮下去，就需要电子枪持续的打出电子束。

但是在以前，技术还没有那么发达，有的厂家生产的电子枪比较好，一枪就可以打出3束，分别对应一个像素点上的三原色荧光粉。但是吧有的厂家生产的电子枪就比较次一点，一次只能打一束，这就造成了每个像素点，电子枪都需要打三次。
并且由于电子束其实就是光，光在传播是受到的影响比较大，可能某次电子枪打出的某束电子束就会发生偏移，本来该达到像素点上的，打到了边上，可能就会造成不好的影响。所以为了避免这种情况，电子枪和crt屏幕中间还有一层庇荫层，庇荫层上面就布满着与屏幕像素点位置一样的小孔。这样庇荫层就可以起一个过滤的作用，那些打歪的电子束在庇荫层处就被滤掉了，只有那些正常的电子束才能通过庇荫层打到屏幕上。

LCD显示屏的成像原理:
LCD显示屏也就是液晶显示屏，它的成像原理主要是靠液晶材料。我们都知道液晶可以在固体和液体之间来回变换，并且液体和固体的透光强调也是不一样的。根据这一特点，液晶显示屏就诞生了。
在液晶显示屏中有两块导电的玻璃，而在这两块导电玻璃之间就是液晶材料。导电玻璃的作用就是在自身通电的情况下，它可以产生一个磁场，通电的强弱不同，磁场也不同。然后产生的磁场就会使中间的液晶材料根据磁场的不同，而使不同区域的液晶材料在液体和固体之间变化。
由于在导电玻璃的后方有光照传来，这样照进来的光照在不同形态的液晶状态下就会发生变化。然后在屏幕和导电玻璃之间还有一层滤光片，这滤光片也有三原色的，然后在根据像点的方式进行排列。这样照进来的那束经过液晶材料改变过的光照，然后在经过滤光片，就会在每个像素点上呈现不同的颜色，然后达到成像的效果。
改变成像通过的就是给导电玻璃通电的强弱，从而影响液晶材料，进而对照进来的光进行不同的处理，这样成像就能进行切换，形成动画。

25.3  像素点的知识
其实不同的屏幕，像素点的大小是不一样的，所以像素点的大小是没有明文规定的。虽然像素点的大小没有明确规定，但是在像素中真正有意义，值得研究的并不是像素点，而是点距。
什么是点距，也就是每个像素点之间相同颜色的像点之间的距离。比如红色像点和红色像点的距离。通过点距我们虽然不知道一个显示屏像素点的大小，但是却可以反应出像素点的密集程度。
所以说同一块区域下像素点多，和像素点密集是一个概念。而一块区域下如何做到像素点更加密集呢? 像点越小，像点间的距离也就越小，这样像素点就会越密集。
其实点距在现在是可以表示像素点的大小，但是不等同于像素点的大小。

在社会上有一个dpi(一英寸所容纳的像素点数)可以衡量一个屏幕的好坏，所以一个屏幕的dpi越大，说明像素点越小，越多，成像效果也就越好。 1英寸 == 2.54cm
其实dpi第一开始是使用在打印机上的，表示的是打印机在一英寸中可以打印出多少墨点。为了区分，然后就又提出了一个ppi，代表的是一英寸所能容纳的像素点数(点距数)。

25.4  参照像素
由于不同厂家生产的电脑屏幕的ppi是不一样的，比如说:有96dpi、200dpi、300dpi。
这样我们在定义一个css{ width: 100px; height: 100px }，在上面的三个屏幕上显示的大小尺寸是不一样的。一英寸的像素点越密集，显示的尺寸就会越小。
这样就造成了编程人员的困难，所以为了解决一个程序在不同的dpi电脑屏幕上展示的效果是一样的，就引入了参照像素。
参照像素就像一个标杆一样，起一个参照作用。
参照像素就是:  96dpi  以一臂之长的视角去看，显示出的具体大小。
标杆:  1/96 * 英寸

然后不同的dpi屏幕就会向这个标杆进行靠拢，什么意思。就是如果我们给一个元素定义了一个尺寸，在参照的96dpi中显示多大，在其他屏幕上就得显示多大。如果像素过于密集，那就把尺寸像素进行扩大显示，这样就会与在参照的96dpi中显示的一样大了。
比如:还是上面的css{ width: 100px; height: 100px }，这个时候我们设置的大小如果在参照96dpi中显示的是100px * 100px，那么在100dpi中(和96dpi差不多)展示的也是100px * 100px。
但是在200dpi中就要进行像素的扩大了，200dpi大约比96dpi大了两边，所以尺寸像素也要变成两倍，这样才能与参照的96dpi中显示的一样大(参照像素标杆的作用)。所以展示样式就变成了200px * 200px。

参照像素又被称为css像素和逻辑像素，而css像素就是我们进行编程的像素，也就是我们平常写的px。所以我们写的100px * 100px；在不同的电脑上就会按照参照像素进行处理，然后展现出样式，由于参照像素的作用，所以展示的样式的尺寸大概就是相同的一个物体。
    
通过上面的例子我们可以看出，在我们写的一个元素在进行自适应设备的尺寸时，是根据一个比值进行计算的，而这个比值就是设备像素比，公式如下:
设备像素比 dpr = 物理像素(dpi)/css像素(参照像素)
由于美工给我们的图纸，上面的图片的尺寸，元素的尺寸是实际物理像素，而我们写的css样式中的像素是参考像素。所以，我们在看美工的图的时候，最好注意一下是否需要除dpr。如果不除，可能就会经过与参考像素的比较，进行放大。

我们也管css编程的逻辑像素方式，叫做逻辑屏幕。
我们平常说的分辨率, 比如: 1920 * 1080，代表的是固定宽高下，展示的像素点数。所以分辨率一样，屏幕越小，像素点数约密，所以分辨率代表不了屏幕的质量。所以我们衡量一个屏幕的好坏不看分辨率，而是看dpi。












# transform属性

## 缩放

transform: scale(0.8);

## 平移

transform: translateX(30px);

## 旋转

transform: rotate(30deg);

# 过渡

`transition: all 3s linear 1s`

以上数据分别对应，过渡属性(全部，width只监听width)，过渡时间，过渡状态(匀速)，等待时间


# 盒模型加阴影(box-shadow)

`box-shadow: 0 0 0 0 #fff;`


# 字体库
阿里字体图标库网址:   https://www.iconfont.cn/