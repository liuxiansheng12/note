
# git的介绍
  
1. git是一个版本管理系统，可以高效的管理开发过程中的不同版本

2. git可以划分三个区块
   1) 工作目录
   2) 暂存区域
   3) get仓库


3. git主要操作的是文件快照
   1) 类似复制一份文件
   2) 先把快照保存到暂存区域
   3) 然后在把暂存区域中的文件快照，永久性的保存到Git仓库中
   4) 保存的其实是一个索引，如果文件没有发生变化，但是有进行了一次保存操作
   5) 不会重新创建文件快照，而是使用之前的，准确来说使用的是之前的索引


4. git主要在本地操作，不用依赖网络，即使在没有网络的地方也可以操作
   1) 等到达有网络的地方，再往GitHub上推送





# 获取一个git仓库
  

1. 把已有的一个文件夹变成git仓库
   1) 运行命令: `git init`
      1) 会初始化一个`.git`的文件，该文件是git仓库的核心
   2) 对文件夹中的文件进行跟踪(把文件保存到git仓库中)
      1) 仅执行了该命令还不行，git仓库的核心就是控制不同的版本，使其可以进行模板的迅速切换
      2) 所以运行`git init`创建git仓库后，需要把文件夹中的文件作为第一个模板
      3) 把文件推送到Git仓库中的方式
         1) `git add .`，保存到暂存区
         2) `git commit -m "本次模板的名称"`，把暂存区中的文件推送到Git仓库中
         3) 如果文件发生了变化，想要作为一个新的版本，重复上面的两个步骤即可


2. 克隆一个现有的git仓库
   1) 运行命令: `git clone 路径`
      1) 路径有两种形式
      2) 一种为`https协议`的路径
      3) 一种为`ssh`的路径
   2) 克隆一个仓库，几乎把所有的版本信息都克隆下来
      1) 然后，找到`master分支`下的最新版本，展示出来
   3) 克隆下来的git仓库，名称也会克隆下来，如果想要**重命名**
      1) 运行命令: `git clone 路径 新名称`
   4) 由于克隆下来的git仓库，所展示的文件，已经保存在Git仓库中为一个版本
      1) 所以，不需要多次一举的运行`add`和`commit`重新保存版本





# 记录每次更新到仓库(操作暂存区与Git仓库)

1. 功能
   1) 修改文件，把修改的文件作为一个新的版本重新保存到仓库中


2. 文件夹中文件的状态
   1) 文件目录中的文件，共有两种状态，一种是`已跟踪`，一种是`未跟踪`
   2) `已跟踪`又有三个状态: 
   3) 克隆下来的git仓库中的所有文件都是处于`已跟踪、未修改`的状态
      1) 如果新创建了一个文件，则该文件处于`未跟踪`状态


3. 状态的变化
   1) `未修改` -> `已修改` -> `已放入暂存区`
      1) 直接修改文件，则文件就从`未修改` -> `已修改`
      2) 运行`add`，把`已修改` -> `已放入暂存区`
   2) 运行`commit`，把暂存区中`所有的最新版的`文件，存入到Git仓库中
      1) 所有的文件又变成了`未修改`状态，从而进入循环状态


4. 查看所有文件的状态
   1) 输入命令: `git status`，得到详细的信息，包括是否已经跟踪
   2) 输入命令: `git status -s`或`git status --short`，得到简化信息


5. 把文件的状态变为`已跟踪、已放入暂存区`的方法(重点)
   1) 指定一个文件: `git add 文件名`
   2) 操作所有文件: `git add .`


6. 忽略文件
   1) 在根目录下创建`.gitignore`文件夹
   2) 该文件夹下写的代码，控制的是，往暂存区存放快照的时候，忽略那个文件或者文件夹
      1) 通常忽略一些通常都是些自动生成的文件，比如`node-modules`文件夹
   3) 防止Git仓库存放一些比较大，但是又没有什么用处的文件
   4) 不进行暂存的文件，它的状态是未跟踪状态
      1) 该文件也会屏蔽该操作，标记的文件不会出现在未跟踪列表中
   5) 文件中具体的代码
      1) 比如: `*.[oa]`，告诉 Git 忽略所有以 `.o` 或 `.a` 结尾的文件
      2) 比如: `*~`，告诉 Git 忽略所有以`波浪符(~)`结尾的文件
   6) 文件`.gitignore`的格式规范如下: 
      1) 所有空行或者以 ＃ 开头的行都会被 Git 忽略。
      2) 可以使用标准的 glob 模式匹配。
      3) 匹配模式可以，以(`/`)开头防止递归。
      4) 匹配模式可以，以(`/`)结尾指定目录。
      5) 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反


7. 获取具体发生变化的地方
   1) 已修改状态，到底修改了什么位置，通过`git status`指令是获取不到的
   2) 此时就需要借助`diff`指令
      1) 该指令，通过文件补丁的格式，更加具体地显示哪些行发生了改变
      2) 该指令有两种使用方式
         1) `git diff`
            1) 比较的是`当前目录文件`与`上一次暂存(暂存区最新的版本)`的文件之间的差异
            2) 比较的是文件快照，因为暂存区存放的就是文件快照
         2) `git diff --staged`
            1) 比较的是`暂存区最新版本`与`Git仓库中最新版本`的文件之间的差异
            2) 比较的是文件快照，因为暂存区和Git仓库存放的就是文件快照
         3) 如果相同，则什么也得不到
         4) 需要注意，两种方式，比较的位置不同
         5) 如果运行了`commit`，把暂存区的最新版本推送到Git仓库中
            1) 然后使用`git diff --staged`获取信息，则什么也得不到
            2) 比较的两个位置的文件快照相同



8. 把暂存区中的最新版本推送到Git仓库中的方法(重点)
   1) 可能暂存区中保存了很多种的版本
      1) `add`一次，就保持一个版本
   2) 运行`git commit`，往Git仓库中存放暂存区中的最新版本
      1) 会自动启动文本编辑器，输入本次提交的说明(版本信息)
   2) 运行`git commit -m "版本信息"`，往Git仓库中存放暂存区中的最新版本
      1) 使版本信息和指令，处于同一行


9. 跳过暂存操作，直接进行提交
   1) 在提交指令`commit`后面，添加`空格 -a`关键字
      1) 会自动进行暂存操作，相当于自动运行`git add .`
      2) 比如: `git commit -a`
      3) 比如: `git commit -a -m "版本信息"`


10. 移除文件
    1) 要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除
       1) 确切地说，是从暂存区域移除，然后提交
       2) 提交的时候，是把暂存区中的最新版本进行上传
       3) 如果从暂存区中移除，则下次提交的时候，Git仓库中的版本就不在包含该文件
    2) 可以从工作目录中删除，然后进行暂存的时候，该文件就会消失
       1) 不足之处: 如果删除后，运行`git status`时，还能看到该文件的信息
       2) 把该文件放在未跟踪的文件清单中
    3) 可以借助`git rm 文件名`命令完成此项工作
       1) 不光把记录删除掉，操作目录中的文件也会删除掉，这样就不会出现在未跟踪文件清单中了
       2) 如果运行该指令的时候，暂存区中存放了新的版本，但是还没有提交到Git仓库中
          1) 需要加上`-f`，表示强制删除
          2) 比如: `git rm -f 文件名`
          3) 这是一种安全特性，用于防止误删还没有添加到快照的数据
          4) 使用`rm`删除的文件，不能恢复
    4) `rm`的另外一种用法
       1) 从仓库中移除，但是仍希望该文件保留在当前的工作目录中，只是不进行跟踪
       2) 重新拉取的时候，该文件就会消失，仓库中没有该文件
       3) 相当于`.gitignore文件`的作用
       4) 具体命令: `git rm --cached 文件或目录的名字`
          1) 填写`文件或目录的名字`的位置，可以填写其它的代码
             1) `.gitignore文件`中写的，都能放在该位置
          2) 比如: `git rm \*~`，删除以`~`结尾的所有文件


11. 对文件进行重命名
    1) 可以直接进行重命名，然后运行`add`
       1) 不足之处: 运行`git status`时，还能看到旧名称的信息
       2) 把旧名称放在未跟踪的文件清单中
    2) 可以使用命令: `git mv 旧名称 新名称`
       1) 底层实现
          1) `mv 旧名称 新名称`: 把工作目标中的名称进行修改
          2) `git rm 旧名称`: 删除旧名称的信息
             1) 不会删除文件，此时的文件已经该名称
          3) `git add 新名称`: 在暂存区中保存新名称的信息




# 查看提交历史

1. 查看方式
   1) 输入指令: `git log`
   2) 可以得到所有指令的信息，按照时间顺序依次排列
      1) 信息包括: SHA-1 校验和、作者的名字和电子邮件地址、提交时间、提交说明

2. 附带的一些指令选项
   1) `git log -p`: 显示每次提交所引入的差异
   2) `git log -2`: 显示最近两次提交的信息
   3) `git log -p -2`: 示最近两次提交的信息，并得到每次提交所引入的差异



# 撤销操作

1. 重新提交
   1) 描述信息写错了，某个文件还需要进行修改，需要覆盖上次的推送
   2) 使用指令`git commit --amend`
      1) 重新把暂存区中的最新版，提交到Git仓库中，并且覆盖上次提交的，即覆盖最新版本
      2) 会重新打开文本编辑器启动
         1) 可以看到之前的提交信息
         2) 编辑后保存会覆盖原来的提交信息


2. 撤销暂存
   1) 把某个文件的暂存从暂存区中移除，暂存区恢复到该文件上次暂存的样子
   2) 使用指令: `git reset HEAD 文件名或者路径`



3. 把文件恢复到上次暂存时的状态(版本切换)
   1) 使用指令: `git checkout -- 文件名或者路径`




# 分支的介绍

1. Git仓库存储模板的原理
   1) Git仓库中存放的其实是一个一个的对象，并且每个对象间都有联系，**组成链式结构**
   2) 通过对象间的联系，实现版本的切换
   3) Git操作的是文件快照，每个文件对应一个文件快照
   4) Git仓库存放的对象的原理
      1) `blob对象`
         1) 每个文件创建一个对象，对象中保存文件快照的地址索引
         2) 通过该对象，获取快照索引指向的快照，还原版本文件
      2) `树对象`
         1) 该对象可以描述出工作目录，可以看做是按照工作目录的排列方式创建出一个对象
         2) 每个属性代表一个文件，属性之间构成文件的排列方式
         3) 并且每个属性指向文件对象，即`blob对象`
         4) 在切换版本的时候，通过该对象还原工作目录
      3) `提交对象`
         1) 该对象，为真正保存到Git仓库中的对象
         2) 对象中有一个属性，指向树对象
         3) 对象中还有一个属性，指向上次提交的对象
            1) 完成版本的切换
            2) 第一次提交，没有该属性，或者指向空


2. Git分支的原理
   1) Git中的分支，其实就是一段普通的字符，共包含41个字节(40 个字符和1 个换行符)
   2) 默认创建出一个`master分支`和一个`HEAD分支`
      1) 其中，`master分支`就是一个普通的分支
      2) `HEAD分支`非常重要
      3) `HEAD分支`指向当前的分支
   3) 分支指向的就是当前存储的Git对象
      1) 并且往Git仓库中新推送对象后
      2) 当前分支会自动向后移，指向新对象，从而带动`HEAD分支`进行移动
         1) 因为`HEAD分支`指向的是当前的分支
   3) 如果新创建了一个分支，则新创建的分支默认也指向当前存储的Git对象
      1) 与当前的分支，指向同一个Git对象


3. 分支切换的现象
   1) 切换分支，`HEAD分支`指向切换的分支，即当前分支
      1) 如果此时，往Git仓库中新推送了新对象
      2) 当前分支指向移动，从而带动`HEAD分支`的移动
      3) 此时旧分支的指向，是不会变动的，还是之前的Git对象
   2) 当分支又切换到旧分支后，`HEAD分支`指向旧分支，即当前分支
      1) 如果此时，往Git仓库中新推送了新对象
      2) 当前分支指向移动，从而带动`HEAD分支`的移动
         1) 指针都是向后移动的
         2) 此时Git对象的后面已经存在一个Git对象了，新分支添加的对象
            1) 链式结构
         3) 于是又会添加一个属性，指向新的Git对象
            1) 又形成了一个链式结构
            2) 该位置被称为项目分叉
            3) **只要添加Git对象时，`HEAD分支`指向的Git对象的后面存在Git对象**
               1) 就会产生分叉点，重新生成一个链式结构
      3) 其它的分支不动，还是之前的Git对象   



4. Git仓库就是一个非常庞大的树形结构
   1) 上面有一些标记，可以获取到该树形结构中对应的Git对象
      1) 从而获取到对应的模板信息
   2) 这些标记，就是一个一个的分支
      1) 并不是一个一个的分支就是一块子仓库，就是一个普通的标记


5. 切换分支的时候，会自动读取到该分支下的最新模板
   1) 其实是通过`HEAD`获取到当前的分支，它永远指向当前的分支
   2) 当前的分支又指向一个Git对象，该对象相当于最新模板
   3) 通过该Git对象，就可以获取到当前的模板文件
      1) 找到树对象
      2) 然后找到blob对象
      3) 然后找到快照索引
      4) 然后找到快照，生成对应的文件
      5) 按照树对象中的工作目录记录，确定文件的位置
      6) 从而展示出当前分支的最新模板文件


6. 创建一个新分支就相当于往一个文件中写入41 个字节(40 个字符和 1 个换行符)
   1) 这也是Git创建分支非常迅速的原因



# 分支合并的介绍
  
1. 介绍
   1) 开发项目都是新建一个分支
      1) 这样做的好处在于，开发失败后，可以随时回退到开始位置
      2) 切换分支就能实现
         1) 切换到初始分支，根据指向获取的就是初始状态的Git对象
         2) 根据Git对象，找到对应的文件快照，快速还原文件
   2) 当开发完成后，就需要把开发的分支合并到项目分支中去


2. 分支合并的规则介绍
   1) Git中存放的是一个Git对象树
   2) 如果当前分支的指向对象，与将要合并的分支的指向对象，可以顺着Git对象链查询到
      1) 在一条链上，没有产生分叉点
      2) 直接把当前分支的指向，向后移，指向合并分支所指向的Git对象
      3) 并且自定获取该对象代表的模板文件
   3) 如果当前分支的指向对象，与将要合并的分支的指向对象，位于两条独立的分支链上
      1) 即Git对象的前面存在分叉点
      2) 如果两个分支指向的对象没有产生冲突
         1) 根据两条分支指向的对象对应的文件快照，生成一个新的合并后的文件快照
         2) 然后生成一个新的Git对象保存到Git仓库中，当前的分支指向指向新创建的Git对象
         3) 该Git对象，有两个父级对象，分别为合并前两个分支指向的对象
      3) 如果两个分支指向的对象没有产生冲突
         1) **相同文件的相同位置，代码(文件内容)不同**
         2) 此时就会在开发目录，对应的文件中的对应位置，罗列出两个文件的文件内容
         3) 进行选择，手动修改保存那个版本，或者两个版本都保存
         4) 当所有冲突的文件全部修改完成
         5) 需要手动运行add，和commit
            1) 如果没有冲突，该步骤自动完成
         6) 此时才会创建出新的Git对象，并且链条指向，合并前两个分支指向的对象
         7) 当前分支指向，移动到新创建的Git分支中
         8) 处理冲突的过程中，控制台的分支提示变成`(当前分支|MERGING)`
            1) 意思为: 该分支正在处理冲突
            2) 处理完成，运行完commit后，分支提示变为`当前分支`



3. 正常情况下，一个Git对象的**链式结构的上面只有一个Git对象**
   1) 当合并分支的时候，可能产生一个新的Git对象，它的**链式结构的上面存在两个Git对象**


4. 开发分支开发完，并且合并到主分支中去了
   1) 该分支就没有存在的必要了，可以删除掉该分支



# 分支对应的指令


1. 创建分支
   1) 只是创建: `git branch 新分支名`
   2) 创建并切换分支: `git checkout -b 新分支名称`
      1) 相当于: `git branch 新分支名`与`git checkout 新分支名` 联合使用


2. 切换分支
   1) 指令: `git checkout 分支名称`
   2) 切换完分支: 会自动拉取下拉，该分支指向的Git对象代表的模板


3. 合并分支
   1) 指令: `git merge 将要合并的分支名`
   2) 把将要合并的分支所指向的Git对象，与`HEAD`(当前分支)指向的Git对象进行分析合并


4. 删除一个分支
   1) 指令: `git branch -d 分支名`
      1) 该指令只能删除已经合并的分支
      2) 表示当前分支的项目已经合并到其它的分支中，该分支已经没有什么用处了，所以可以删除
      3) 如果删除一个没有进行合并的分支，该指令报错，删除失败
         1) 没有合并的分支，表示当前分支的项目只存在当前分支中，如果删除就找不到了
   2) 指令: `git branch -D 分支名`
      1) 强制删除某个分支，不管该分支有没有被合并




# 分支管理

1. `branch`命令不只是可以创建与删除分支，还可以得到当前所有的分支
   1) 比如: `git branch`，得到所有的分支名，当前的分支前面有个`*`号
   2) 比如: `git branch -v`
      1) 得到所有的分支名，当前的分支前面有个`*`号
      2) 并且后面跟上，对应分支所指向的Git对象的信息
   3) 比如: `git branch --merged`
      1) 得到所有与当前分支进行过合并的分支，**必须是没有删除的分支**
      2) 带`*`号的分支表示当前的分支，其它的分支可以进行删除
      3) 其它分支的功能，已经合并到了当前的分支
   4) 比如: `git branch --no-merged`
      1) 得到所有**没有**与当前分支进行过合并的分支
      2) 带`*`号的分支表示当前的分支，其它的分支不可以进行删除
      3) 如果使用`git branch -D 分支名`强制删除，则对应分支的项目就找不到了



# 分支开发工作流

1. 长期分支
   1) 长期存在的分支，该分支中存放一些稳定的版本


2. 特性分支
   1) 用于开发的分支，只是短期存在
   2) 开发完，把开发完的稳定版本合并到长期分支中
   3) 合并完，把特性分支删除





# 远程分支(远程仓库中的分支)与本地分支的对应关系

1. 远程仓库中的分支，与Git仓库中的分支格式一样
   1) 远程仓库中存放的也是一个Git对象树
   2) 远程仓库中的分支，指向树形结构的末端，对应的Git对象，和本地仓库相同


2. 当克隆仓库的时候，会把该仓库所有的版本都克隆下来，即所有的分支
   1) 由于远程仓库是一个Git对象树，所以克隆下来的是一个完成的Git对象树
      1) 与本地的Git对象树相同
   2) 会把远程仓库的分支信息也克隆下来，指向对应的Git对象
      1) 但是会进行重命名，并且分支名不可以进行重写
      2) 重命名格式: `origin/分支名`，表示远程分支
      3) 并且使用`git branch`指令，查不到这些分支的信息
   3) 克隆下来的仓库，会创建一个本地的分支`master`
      1) 并且指向远程分支`origin/master`指向的Git对象
   4) 并且创建出`HEAD`，指向`master`分支
   5) 默认展示`master分支`指向的Git对象表示的模板
   6) 新建本地分支，初始时指向`HEAD`指向的Git对象
   7) 当运行commit的时候，对应的本地分支开始运动
      1) 远程分支的指向`origin/?`不会发生变化
      2) 该进行分叉的位置进行分叉
   


3. **向远程仓库推送版本**
   1) 通过指令: `git push origin 分支名`，进行推送
   2) 会查询本地对应的分支
      1) 从分支位置开始，沿着链条向上查询，直到查询到链条的末端
      2) 把这一条的Git版本，全部推送到远程仓库中，与远程仓库中的Git对象树进行合并
      3) 相同的Git对象(之前已经推送过)，不动
      4) 新的Git对象，开始向后拼接
   3) 并且远程仓库中的分支指向开始向后移动，移动到链条末端
   4) 虽然远程仓库中的分支指向发生变化
      1) 如果是新克隆一个Git本地仓库，下载的是完成的(最新的Git对象树)
         1) 并且对应的重写的远程分支的指向，都是当前的位置(最新的位置)
      2) 如果是之前克隆的Git本地仓库，不会对重写的远程分支造成影响
         1) 即不会更新，即不会向后移动
         2) 指向的还是，刚拉取下来的Git对象
         3) 不会自动更新，改变指向
   5) 改变之前克隆下来的，本地的，Git仓库中的，重写的，远程分支的指向
      1) 如果两个人同时拉取了一个仓库，另外一个人修改后，进行了重新提交
      2) 另一个人的Git仓库不会发生变化
      3) **可以使用指令: `git fetch origin`**
      4) 会重新拉取远程仓库的Git对象树，与当前的Git对象树进行合并
         1) 相同的不同，没有的新建，可能进行分叉或者延长之前的链
         2) 并且改变当前的Git仓库中的重写的远程分支的指向
         3) 指向最新的对应的版本
   6) **如果想要共享本地的某个分支，可以推送到远程仓库**



4. 重写的远程分支的作用
   1) 重写的远程分支，与远程仓库中的对应的分支，所指向的版本相同
      1) 如果远程仓库发生了更新，本地仓库也可以进行更新，时刻保持指向相同
   2) 虽然它与远程仓库中的分支是对应的关系
   3) 但是它就是一个本地的特殊的分支，我们可以操作它
      1) 比如切换到该分支，查看远程仓库中对应分支的最新版本
      2) **也可以与本地的某个分支进行合并**
         1) 比如两个人同时修改一个分支，但是另一个先进行了推送
         2) 另外一个人，就需要进行合并，否则他推送不上去
            1) 更新Git，获取到，最新的远程分支的指向
            2) 此时在进行分支的合并
               1) 比如: `git merge origin/master`
            3) **如果不进行合并进行提交，会进行拒收**
               1) 克隆时，该分支指向的Git对象，后面已经有新的Git对象了(另外一个人提交的)
               2) 此时他在进行提交，就会产生分叉，但是只有不同的分支才能进行分叉
               3) 同一个分支不允许分叉，所以远程仓库拒收
            4) 合并后，会产生一个新的Git对象，链条的前方有两个Git对象
               1) 一个是另外一个人提交的，一个是当前的
               2) 提交后，链条即产生分叉，也会进行延长，但是最终分叉点会合并到一条链上
               3) 所以可以提交成功，并且分叉的那个链也会进行提交
               4) 原因: 把整个链条提交上去



5. 创建本地分支时，直接在远程分支指向的位置创建
   1) 好处: 沿着对应的远程分支继续开发
   2) 比如: 相对远程仓库中的a分支继续开发，就可以使用该方法
   3) 如果不使用该方法
      1) 对master分支进行开发，功能相同，新创建的分支就是从该位置开始
      2) 其它的分支，新建分支后，还是从master指向的位置创建本地分支
      3) 与对应的远程分支，位于两条链上
      4) 虽然可以进行开发，但是分叉点，距离对应分支指向的位置过远
      5) 如果在对应分支指向的位置，创建分支，即使分叉，也是从对应位置开始分叉
      6) 这样，**树形结构更加合理**
   4) **对应指令: `git checkout -b 新分支名 对应的远程分支名`**
      1) 比如:  `git checkout -b a origin/a`;
      2) 在`origin/a`指向的位置，创建`a`分支
      3) 而不是在`master`指向的位置开始创建分支



6. `git pull`指令的作用
   1) 该指令相当于`git fetch origin`与`git merge origin/对应分支`的合集
   2) 自动更新当前的Git库，更新远程分支的指向(origin/?的指向)
   3) 自动找到运行`git pull`指令的分支，找到对应的`origin/?`分支，与当前的版本进行合并


7. 删除远程仓库中的分支
   1) 对应指令: `git push origin --delete 分支名`
   2) 直接删除远程仓库中的分支
   3) 只是删除该分支的指针，内容还没有删除，可以恢复指针
   4) 时间一长，对应的内容也会被删除掉，此时就很难恢复了



8. 当克隆下来一个远程仓库后，会克隆下来完整的一个Git树形结构，远程仓库中存储的树形结构
   1) 同时也会把远程仓库中的分支克隆下来，并且指向与当时的远程仓库中对应的分支指向相同
   2) 为了防止对应的远程仓库分支，与本地的分支产生冲突，所以进行了重命名
   3) 然后新建一个本地的`master分支`
   4) 此时本地仓库构建完成，就会与远程仓库断了联系
      1) 如果有人对远程仓库中的Git树形结构进行了增加或者删除，不会对当前的仓库的树形结构造成影响
      2) 可以进行手动更新本地仓库，重新拉取远程仓库的属性结构
      3) 新增的结构，在相应的位置进行拼接，删除的位置不动
      4) 只能新增，不能删除





# 变基

1. 作用: 合并分支


2. 具体介绍
   1) 变基与`merge`(分支合并)有些特殊
   2) 具体的指令: `git rebase master server`
   3) 分析:
      1) 把server分支变基到master分支上
      2) 如果server分支，位于master分支的链上，则不作处理
      3) 如果需要合并的分支，位于两条链上
         1) 找到`master分支`与`server分支`的分叉点(功能的分叉点)
         2) 然后顺着分叉点，开始查询`server分支`上的Git对象
         3) 并且与`master分支`指向的Git对象对应的文件快照进行比较
            1) 如果没有冲突，两个快照进行合并，合并完形成一个新的Git对象
               1) 并且新的Git对象的描述信息，与对应的server分支上的Git对象的描述信息相同
               2) 即`git commit -m 描述信息`设置的描述信息
               3) 合并完形成的新的Git对象，放在`maser分支`指向的Git对象的后面
               4) 然后，继续取`server分支`上的Git快照(从分叉点开始的)
               5) 合并完形成的新的Git对象，描述信息不变，继续拼接在`maser分支`的Git对象链上
               6) 直到分析完`server分支`指向的对象
            2) 如果产生了冲突，需要手动设置，与合并分支时的操作相同
               1) 由于是一个一个的Git对象进行比较，所以会一个一个的进行设置
               2) 并且控制台的分支描述，变为`(server|REBASE 1/2)`
               3) 设置完一个，运行`git add .`即可，不用运行`commit`
                  1) 会复用描述信息，自动进行commit的处理
               4) 然后运行: `git rebase --continue`，会继续进行处理
                  1) 处理完: 同样只运行`git add .`
                  2) 然后运行: `git rebase --continue`
               5) 直到控制台的分支提示变为正常，即`server`
                  1) 表示合并完成，同样不用运行`commit`
         4) 处理、合并完成后，`master分支`的链，就会延长
            1) `server分支`从分叉点开始，有多少个版本
            2) `master分支`就延长多少个版本
            3) 并且每个版本都是与`master分支`指向的Git对象合并完的版本
         5) `server分支`的指向，就会从原先的Git对象变为，`master分支`的末端
            1) 即`server分支`指向Git对象版本，与`master分支`指向的Git版本合并完成后的版本
            2) 也就是最终版本
            3) 就相当于`merge`合并完成后的最终版本
            4) **好处在于，这样合并完成的分支，没有分叉点、合成点，就是单独的一条线**
      4) 变基完成后，切换到`master分支`，让它合并`server分支`即可   
         1) 可以使用: `git merge server`
         2) 由于经过变基后，这两条分支已经位于同一个链条下
         3) `master分支`只是向后移动一下指向位置
         4) 移动完成后，就可以把`server分支`删除掉


3. 使用完变基合并的分支，与合并的分支(旧分支)没有链条关系了
   1) 单独处理，形成了新的版本信息，依次拼接到`master分支`上
   2) 这样的链条，更加清晰，更加简洁
   3) 一条链干到底，并且还能清晰的感知合并分支的开发过程
      1) 因为，都已经合并过来了
   4) `merge`进行分支的合并
      1) 只合并两个分支当前指向的Git对象，然后创建一个新的Git对象
      2) 新的Git对象的链条的上端继承，这两个Git对象
      3) 所以，它还是与合并分支的链条(旧链条相关)
      4) 并且一个分支的链条上，分叉了两个链条，然后在合并为一个
      5) 此时链条结构就比较混乱，如果一个长一个短(合并的分支多开发了几个版本)，更加混乱



4. `git rebase --onto master server client`的作用
   1) 分析
      1) 查到`client`与`server`分支的交叉点
      2) 然后顺着`client`的分支开始查询
      3) 与`master分支`当前的指向，进行合并成一个新的Git对象
      4) 然后拼接到`master分支`上
      5) 最终改变`client分支`的指向，指向`master分支链`上合并产生的最新版本
      6) **不是从client与master分支的交叉点开始查询**
   2) 处理完成后，移动`master分支`的指向
      1) 指向合并的最新版本
      2) 指令: `git checkout master`
      3) 合并分支: `git merge client`，由于在一条链上，直接移动指针，改变指向
   3) 移动完指针后，如果`server分支`开发完成，也可以变基合并到`master分支`上
      1) 首先切换到`server分支`进行变基
      2) 变基: `git rebase master server`;
      3) 指令: `git checkout master`
      4) 合并分支: `git merge server`，由于在一条链上，直接移动指针，改变指向
   4) 适用场景
      1) 新创建了一个`server分支`，开发了几个版本，又新创建了一个`client分支`
      2) 此时，如果client开发完成，需要合并到`master分支`上
      3) 如果以`master分支`与`client分支`的交叉点进行变基合并
      4) 会找到`server分支`上的部分版本，与`client分支`分叉前的版本，进行合并处理
      5) 如果此时`server分支`也开发完成，进行变基操作
         1) 只能以`master分支`与`server分支`的交叉点进行处理
         2) 这样就会重复处理几个版本，造成`master分支`的链条过长
      6) 由于`client分支`功能的起点，就是以`server分支`的分叉点开始的
         1) 分叉前的功能都存在
      7) 可以以`client分支`与`server分支`的交叉点开始分析
         1) 不会造成分叉前功能的缺失



5. 注意点
   1) 变基只能操作本地的分支，变基完合并到远程仓库中对应的分支中
      1) 不会对远程仓库造成分支的改变，这样别人更新本地仓库的时候，没有影响
   2) 如果使用变基操作了远程分支，合并了几个分支，删除了几个分支
      1) 这样别人更新本地仓库的时候，之前下载的远程仓库结构不会发生变化
      2) 变基新创建的结构也会下载下来，即参与变基合并的版本，不会删除
      3) 这样变基操作操作的过于频繁，对更新本地仓库的影响越大
      4) 本地仓库的树形结构会越来越乱




# 交互式暂存

1. 介绍
   1) 往暂存区中暂存文件
   2) 相当于: `git add .`
   3) 只不过暂存变得可控，即出现一个控制界面
   4) 甚至可以撤销暂存操作



2. 具体操作
   1) 输入命令: `git add -i`或者`git add --interactive`
   2) 会出现一个没有进行暂存的文件列表，列表共两列
      1) 第二列，文件名前面有类似`+0/-7`标记，表示该文件没有暂存
      2) 并且控制台提示`What now>>`，然后陷入等待过程
   3) 在控制台提示`What now>>`的时候，输入`2`或者`u`，进入暂存阶段
      1) 此时控制台的提示变为: `Update>>`
      2) 想要暂存那个文件，就输入那个文件的序号，在提示信息的最左侧
      3) 输入序号后，敲击回车键，选中该文件，则该文件的序号前面出现`*`
      4) 此时控制台依旧处于`Update>>`，可以继续选中要暂存的文件
      5) 如果什么都不选，直接敲击回车键，则会暂存上面步骤选中的文件
      6) 并且控制台提示变为`What now>>`，可以继续进行其他的操作
      7) 此时打印文件的暂存列表，发现第二列，类似`+0/-7`的标记变为`nothing`，表示该文件已经暂存
   4) 在控制台提示`What now>>`的时候，输入`3`或者`r`，进入取消暂存阶段
      1) 只能取消，在交互式暂存的过程中，进行暂存的文件
      2) 此时控制台的提示变为: `Revert>>`
      3) 想要取消那个文件的暂存状态，也是填入对应文件的序号，在提示信息的最左侧
      4) 输入序号后，敲击回车键，选中该文件，则该文件的序号前面出现`*`
      5) 可以继续选中，填写序号
      6) 如果什么都不选，直接敲击回车键，则会取消上面步骤选中的文件的暂存状态
      6) 并且控制台提示变为`What now>>`，可以继续进行其他的操作
      7) 此时打印文件的暂存列表，发现第二列，`nothing`的标记又恢复成原样，表示该文件没有被暂存
   5) 在控制台提示`What now>>`的时候，输入`1`，打印出文件暂存信息列表
      1) 通常，进行完某个操作，比如暂存或者取消暂存后，再次查看一下文件状态
      2) 看看是否操作成功
   6) 在控制台提示`What now>>`的时候，输入`6`或者`d`，进入查询暂存文件内容的阶段
      1) 控制台的提示变为`Review diff>>`
      2) 后面跟上要查看的文件的序号，在列表信息的最左侧
      3) 输入序号后，敲击回车键，立马打印出选中文件进行暂存的文件内容
      4) 打印完成后，控制台提示切换为`What now>>`
      5) 如果想要查看多个文件的信息，序号中间用`,`号隔开
      6) 需要注意，如果没有文件进行过暂存操作，该阶段是进不去的