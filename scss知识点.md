

# 介绍以及优点

1. 完全兼容 CSS3
2. 在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能
3. 通过函数进行颜色值与属性值的运算
4. 提供控制指令 (control directives)等高级功能
5. 自定义输出格式





# 选择器嵌套

1. 作用
   1) 避免了重复输入父选择器
   2) 令复杂的 CSS 结构更易于管理


2. 代码示范
```scss
.a {
    width: 100px;
    .b {
        .c {
            width: 100px;
        }
    }
}

// 解析 为正常的css样式如下
.a {
    width: 100px;
}
.a .b .c {
    width: 100px;
}
```



# 父选择器 &

1. 作用
   1) 简写选择器
   2) 不会出现嵌套现象，发生的是替换现象
   3) **通常与伪元素连用**


2. 注意点
   1) `&` 必须写在开头


3. 代码分析
```scss
.a {
    // 简写选择器中，存在父级字符串
    &--block {
        width: 100px;
    }
    & {
        width: 100px;
    }
    .b {
        // 与伪元素连用
        &::after {
            width: 100px;
        }
    }
}

// 解析 为正常的css样式如下
.a--block {
    width: 100px;
}
.a {
    width: 100px;
}
.a .b::after {
    width: 100px;
}

// &不会进行嵌套，而是直接替换为父级选择器
// 最终解析为 .a--block ， 而不是 .a .a--block
// 相当于与父级选择器同级，而不是子级
// 写在父级的 {} 中，并不是父子级关系，而是在书面上增加联系，便于管理
```





# 属性嵌套

1. 作用
   1) 简写属性


2. 代码分析
```scss
.a {
    .b {
        abc: {
            dd: 123
        }  
    }

    .c {
        // 常用
        font: {
            size: 14px;
            family: fantasy;
        }
    }
    
    .d {
        .e {
            // 可以有自己的属性
            font: 14px {
                weight: 700
            }
        }
    }
}

// 解析 为正常的css样式如下
.a .b {
    abc-dd: 123
}
.a .c {
    font-size: 14px;
    font-family: fantasy;
}
.a .d .e {
    font: 14px;
    font-weight: 700;
}

// 并不作为选择器，而是与内部的所有属性进行拼接
// 使用 - 进行拼接
```






# 变量的使用

1. 作用
   1) 提取相同的css样式
   2) 当发生变化时，可以修改变量
   3) 就可以影响，所有使用该变量的css样式
   4) 不用一个一个的修改css样式


2. 变量的声明
   1) 通过 `$` 进行声明变量， `:` 相当于等号
   2) 比如: `$color: #f0f;`


3. 变量的使用
   1) 选择器使用: 通过`#{}`进行调用，比如: `#{ $color }`
   2) css属性使用: 直接使用，比如: `color: $color`


4. 变量的重新赋值
   1) 只要在声明变量的后面，再次使用`$?: ?`就可以对变量进行重新赋值
   2) 和js的原理一样


5. 代码分析
```scss
$color: #f0f;
$a: cc;

.a {
    // 选择器使用变量
    .b-#{$a}-d {
        // css属性使用变量
        color: $color
    }
}

// 解析 为正常的css样式如下
.a .b-cc-d {
    color: #f0f;
}
```





# 变量为数字类型的书写方式

1. 常见的数字种类: 1, 2, 13, 10px, 5em

2. 代码分析
```scss
$a: 14px;
$b: 5em;
.a {
    width: $a;
    font-size: $b;
}

// 解析 为正常的css样式如下
.a {
    width: 14px;
    font-size: 5em;
}
```





# 变量为字符串类型的书写方式

1. 字符串有两种写法
   1) 有引号字符串，比如: "ABC"
   2) 无引号字符串，比如: ABC


2. 有引号字符串和无引号字符串的差别
   1) css属性引用，分为有引号和无引号
   2) 选择器引用，有引号会转换为无引号


3. 代码分析
```scss
$a: "abc";
$b: abc;
.a {
    .b-#{$a}-#{$b} {
        content: $a;
        content: $b;
    }
}

// 解析 为正常的css样式如下
.a {
    // 选择器引用，会把有引号字符串转换成无引号字符串
    .b-abc-abc {
        // css属性引用，不会发生有引号和无引号的转换
        content: "abc";
        content: abc;
    }
}
```
   




# 变量为数组类型的书写方式

1. 声明的方式
   1) 使用空格隔开
      1) 比如: 1 2 3 4
      2) 相当于: [1, 2, 3, 4]
   2) 使用逗号隔开
      1) 比如: 1, 2, 3, 4
      2) 相当于: [1, 2, 3, 4]
   3) 使用()进行包裹
      1) 一个()表示一个数组，数组中的每一项还是用空格或者逗号隔开
      2) 比如: (1 2 3 4)
      3) 相当于: [1, 2, 3, 4]
   4) 声明多维数组
      1) 数组中存在两种隔开方式，认为是多维数组
         1) 比如: `1 2,3 4`或者`1,2 3,4` ，相当于: `[[1, 2], [3, 4]]`
      2) 或者数组的每一项使用()进行包裹
         1) 比如: `(1 2) (3 4)`或者`(1 2),(3 4)`等等 ，相当于: `[[1, 2], [3, 4]]`


2. 其实每一个数据都是一个单项数组
   1) 比如: `$color: #f0f;`，相当于: `$color = [#f0f]`
   2) 比如: `1 2 3 4`，相当于: `[[1], [2], [3], [4]]`
   3) 所以: **单个数据，也能使用scss提供的一些操作数组的方法，进行操作**



3. 数组的最后可以加 `,`
   1) 比如: `(1,)`，代表 `[1]`，而不是`[1, undefined]`，即`,`会自动忽略
   2) 作用: 强调数组的结构关系



4. 数组中存在空值，会自动忽略
   1) 比如: `(1, 2, (), 3)` 或者 `(1, 2, null, 3)`
   2) 最终解析为: `(1, 2, 3)`，即中间的空值`()`或者`null`会忽略掉





# 变量为颜色的书写方式

1. 颜色在css中有三种写法
   1) 一种: 对应的英文单词
   2) 一种: #fff
   3) 一种: rgb() 或者 rgba()

2. 在声明颜色时，也可以使用这三种方法
   1) 比如: `$color: #f0f;`或者`$color: rgba(255, 0, 255, 0.5)`






# 变量为布尔类型的书写方式

1. 直接写成: `$boo: false` 或者 `$boo: true`





# 变量为空的书写方式

1. 直接写成: `$boo: null;`





# 数字运算

1. scss支持数字的加、减、乘、除、取整等运算，即`+`、`-`、`*`、`/`、`%`

2. 如果运算符号两侧的**单位不同，会进行转换**
   1) 即: `1px + 2` 转换成 `1px + 2px = 3px`;

3. 百分号也可以参与运算，运算结果依旧为百分数
   1) 比如: `5 / 10 * 100%` 运算完为`50%`，而不是`0.5`


4. `/`号运算比较特殊
   1) 在css中 `/` 存在特殊的意义，即分隔数字的作用
      1) 比如: `10px / 5px`，解析完还是`10px / 5px`，并不会解析成 `2px`
      2) 只是起一个数据间的分隔作用
   2) **只有在特殊情况下，`/`才会进行除法运算**
      1) 表达式中存在变量、或者函数引用，会进行除法运算
         1) 比如: `1px / $a` 或者 `a() / 5px` 
      2) 表达式被圆括号包裹
         1) 比如: `(10px / 5px)`，会参与运算，结果为`2px`
      3) 表达式中存在其他的运算符号
         1) 比如: `10px / 5px * 2px`，结果为`4px`
   3) 如果符合特殊情况，但是也不想`/`参与运算，可以使用`#{}`进行处理
      1) 比如: `$a / 2`，存在变量引用，所以会进行运算
      2) 如果把变量引用通过`#{}`进行处理，比如: `#{$a} / 2`，就不会进行运算
      3) 如果`$a = 3`，结果为 `3 / 2`，不进行运算，只是分隔数据






# 颜色运算

1. 特殊性
   1) 颜色比较特殊，由三段颜色代码，即红、绿、蓝组合而成
   2) 所以在运算时，也分为三段进行运算，然后在形成完整的颜色代码


2. 运算分析
   1) 比如: `#010203 + #020304`，运算完结果为: `#030507`
      1) 分析: 分段运算，即红和红运算，绿和绿运算，蓝和蓝运算
   2) 比如: `#010203 * 2`，运算完结果为: `#020406`
      1) 分析: 分段运算，即红乘，绿乘，蓝乘
   3) `rgba`中的透明度不会参与运算
      1) 比如: `rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75)`
      2) 运算结果为: `rgba(255, 255, 0, 0.75);`
      3) 只有颜色参与运算
   4) 要想运算透明度，需要借助两个函数，scss内部提供的两个函数
      1) `opacify`函数
         1) 使用方法: `color: opacify(rgba(255, 0, 0, 0.5), 0.3)`
         2) 得到的结果为: `color: rgba(255, 0, 0, 0.8)`
         3) 相当于，**对透明度做加法运算**
      2) `transparentize`函数
         1) 使用方法: `color: transparentize(rgba(255, 0, 0, 0.5), 0.3)`
         2) 得到的结果为: `color: rgba(255, 0, 0, 0.2)`
         3) 相当于，**对透明度做减法运算**


3. 无论颜色运算还是透明度运算，结果都**无法超过最大值或者最小值**
   1) 比如透明度: `0.5 - 0.8`结果小于0，最终结果为0
      1) 如果运算结果大于1，结果为1
   2) 比如颜色: `#0000f1 + #0001f2`，运算结果为`#0001ff`
      1) 分段运算，蓝色段运算完，超过了`ff`，不会向前进位，蓝色段最终结果为`ff`




# 字符串运算

1. `+` 可用于连接字符串
   1) 无引号字符串的拼接
      1) 比如: `cursor: e + -resize;`
      2) 编译为: `cursor: e-resize;` 
   2) 有引号字符串的拼接
      1) 比如: `cursor: "e" + "-resize";`
      2) 编译为: `cursor: "e-resize";` 
   3) 注意
      1) 如果`+`的左侧是有引号字符串，右侧为无引号字符串，运算结果是有引号字符串
         1) 比如: `content: "Foo " + Bar;`
         2) 编译为: `content: "Foo Bar";`
      1) 如果`+`的左侧是无引号字符串，右侧为有引号字符串，运算结果是无引号字符串
         1) 比如: `content: Foo + " Bar";`
         2) 编译为: `content: Foo Bar;`



2. 运算表达式与其他值连用时，用空格做连接符
   1) 比如: `margin: 3px + 4px auto;`
   2) 编译为: `margin: 7px auto;`


3. 在有引号的文本字符串中使用 `#{}` 插值语句可以添加动态的值
   1) 比如: `content: "I ate #{5 + 10} pies!";`
   2) 编译为: `content: "I ate 15 pies!";` 
   3) 如果`#{}`中插入的为空值，比如null，则相当于插入空字符串，即`""`





# 圆括号

1. 作用
   1) 声明数组
   2) 改变运算的顺序


2. 分析
   1) 比如: `width: 1em + (2em * 3);`
   2) 编译为: `width: 7em;`




# #{}的作用


1. 引用数据
   1) 选择器只能使用该方法引用数据
   2) 凡是可以通过`$?`引用数据的地方，都可以通过`#{$?}`进行引用
2. 禁止 `/` 进行除法运算




# !default解决变量重新赋值的问题

1. 作用
   1) 如果变量已经赋过值了，不在重新赋值
   2) 如果之前的变量值为空，则重新赋值


2. 使用
   1) 变量有值的情况
      1) 比如: `$content: "First content";`
      2) 重新赋值: `$content: "Second content?" !default;`
      3) 则`$content`依旧为`"First content"`，不会重新赋值为`"Second content?"`
      4) 如果没有使用`!default`，会进行重新赋值
   2) 变量为空的情况
      1) 比如: `$content: null;`
      2) 重新赋值: `$content: "Second content?" !default;`
      3) 则`$content`重新赋值为`"Second content?"`
      4) 之前变量值为`null`，为空重新赋值






# @import的使用

1. scss中重写了`@import`，不光可以引入css文件，也可以引入scss文件


2. scss中@import的功能
   1) 不做任何处理的情况，即`@import`的原始功能
      1) 原样解析为css，不进行引入，在css运行时，在进行引入
      2) 具体情况
         1) 引入的文件拓展名是 `.css`
         2) 引入的文件名以 `http://` 开头
         3) 引入的文件名是 `url()`
   2) 引入的文件后缀名为`.scss`
      1) 在打包过程中，引入文件，进行分析
         1) 相当于把scss文件中的代码，复制一份，放到该位置
         2) 然后在解析成对应的css
      2) 解析完成的css中，没有引入`.scss`的`@import`语句，被替换掉了
         1) 所以，对应的scss文件的引入，发生在打包过程
         2) 而webpack的打包过程，发生在node环境下
         3) 然后，把对应的scss文件通过fs读取出来，插入到对应的位置，然后在进行scss的分析
         4) 所以，相当于复制粘贴
   3) 如果没有写后缀名，会自动拼接为`.scss`后缀名，然后在进行引入
   4) `@import`可以一次引入多个scss文件
      1) 相当于把多个scss文件中的代码，复制一份，放到该位置，然后进行分析
      2) 引入多个文件的方式: `@import "a", "b";`
         1) 没写后缀名，会自动拼接，相当于: `@import "a.scss", "b.scss";`
   5) 由于，引入scss文件，相当于把scss文件中的代码，复制一份，放到对应的位置
      1) **所以被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用**


3. 引入的scss文件代码，会打包到一个css中
   1) 由于@import引入scss相当于复制粘贴
   2) 所以，会打包到一个css中



4. 不编译引入的scss文件
   1) 在对应的scss的文件名前面加上`_`
   2) 导入语句中不需要添加下划线
   3) 比如: 将文件命名为 `_colors.scss`
   4) 导入语句: `@import "./colors";`，不需要添加`_`，并且不能添加后缀名
      1) 正常情况下，把colors.scss中的代码读取出来，然后插入到对应的位置，在进行分析
      2) 多少个文件引入，就读取多少次，然后放入对应的文件中，进行分析
      3) 不足: 同一个scss文件中的代码，会在不同的文件中多次解析
      4) 使用了`_`，在引入时，不在进行读取解析
         1) 而是，对应的文件形成一个css
         2) 然后对应的引入，会替换成: `@import url(路径.css);`
         3) 避免了重复解析
   5) 注意
      1) 不可以同时存在添加下划线与未添加下划线的同名文件，否则添加下划线的文件将会被忽略。

5. 嵌入`@import`，加上选择器限制
   1) 比如: `#main { @import "./a"; }`      
      1) a.scss中的代码: `.a { color: #f0f; }`
   2) 解析过程
      1) a.scss中的代码，替换该文件的引入
      2) 即`.a { color: #f0f; }`替换`@import "./a";`
      3) 表现形式: `#main { .a { color: #f0f; } }`  
      4) 然后，按照scss进行解析，解析为 `#main .a { color: #f0f; }`       
   3) 不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 `@import`







# @media的使用


1. `@media`在css中，是处理响应式的关键词

2. 在scss中，`@media`允许嵌套使用
   1) 编译时，`@media` 将被编译到文件的最外层，包含嵌套的父选择器
   2) 比如: 
   ```scss
   .sidebar {
       width: 300px;
       .a {
           @media (max-width:500px) {
               width: 500px;
           }
       }
   }

   // 编译为
   .sidebar {
       width: 300px; 
   }
   @media (max-width:500px) {
       .sidebar .a{
           width: 500px; 
       }
   }
   // 其它样式，正常解析
   // 遇到@media，会向外提，内部填写的样式，继续放在父选择器中
   ```
   3) 作用
      1) 可以更好的描述出，某个父级选择器下的某个选择器
      2) 在某个响应式中，所表现的形式
      3) 可以一个整体写下来，使scss的父子级选择器更加清楚
      4) 不用单独把@media写在外面，搞得和某个父级选择器的联系不容易看出来
      ```scss
      @media (max-width: 200px) {
         .a {
            .b {
               width: 100px;
            }
         }
      }
      @media (max-width: 500px) {
         .a {
            .b {
               width: 300px;
            }
         }
      }

      // 上面的结构，之间的联系不是很强

      .a {
         .b {
             @media (max-width: 200px) {
                 width: 100px;
             }
             @media (max-width: 500px) {
                 width: 300px;
             }
         }
      }

      // 上面的结构，可以更加清晰的看出.a .b在不同响应式下的关系
      // 不足之处在于，其它结构想要使用@media响应式，即使条件相同，也需要重新写@media
      // 如果@media在最外层，可以写在内部
      // 也就是说，一个结构对应一个@media，即使条件相同，也无法混写使用
      // 在书面上，简化了理解的难度，如果写在一个@media中，难免过于混乱
      ```



3. `@media`允许互相嵌套使用，编译时，会自动添加 `and`
   1) 比如:
   ```scss
   @media (max-width: 200px) {
       .sidebar {
           @media (min-width: 500px) {
               width: 500px;
           }
       }
   }

   // 解析完，内部的@media自动向外提，然后与外界的@media进行合并，添加add
   @media (max-width: 200px) and (min-width: 500px) {
       .sidebar {
           width: 500px; 
       } 
   }
   ```


4. `@media` 甚至可以使用 `变量`、`函数`、`运算符`，来得到条件的名称或者值
   1) 比如：
   ```scss
   $media: screen;
   $feature: max-width;
   $value: 200px;

   @media #{$media} and ($feature: $value) {
       .sidebar {
           width: 500px;
       }
   }
   
   // 编译为
   @media screen and (max-width: 200px) {
       .sidebar {
           width: 500px; 
       } 
   }
   ```






# @extend的使用(延伸)

1. 作用
   1) 实现css的继承


2. 使用方式
```scss
.a {
    color: #f0f;
    .c {
        background: #000;
    }
}

.b {
    // .b继承.a中的所有属性
    @extend .a;
    font-size: 14px;
}

.d {
    // .d继承.c中的所有属性
    @extend .c;
    font-size: 14px;
}

/*
相当于
.a, b {
   color: #f0f;
   .c, .d {
      background: #000;
   }
}

.b {
   font-size: 14px;
}
*/


// 解析后
.a, .b {
  color: #f0f;
}

.a .c, .b .c, .a .d, .b .d {
  background: #000;
}

.b {
  font-size: 14px;
}

.d {
  font-size: 14px;
}
```



3. 优点，也是解决的问题
   1) 比如: 某些元素存在基础样式: `.a{}`，存在特殊样式: `.b{}`
   2) 有的元素存在基础样式，有的元素存在特殊样式和基础样式
   3) 但是存在特殊样式的元素，必须添加两个class名，一个a一个b
   4) 如果使用了`@extend`，b进行了继承。相当于基础样式变成了`.a, .b{}`
   5) 这样的话，class为b，就已经包含了基础样式，不必在借助class为a



4. @extend的作用就像延伸
   1) 本来一个人负责一件事，另一个人负责另外一件事
   2) 如果想要完成两件事，就需要通过两个人
   3) @extend的作用，就相当于把一个人做的事(功能)，延伸到另外一个人身上
      1) 即，另外一个人可以完成两件事
      2) 这样，想要完成两件事，就不需要通过两个人，只需要通过一个人就可以完成




# @at-root的作用

1. 作用
   1) 把样式提到全局中去，而不是嵌套在其父选择器下
   2) 虽然在scss中，与父选择器属于嵌套关系


2. 代码分析
```scss
.a {
    color: #f0f;
    .c {
        @at-root {
            .dd {
                color: #123;
            }
        }
        background: #000;
    }
}

/*
相当于
.a {
    color: #f0f;
    .c {
        background: #000;
    }
}

把@at-root后的代码提到全局中去，不在属于父级的嵌套
.dd {
    color: #123;
}
*/


// 解析为
.a {
  color: #f0f;
}

.a .c {
  background: #000;
}

// 不在嵌套父级选择器 .a .c
.dd {
  color: #123;
}
```



3. `@at-root`后面还可以跟父级选择器
   1) 代码分析
   ```scss
   .a {
      color: #f0f;
      @at-root .bs{
         .dd {
            color: #123;
         }
      }
   }

   /*
   相当于
   .a {
      color: #f0f;
   }

   把@at-root向外提
   .bs{
      .dd {
         color: #123;
      }
   }
   */

   // 解析为
   .a {
      color: #f0f;
   }

   .bs .dd {
      color: #123;
   }
   ```


4. `@at-root`与`@media`使用
   1) 如果不做任何处理，`@at-root`是提取不到`@media`的外面的
      1) 还是受`@media`所控制
      2) 比如:
      ```scss
      .a {
         color: #f0f;
         @media (max-width: 500px) {
            .c {
               width: 500px;
            }
            @at-root .bs{
               .dd {
                  color: #123;
               }
            }
         }
      }

      // 解析时，@media的内部向外提，即.c和.bs向外提
      // .c还是受.a的控制
      // .bs由于被@at-root标记，所以不受父级控制，即不受.a控制，但是受@media的控制
      // 解析为
      .a {
         color: #f0f;
      }

      @media (max-width: 500px) {
         // 受父级选择器控制
         .a .c {
            width: 500px;
         }
         // 不受父级选择器控制，但是受@media的控制
         .bs .dd {
            color: #123;
         }
      }
      ```
   2) 如果`@at-root`后面加上`(without: media)`，`@at-root`就会提取到`@media`的外面
      1) 不受`@media`所控制
      2) 比如:
      ```scss
      .a {
         color: #f0f;
         @media (max-width: 500px) {
            .c {
               width: 500px;
            }
            @at-root (without: media) .bs{
               .dd {
                  color: #123;
               }
            }
         }
      }

      // 解析时，@media的内部向外提，即.c和.bs向外提
      // .c还是受.a的控制
      // .bs由于被@at-root标记，继续向外提，由于加上了(without: media)
      // 所以会提取到@media的外面
      // 解析为
      .a {
         color: #f0f;
      }

      @media (max-width: 500px) {
         // 受父级选择器控制
         .a .c {
            width: 500px;
         }
      }
      // 不受父级选择器控制，也不受@media的控制
      .bs .dd {
         color: #123;
      }
      ```







# if指令

1. 作用
   1) 起判断功能，根据判断条件添加样式


2. 使用
   1) 与js一样，也分为三个指令: `@if`、`@else if`、`@else`
   2) 并且功能与js的相同
      1) 当 `@if` 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码
      2) 如果不成立，有`@else if`就看，该判断的条件是否成立
      3) 如果不成立，有`@else`，就输出 {} 内的代码
   3) 这三个指令必须写在一块，与js一样，中间不能有其它的语句隔断


3. 代码分析
```scss
.a {
   // 没有绝对等于，即 === 
   @if 1 + 1 == 3 { color: #f0f; }
   @else if 1 + 1 == 2 { color: #0ff; }
   @else { color: #ff0; }
}


// 只有@else if的条件成立
// 解析为
.a {
  color: #0ff;
}
```






# for指令

1. 作用
   1) 在限制的范围内重复输出


2. 使用
   1) `@for $? from ? through ?`
   2) `@for $? from ? to ?`
   3) `$?`，表示每次循环，得到的数据
   4) `from`后面跟的数据，表示循环的起点
   5) `through`和`to`，表示循环的终点，区别在于`through`包含终点，`to`不包含终点
      1) 即小于等于、小于的关系


3. 代码分析
```scss
@for $i from 1 through 3 {
   // 选择器，要使用#{}引用数据
   .item-#{$i} { 
      width: 2em * $i; 
   }
}

// 编译为
.item-1 {
   width: 2em; 
}
.item-2 {
   width: 4em; 
}
.item-3 {
   width: 6em; 
}
```






# each指令

1. 作用
   1) 主要用来遍历数组
 

2. 使用
   1) `@each $? in ?`
   2) 其中$?是遍历得到的数据，? 表示将要遍历的数组



3. 代码分析
```scss
// 定义一个数组
$arr: 1 2 3;
// 也可以直接把数组1 2 3，写在in的后面，即@each $prop in 1 2 3;
@each $prop in $arr {
    .a#{$prop} {
        font-size: 5px * $prop;
    }
}


// 解析为
.a1 {
  font-size: 5px;
}
.a2 {
  font-size: 10px;
}
.a3 {
  font-size: 15px;
}
```


4. 遍历多维数组
   1) 可以使用两次`@each`，进行嵌套使用
   2) 也可以定义多个变量，进行接收，比如:
   ```scss
   $arr: (1 2) (3 4);

   @each $a, $b in $arr {
      .a#{$a} {
         a: $a;
         b: $b;
      }
   }

   // 多个变量必须用 , 号隔开。不能使用空格或者()，用来定义数组的方式进行定义
   // 第一次遍历，得到的是 1 2 数组，则$a对应1，$b对应2
   // 第二次遍历，得到的是 3 4 数组，则$a对应3，$b对应4
   // 即使每次得到的数组，数据个数超过了变量个数，也只取对应位数的数据，其它的数据忽略
   // 如果只有一个变量，则接收的就是一个完整的数组，即 1 2 和 3 4

   // 解析为
   .a1 {
      a: 1;
      b: 2;
   }

   .a3 {
      a: 3;
      b: 4;
   }
   ```



5. `@each`还可以遍历键值对，即对象
   1) 需要使用两个属性进行接收，第一个属性接收键名，第二个属性接收键值
      1) 虽然写的是 ?: ?
      2) 但是遍历出的格式为: ? ?，即数组格式
      3) 如果只写一个属性进行接收，每次接收的都是 ? ? 这种格式
      4) 使用两个属性，就可以对应接收数据
   2) 代码分析
   ```scss
   // 定义一个键值对数据
   $arr: (k1: 100px, k2: 200px);
   @each $k, $p in $arr {
      .a-#{$k} {
         font-size: $p;
      }
   }
   
   // 解析为
   .a-k1 {
     font-size: 100px;
   }
   
   .a-k2 {
     font-size: 200px;
   }
   ```






# while指令

1. 作用
   1) 重复生成一段格式的样式代码
   2) 直到表达式的返回结果为false，退出循环


2. 代码分析
```scss
$i: 6;
@while $i > 0 {
   .item-#{$i} { 
      width: 2em * $i; 
   }
   // 变量重新赋值
   $i: $i - 2;
}

// 解析为
.item-6 {
   width: 12em; 
}
.item-4 {
   width: 8em; 
}
.item-2 {
   width: 4em; 
}
```







# 混合样式

1. 作用
   1) 提取重复样式，减少重复样式的书写
   2) 和`@import ?`的功能相似，都是提取公共的样式
   3) 混合样式可以传入参数，甚至插入样式，使用起来更加方便


2. 混合样式的定义
   1) 通过`@mixin`进行定义，后面跟上该`@mixin`的名称
   2) 比如: `@mixin a {}`
   3) {}内填写的，就是样式代码，最终会复制到引用的位置，进行解析


3. 混合样式的引用
   1) 通过`@include 混合样式名`，引用定义好的混合样式


4. 代码分析
```scss
// 定义混合样式，混合样式名为a
@mixin a {
   // 混合样式的内部，书写的就是scss样式代码
   .a {
      color: #f0f;
      @at-root {
         .c {
            color: #00f;
         }
      }
   }
}
// 嵌套使用
.dd {
   @include a;
}
// 最外界使用
@include a;

// 引用混合样式，就相当于把混合样式{}中书写的样式，复制放到引用的位置进行分析
// 嵌套使用解析完
.dd .a {
   color: #f0f;
}
.c {
   // c向外提
   color: #00f;
}

// 外界引用解析完
.a {
   color: #f0f;
}
.c {
   // c向外提
   color: #00f;
}

```

5. 混合样式的嵌套
   1) `@mixin`中，可以使用`@include`继续引用混合样式，原理一样
   2) 比如: 
   ```scss
   @mixin compound {
      // 引入其他的混合样式
      @include a;
      // 引入其他的混合样式
      @include b;
      .b {
         // 继续引入混合样式
         @include c;   
      }
   }
   ```

6. 给混合样式传递参数
   1) 和函数传参一样
   2) 代码分析:
   ```scss
   // 设置混合样式，($color, $width)中定义的就是接收的参数
   // 其中，$width赋默认值，如果没有传递第二个参数，就使用默认值
   @mixin a($color, $width: 200px) {
      .web {
         color: $color;
         width: $width;
         display: block;
      }
   }
   // 使用混合样式并传入参数
   .dd {
      @include a(#f0f, 500px);
   }
   // 使用混合样式，不传入第二个参数
   .cc { 
      @include a(#f0f); 
   }
      
   // 编译为
   .dd .web {
      color: #f0f;
      width: 500px;
      display: block;
   }
   .cc .web {
      color: #f0f;
      width: 200px;
      display: block;
   }
   ```



7. 指定参数传入
   1) 和传入对象一个原理，以键值对的方式传入
   2) 键名，与混合样式接收的参数的属性名对应起来
   3) 可以打乱传递顺序
   4) 比如:
   ```scss
   @mixin a($color, $width: 200px) {
      .web {
         color: $color;
         width: $width;
         display: block;
      }
   }
   .dd {
      // 可以打乱顺序传递，没有对应的属性，就使用默认值
      @include a($width: 300px, $color: #f0f);
   }

   // 解析为
   .dd .web {
      color: #f0f;
      width: 300px;
      display: block;
   }
   ```


8. 类似...运算符的功能
   1) 可以展开一个数组，进行传递
   2) 接收的数据，也放入一个数组中
   3) 代码分析
   ```scss
   @mixin a($color, $width: 200px) {
      .a {
         color: $color;
         width: $width;
         display: block;
      }
   }
   @mixin b($arr...) {
      // 接收的也是一个数组格式，并且是 ?, ? 的形式
      .b {
         width: $arr;
         @include a($arr...);
      }
   }
   // 定义一个数组
   $arr: #f0f 500px;
   .dd {
      // 把数组展开传递
      @include b($arr...);
   }

   // 解析为
   .dd .b {
      // 如果直接使用$arr进行赋值，所赋的就是?, ? 的形式，即接收的形式
      width: #f0f, 500px;
   }
   .dd .b .a {
      color: #f0f;
      width: 500px;
      display: block;
   }
   ```



# 函数指令

1. 使用方式
   1) 定义函数，通过`@function`进行声明
   2) 通过`@return`，进行数据的返回


2. 代码分析
```scss
@function a($data) {
   @return $data + 200;
}
.a {
   // 调用函数，传入参数
   font-size: a(200px);
}

// 解析为
.a {
   font-size: 400px;
}
```