
# Callbacks回调

1. 借助Callbacks函数，构建回调环境，几个参数的作用
   1) 什么参数都不传递，效果
      1) 构建一个回调函数执行完不销毁的环境
      2) 即: 储存在回调机制中那些方法，执行完还存在，不像队列一样执行完就销毁了
      3) 具体代码: `const cb = $.Callbacks()`
   2) 传递字符串`'once'`，效果
      1) 构建一个回调函数执行完销毁的环境
      2) 即: 通过`fire`方法，进行过回调执行，回调完成，直接清空整个队列中的方法
      3) 下次在使用`fire`方法，进行回调执行没有效果
         1) 并且无法再次通过add方法进行函数的存放
      4) 具体代码: `const cb = $.Callbacks('once')`
   3) 传递字符串`'unique'`，效果
      1) 构建一个自动去重的回调环境
      2) 即: 一个函数被注册(存储)多次(函数索引一样)，后面的会自动忽略，即进行去重
      3) 如果不进行去重处理，则一个函数可以存储多次
      4) 具体代码: `const cb = $.Callbacks('unique')`
   4) 传递字符串`'memory'`，效果
      1) 构建一个带有执行函数的记忆功能的回调环境
      2) 即: 该环境中存放的回调函数，被`fire`方法，进行过回调执行(函数执行)，就会进行标记
      3) 后期在往该环境中存放回调函数，会自动进行回调
      4) 具体代码: `const cb = $.Callbacks('memory')`
   5) 传递字符串`'stopOnFalse'`，效果
      1) 构建一个回调函数中如果返回false就停止回调的环境
      2) 即: 通过`fire`方法，进行过回调执行(函数执行)
      3) 如果某个函数在执行过程中返回`false`，立即终止回调
         1) 回调方法，类似队列的方式，存放在环境中
         2) 通过`fire`方法，进行过回调执行，会一个接着一个的进行回调执行，直到最后一个
      4) 如果回调函数，进行阻止，并没有执行完
         1) 如果创建的环境，使用`'once'`进行了限制，哪怕没有执行完，依旧会清空整个对列
         2) 并不是执行几个，销毁几个，再次调用`fire`方法，会继续回调剩余的方法
         3) 而是，再次调用`fire`方法，没有效果，队列已经清空
      5) 具体代码: `const cb = $.Callbacks('stopOnFalse')`
   6) 上面限制回调环境的字符串，可以联合使用
      1) 回调环境，具有了多个限制条件
      2) 示范代码: `const cb = $.Callbacks('memory stopOnFalse')`
         1) 构成的回调环境就同时具备`memory`和`stopOnFalse`这两个的各自的作用
         2) 即记忆回调触发和阻止回调


2. 借助add函数，注册回调函数
   1) add函数，是Callbacks函数构建环境时，返回的对象中的一个方法
   2) **add函数，也存在返回值，即构建的环境对象，所以add可以实现链式调用**
   3) add函数，可以一次只传入一个方法，多次调用，注册多个回调函数
   4) add函数，可以一次传入多个方法，一次调用，注册多个回调函数


3. 借助fire函数，触发回调环境中注册的回调方法
   1) fire函数，是Callbacks函数构建环境时，返回的对象中的一个方法
   2) **file函数，也存在返回值，即构建的环境对象，所以fire可以实现链式调用**
   3) fire可以传递数据，传递的数据，会传入每一个回调函数中，即回调函数接收的数据是相同的
   4) 如果环境是`once`，该函数一经调用，会清空整个队列，无论是否进行了阻断
      1) 再次调用该函数，没有效果

      
