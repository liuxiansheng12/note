# 重新渲染过程中，各个函数的执行顺序

1. 先`watch`中定义的函数
   1) 不能在函数内部，修改被函数侦听的状态，否则陷入死循环
2. 然后是生命周期函数`beforeUpdate`
   1) 可以在该函数中，修改状态，并不会陷入死循环
   2) 下面三个函数，对应的状态，则为现在修改后的状态
   3) 在该函数中，修改状态，并不会立即触发对应的侦听器函数
   4) 而是先执行`filter`和`directive`中定义的函数
   5) 然后在触发侦听器函数，最终在触发生命周期`updated`函数
3. 然后是`filter`中定义的函数
   1) 函数内部的this指向`undefined`
4. 然后在`directive`中定义的函数
   1) 函数内部的this指向`undefined`
5. 然后是生命周期函数`updated`
   1) 内部的this，指向当前组件的环境
   2) 但是不能修改状态，否则会陷入死循环，最终报栈溢出的错误