

# 迭代器与迭代器生成函数

## 迭代器
1. 迭代的表现形式
   1) 迭代与遍历，在本质上有本质的区别
   2) 遍历是直接操作数据，迭代操作的是第三方工具，第三方工具操作数据
   3) 迭代是迭代一次，取一次的数据。并不关心数据是否取完
   4) 迭代关系的是取多少数据，而不是取多少次取完，迭代是不知道数据是否取完的


2. 迭代器
   1) 迭代器是一个对象，对象中必须存在一个`next方法`。
   2) next方法必须返回一个对象，对象中有两个属性，一个是`value`，一个是`done`
      1) value对应的属性值为本次迭代取出的数据
      2) done对应的属性值表示是否迭代到了最后一个数据
      3) 如果迭代到最后一个数据
         1) 下次再进行迭代时value为undefined，表示没有数据了，done变为true
      4) 如果没有迭代完，done为false。

3. 迭代器的示范代码
```js
const a = {
    next() {
        // 进行其他操作
        const a = {
            value: ?,
            done: ?
        }
        // 进行其他操作
        return a;
    }
}
```


## 迭代器生成函数

1. 作用
   1) 就是一个普通的函数，但是该函数返回一个迭代器对象

2. 示范代码
```js
function a() {
    return {
        next() {
            // 进行其他操作
            const a = {
                value: ?,
                done: ?
            }
            // 进行其他操作
            return a;
        }
    }
}
```



# 可迭代协议与for-of之间的关系

1. 可迭代协议
   1) 一个数据集合(对象)上存在一个特殊的属性，为Symbol的知名符号`Symbol.iterator`
   2) 该属性的属性值为一个迭代器创建函数，即通过该函数可以创建出一个迭代器
   3) 创建出的迭代器，可以迭代该集合。

2. 作用
   1) 只要一个集合具有可迭代协议(特殊属性)，无论是在本身上还是原型上
   2) 就可以使用该属性创建迭代器，迭代该集合
   3) 普通的对象是没有可迭代协议的，数组具有可迭代协议
      1) 数组的可迭代协议存在于`Array.prototype`上


3. 可迭代协议的使用示范代码
```js
const a = [1, 2];

// 使用可迭代协议创建一个迭代器
const iterator = a[Symbol.iterator]();

// 迭代一次，打印{value: 1, done: false}
console.log(iterator.next());
// 迭代一次，打印{value: 2, done: false}
console.log(iterator.next());
// 迭代一次，打印{value: undefined, done: true}，迭代完成
console.log(iterator.next());
```


4. 仿写数组的可迭代协议(迭代器生成函数)
   1) 数组的可迭代协议存在于`Array.prototype`
   2) 可以直接对其进行重写，实现的功能一样
```js
// 重写数组的可迭代协议
Object.defineProperty(Array.prototype, Symbol.iterator, {
    value: function (){
        let i = 0;
        const _this = this;
        return {
            next() {
                const d = {
                    value: _this[i],
                    done: i >= _this.length
                }
                i ++;
                return d
            }
        }
    } 
})
```


5. for-of的作用
   1) 一直迭代某个集合，直到不能迭代为止，并且可以获取到每次迭代的数据


6. 可迭代协议与for-of之间的关系
   1) for-of是一个语法糖
   2) for-of的底层原理
      1) for-of可以迭代一个具有迭代协议的集合
      2) 所以底层一定是调用了`Symbol.iterator`属性对应的函数，创建迭代器
      3) 然后进行循环迭代，并且判断done的属性值是否为true
      4) 当done的值为false的时候，表示还可以继续迭代，循环迭代
      5) 当done的值为true的时候，表示不可以继续迭代，停止循环迭代完成
   3) 底层代码如下
   ```js
   // 使用可迭代协议创建一个迭代器
   const iterator = a[Symbol.iterator]();
   // 先取一次数据
   let iter = iterator.next();
   // 进行循环
   while(!iter.done) {
       // 如果iter.done为false，表示本次迭代还有数据，可以继续迭代
       // 如果iter.done为ture，表示本次迭代没有数据，循环进不去，迭代结束
       const prop = iter.value;
       
       /********for-of循环中的代码体*********/
       // 
       // prop也是for-of声明的数据，由于底层是定义在while中
       // 每次都重新声明数据，不存在替换的现象，所以可以使用const定义数据
       // for循环不是语法糖，变量只声明一次，然后进行替换，所以只能使用let定义数据
       console.log(prop);
       /*************             **********/

       // 进行下一次迭代，重新赋值，进行判断
       iter = iterator.next();
   }
   ```


7. 点点点运算符与可迭代协议之间的关系
   1) Es6中: 点点点运算符底层的实现原理，与for-of循环相同
      1) 利用`Symbol.iterator`属性对应的函数，创建迭代器
      2) 然后进行循环迭代，并且判断done的属性值是否为true
      3) 当done的值为false的时候，表示还可以继续迭代，循环迭代
      4) 当done的值为true的时候，表示不可以继续迭代，停止循环迭代完成
      5) 并且把每次迭代出来的数据，展示出来
   2) Es7中: 对点点点运算符进行了功能增强
      1) 使其可以迭代对象，但是底层使用的不是迭代原理，对象是无法被迭代的





# 生成器

1. 作用
   1) 生成器最初创建的目的，简化迭代器的书写
   2) **为迭代提供数据**

2. 生成器解决的现象
   1) 迭代的原理
      1) 一次取一个数据
      2) 可以理解为调用一次next，经过一系列复杂的函数处理，返回一个对象
   2) 生成器解决的现象
      1) 迭代一次取一个数据，取出的数据可能在next内部进行了复杂的处理
      2) 并且是根据将要迭代的集合数据进行了复杂的处理
      3) 如果集合每次迭代一个数据，处理方式不同
      4) 这样迭代器的next构建起来就非常麻烦(既复杂，每次迭代处理方式还不同)
      5) 生成器就可以快速的构建出这个复杂的生成器
         1) 每次迭代，对数据的处理不同(可以相同)，然后返回迭代的数据

3. 生成器的创建方法
   1) 生成器不能直接创建(底层API不开放)
   2) 可以通过生成器创建函数，创建一个生成器
   3) **只要在函数名的前面加*，该函数就变成了生成器函数**
      1) 匿名函数，在()的前面加上*
      2) 普通函数转换成生成器函数，就会失去原先的功能
   4) 调用生成器创建函数，默认返回一个生成器函数
      1) 内部的代码体，会放在一个特殊的地方(调用函数不会进行执行)
      2) 内部代码变成迭代执行的代码，使用next才进行执行


4. 生成器的使用
   1) 生成器是为了给迭代提供数据，所以就需要有指令提供数据
      1) 迭代一次，运行一部分生成器中的代码，然后返回迭代到的数据
   2) `yield指令`
      1) 调用一次next方法，生成器函数中的代码执行一次，执行完yield后面的表达式，停止执行
      2) 然后把yield后面表达式的值，赋给迭代返回的对象中的value属性，作为本次迭代得到的值
      3) **done属性一定为false**，代码停止还没有运行完，哪怕yield在函数的最后
         1) 函数最后为return，虽然没写，但是会自动添加，返回undefined
         2) 所以，虽然yield写在最后，实际后面还有代码，表示当前生成器还可以进行迭代
         3) done的属性值自然为false
      4) **下次迭代，从上次迭代的位置(yield)开始执行，执行完下一个yield后方的表达式**
   3) `return指令(表示迭代完成)`
      1) 如果生成器函数中没有yield关键字，进行迭代(运行next)，会一直运行到结束
      2) 如果生成器函数中存在yield关键字，以yield为分界线，迭代一次运行一段代码
      3) return的作用
         1) 标记，生成器的最后一次迭代
            1) 如果某次迭代，运行了生成器的return，表示生成器中定义的代码已经运行完成
            2) 本次迭代是最后一次迭代
         2) 把return值，作为本次迭代的数据返回，如果没有返回值，为undefined
         3) 与正常迭代不同之处
            1) 如果生成器存在return，则迭代出的对象，value属性有值
            2) 但是done属性的值为true，表示迭代完成
            3) 正常迭代器，done为true，value为undefined


5. yield指令的使用
   1) 分割生成器中的代码，迭代一次运行一段代码
   2) yield指令，与赋值符号一起运用的原理
      1) 比如: const a = yield ?
      2) 并不是yield后面的表达式运行结果赋值给a，作为本次迭代的返回数据
      3) **迭代一次运行完yield后面的表达式，返回表达式值，就会立刻停止执行**
      4) 即，虽然赋值符号与yield写在一起，但是并没有被解析
      5) 解析时间: 进行下一次迭代，代码重新执行，此时才会解析赋值符号进行赋值
         1) **此时迭代，就已经与上一次迭代无关了**
         2) 所以赋值符号使用的也不是上一次迭代的结果
         3) 迭代，就是运行next方法，next方法运行值可以传递参数
         4) 赋值符号使用的就是本次迭代，next的传参，把传参赋值给a


6. 生成器的原理
   1) 生成器就是一个特殊的对象
   2) 该对象即使一个迭代器，存在next属性(迭代调用的方法)
   3) 该对象也是一个具有可迭代协议的对象，存在知名符号`Symbol.iterator`
   4) 生成器创建函数中的代码，按照yield拆分完，放在一个集合中
      1) 迭代一次，运行一段代码

7. 生成器的示范代码
```js
function * a() {
    const a = yield 1;
    // 打印b
    console.log(a);
    const b = yield 2;
    // 打印c
    console.log(b);
    return 3;
}

// 创建生成器
const sheng = a();
// 迭代一次，打印{value: 1, done: false}
console.log(sheng.next("a"));
// 迭代一次，打印{value: 2, done: false}
console.log(sheng.next("b"));
// 迭代一次(结束)，打印{value: 3, done: true}
console.log(sheng.next("c"));
```


#  生成器与promise的配合使用
1. 使用原理
   1) yield后面跟的表达式，返回一个promise对象
   2) 使用生成器创建函数，创建生成器
   3) 生成器调用next，进行迭代，得到的迭代数据对象的value属性就是一个promise对象
   4) 给promise对象绑定状态，当promise对象的状态改变，触发成功回调函数
   5) 成功回调函数中，在调用生成器的next方法，继续迭代
   6) 并且传入成功回调函数接收的参数(上次迭代得到的promise对象的状态改变时的传参)
   7) 可以使用递归的方式，进行生成器的迭代

2. 示范代码
```js
function * a() {
    const a = yield fetch("http://127.0.0.1:10086/a");
    const ajie = yield a.text();
    console.log(ajie);
    const b = yield fetch("http://127.0.0.1:10086/b");
    const bjie = yield b.text();
    console.log(bjie);
    const c = yield fetch("http://127.0.0.1:10086/c");
    const cjie = yield c.text();
    console.log(cjie);
    return cjie;
}

// 创建一个生成器
const f = a();

function d(res) {
    // 进行一次迭代(返回一个对象，对象中的value属性是一个promise对象)
    const pro = f.next(res);
    // 判断是否迭代完成，迭代完成，该属性为true
    if(pro.done) {
        console.log(pro, "结束");
        return pro.value;
    }
    // 如果没有迭代完成，给promise对象绑定回调函数
    pro.value.then( (res) => {
        // 如果promise对象变为成功状态，表示promise对象的功能处理完成
        // 可以进行下一次的迭代处理，进行递归
        d(res);
    } )
}
d();
```


# 使用点点点运算符和for-of循环迭代生成器
1. 只要具有可迭代协议，就可以使用点点点运算符和for-of循环进行迭代
   1) 生成器的原型上就具有可迭代协议，所以是可以使用点点点运算符和for-of循环迭代生成器


2. **点点点运算符与for-of获取不到return的返回值**

3. for-of和点点点，只有迭代返回对象的`done`属性的属性值为`false`，才展示迭代出的数据
   1) 但是，生成器构建函数的return返回值，虽然可以迭代出数据
   2) 但是`done`属性的属性值变成了`true`，所以点点点运算符获取不到
   3) for-of循环中的运算程序，也不会进去，条件不满足
   4) 迭代还是要进行迭代的，只不过获取不到数据(迭代三次，获取两次的数据)
   5) 只能获取`yield`指令后面的，表达式运算出的结果

4. 由于点点点与for-of循环，底层借助的也是next函数
   1) 前面手动调用了几次next方法
   2) **后面在使用for-of的时候，从对应位置，继续迭代，不会从开始位置迭代**
   3) 比如: 前面调用了两次next函数，使用for-of时候，从第三个位置开始迭代




